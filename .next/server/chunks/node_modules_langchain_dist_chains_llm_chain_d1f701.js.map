{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/langchain/dist/chains/llm_chain.js"],"sourcesContent":["import { BaseLanguageModel, } from \"@langchain/core/language_models/base\";\nimport { BasePromptTemplate } from \"@langchain/core/prompts\";\nimport { Runnable } from \"@langchain/core/runnables\";\nimport { BaseChain } from \"./base.js\";\nimport { NoOpOutputParser } from \"../output_parsers/noop.js\";\nfunction isBaseLanguageModel(llmLike) {\n    return typeof llmLike._llmType === \"function\";\n}\nfunction _getLanguageModel(llmLike) {\n    if (isBaseLanguageModel(llmLike)) {\n        return llmLike;\n    }\n    else if (\"bound\" in llmLike && Runnable.isRunnable(llmLike.bound)) {\n        return _getLanguageModel(llmLike.bound);\n    }\n    else if (\"runnable\" in llmLike &&\n        \"fallbacks\" in llmLike &&\n        Runnable.isRunnable(llmLike.runnable)) {\n        return _getLanguageModel(llmLike.runnable);\n    }\n    else if (\"default\" in llmLike && Runnable.isRunnable(llmLike.default)) {\n        return _getLanguageModel(llmLike.default);\n    }\n    else {\n        throw new Error(\"Unable to extract BaseLanguageModel from llmLike object.\");\n    }\n}\n/**\n * @deprecated This class will be removed in 1.0.0. Use the LangChain Expression Language (LCEL) instead.\n * See the example below for how to use LCEL with the LLMChain class:\n *\n * Chain to run queries against LLMs.\n *\n * @example\n * ```ts\n * import { ChatPromptTemplate } from \"@langchain/core/prompts\";\n * import { ChatOpenAI } from \"@langchain/openai\";\n *\n * const prompt = ChatPromptTemplate.fromTemplate(\"Tell me a {adjective} joke\");\n * const llm = new ChatOpenAI();\n * const chain = prompt.pipe(llm);\n *\n * const response = await chain.invoke({ adjective: \"funny\" });\n * ```\n */\nexport class LLMChain extends BaseChain {\n    static lc_name() {\n        return \"LLMChain\";\n    }\n    get inputKeys() {\n        return this.prompt.inputVariables;\n    }\n    get outputKeys() {\n        return [this.outputKey];\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"prompt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"llm\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"llmKwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"text\"\n        });\n        Object.defineProperty(this, \"outputParser\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.prompt = fields.prompt;\n        this.llm = fields.llm;\n        this.llmKwargs = fields.llmKwargs;\n        this.outputKey = fields.outputKey ?? this.outputKey;\n        this.outputParser =\n            fields.outputParser ?? new NoOpOutputParser();\n        if (this.prompt.outputParser) {\n            if (fields.outputParser) {\n                throw new Error(\"Cannot set both outputParser and prompt.outputParser\");\n            }\n            this.outputParser = this.prompt.outputParser;\n        }\n    }\n    getCallKeys() {\n        const callKeys = \"callKeys\" in this.llm ? this.llm.callKeys : [];\n        return callKeys;\n    }\n    /** @ignore */\n    _selectMemoryInputs(values) {\n        const valuesForMemory = super._selectMemoryInputs(values);\n        const callKeys = this.getCallKeys();\n        for (const key of callKeys) {\n            if (key in values) {\n                delete valuesForMemory[key];\n            }\n        }\n        return valuesForMemory;\n    }\n    /** @ignore */\n    async _getFinalOutput(generations, promptValue, runManager) {\n        let finalCompletion;\n        if (this.outputParser) {\n            finalCompletion = await this.outputParser.parseResultWithPrompt(generations, promptValue, runManager?.getChild());\n        }\n        else {\n            finalCompletion = generations[0].text;\n        }\n        return finalCompletion;\n    }\n    /**\n     * Run the core logic of this chain and add to output if desired.\n     *\n     * Wraps _call and handles memory.\n     */\n    call(values, config) {\n        return super.call(values, config);\n    }\n    /** @ignore */\n    async _call(values, runManager) {\n        const valuesForPrompt = { ...values };\n        const valuesForLLM = {\n            ...this.llmKwargs,\n        };\n        const callKeys = this.getCallKeys();\n        for (const key of callKeys) {\n            if (key in values) {\n                if (valuesForLLM) {\n                    valuesForLLM[key] =\n                        values[key];\n                    delete valuesForPrompt[key];\n                }\n            }\n        }\n        const promptValue = await this.prompt.formatPromptValue(valuesForPrompt);\n        if (\"generatePrompt\" in this.llm) {\n            const { generations } = await this.llm.generatePrompt([promptValue], valuesForLLM, runManager?.getChild());\n            return {\n                [this.outputKey]: await this._getFinalOutput(generations[0], promptValue, runManager),\n            };\n        }\n        const modelWithParser = this.outputParser\n            ? this.llm.pipe(this.outputParser)\n            : this.llm;\n        const response = await modelWithParser.invoke(promptValue, runManager?.getChild());\n        return {\n            [this.outputKey]: response,\n        };\n    }\n    /**\n     * Format prompt with values and pass to LLM\n     *\n     * @param values - keys to pass to prompt template\n     * @param callbackManager - CallbackManager to use\n     * @returns Completion from LLM.\n     *\n     * @example\n     * ```ts\n     * llm.predict({ adjective: \"funny\" })\n     * ```\n     */\n    async predict(values, callbackManager) {\n        const output = await this.call(values, callbackManager);\n        return output[this.outputKey];\n    }\n    _chainType() {\n        return \"llm\";\n    }\n    static async deserialize(data) {\n        const { llm, prompt } = data;\n        if (!llm) {\n            throw new Error(\"LLMChain must have llm\");\n        }\n        if (!prompt) {\n            throw new Error(\"LLMChain must have prompt\");\n        }\n        return new LLMChain({\n            llm: await BaseLanguageModel.deserialize(llm),\n            prompt: await BasePromptTemplate.deserialize(prompt),\n        });\n    }\n    /** @deprecated */\n    serialize() {\n        const serialize = \"serialize\" in this.llm ? this.llm.serialize() : undefined;\n        return {\n            _type: `${this._chainType()}_chain`,\n            llm: serialize,\n            prompt: this.prompt.serialize(),\n        };\n    }\n    _getNumTokens(text) {\n        return _getLanguageModel(this.llm).getNumTokens(text);\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 204, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}