{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@langchain/core/dist/prompts/prompt.js"],"sourcesContent":["// Default generic \"any\" values are for backwards compatibility.\n// Replace with \"string\" when we are comfortable with a breaking change.\nimport { BaseStringPromptTemplate } from \"./string.js\";\nimport { checkValidTemplate, parseTemplate, renderTemplate, } from \"./template.js\";\n/**\n * Schema to represent a basic prompt for an LLM.\n * @augments BasePromptTemplate\n * @augments PromptTemplateInput\n *\n * @example\n * ```ts\n * import { PromptTemplate } from \"langchain/prompts\";\n *\n * const prompt = new PromptTemplate({\n *   inputVariables: [\"foo\"],\n *   template: \"Say {foo}\",\n * });\n * ```\n */\nexport class PromptTemplate extends BaseStringPromptTemplate {\n    static lc_name() {\n        return \"PromptTemplate\";\n    }\n    constructor(input) {\n        super(input);\n        Object.defineProperty(this, \"template\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"templateFormat\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"f-string\"\n        });\n        Object.defineProperty(this, \"validateTemplate\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        /**\n         * Additional fields which should be included inside\n         * the message content array if using a complex message\n         * content.\n         */\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"additionalContentFields\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // If input is mustache and validateTemplate is not defined, set it to false\n        if (input.templateFormat === \"mustache\" &&\n            input.validateTemplate === undefined) {\n            this.validateTemplate = false;\n        }\n        Object.assign(this, input);\n        if (this.validateTemplate) {\n            if (this.templateFormat === \"mustache\") {\n                throw new Error(\"Mustache templates cannot be validated.\");\n            }\n            let totalInputVariables = this.inputVariables;\n            if (this.partialVariables) {\n                totalInputVariables = totalInputVariables.concat(Object.keys(this.partialVariables));\n            }\n            checkValidTemplate(this.template, this.templateFormat, totalInputVariables);\n        }\n    }\n    _getPromptType() {\n        return \"prompt\";\n    }\n    /**\n     * Formats the prompt template with the provided values.\n     * @param values The values to be used to format the prompt template.\n     * @returns A promise that resolves to a string which is the formatted prompt.\n     */\n    async format(values) {\n        const allValues = await this.mergePartialAndUserVariables(values);\n        return renderTemplate(this.template, this.templateFormat, allValues);\n    }\n    /**\n     * Take examples in list format with prefix and suffix to create a prompt.\n     *\n     * Intended to be used a a way to dynamically create a prompt from examples.\n     *\n     * @param examples - List of examples to use in the prompt.\n     * @param suffix - String to go after the list of examples. Should generally set up the user's input.\n     * @param inputVariables - A list of variable names the final prompt template will expect\n     * @param exampleSeparator - The separator to use in between examples\n     * @param prefix - String that should go before any examples. Generally includes examples.\n     *\n     * @returns The final prompt template generated.\n     */\n    static fromExamples(examples, suffix, inputVariables, exampleSeparator = \"\\n\\n\", prefix = \"\") {\n        const template = [prefix, ...examples, suffix].join(exampleSeparator);\n        return new PromptTemplate({\n            inputVariables,\n            template,\n        });\n    }\n    static fromTemplate(template, options) {\n        const { templateFormat = \"f-string\", ...rest } = options ?? {};\n        const names = new Set();\n        parseTemplate(template, templateFormat).forEach((node) => {\n            if (node.type === \"variable\") {\n                names.add(node.name);\n            }\n        });\n        return new PromptTemplate({\n            // Rely on extracted types\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            inputVariables: [...names],\n            templateFormat,\n            template,\n            ...rest,\n        });\n    }\n    /**\n     * Partially applies values to the prompt template.\n     * @param values The values to be partially applied to the prompt template.\n     * @returns A new instance of PromptTemplate with the partially applied values.\n     */\n    async partial(values) {\n        const newInputVariables = this.inputVariables.filter((iv) => !(iv in values));\n        const newPartialVariables = {\n            ...(this.partialVariables ?? {}),\n            ...values,\n        };\n        const promptDict = {\n            ...this,\n            inputVariables: newInputVariables,\n            partialVariables: newPartialVariables,\n        };\n        return new PromptTemplate(promptDict);\n    }\n    serialize() {\n        if (this.outputParser !== undefined) {\n            throw new Error(\"Cannot serialize a prompt template with an output parser\");\n        }\n        return {\n            _type: this._getPromptType(),\n            input_variables: this.inputVariables,\n            template: this.template,\n            template_format: this.templateFormat,\n        };\n    }\n    static async deserialize(data) {\n        if (!data.template) {\n            throw new Error(\"Prompt template must have a template\");\n        }\n        const res = new PromptTemplate({\n            inputVariables: data.input_variables,\n            template: data.template,\n            templateFormat: data.template_format,\n        });\n        return res;\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 159, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}