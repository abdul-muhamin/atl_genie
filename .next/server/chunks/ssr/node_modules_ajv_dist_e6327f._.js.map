{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/compile/codegen/code.ts"],"sourcesContent":["// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nexport abstract class _CodeOrName {\n  abstract readonly str: string\n  abstract readonly names: UsedNames\n  abstract toString(): string\n  abstract emptyStr(): boolean\n}\n\nexport const IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i\n\nexport class Name extends _CodeOrName {\n  readonly str: string\n  constructor(s: string) {\n    super()\n    if (!IDENTIFIER.test(s)) throw new Error(\"CodeGen: name must be a valid identifier\")\n    this.str = s\n  }\n\n  toString(): string {\n    return this.str\n  }\n\n  emptyStr(): boolean {\n    return false\n  }\n\n  get names(): UsedNames {\n    return {[this.str]: 1}\n  }\n}\n\nexport class _Code extends _CodeOrName {\n  readonly _items: readonly CodeItem[]\n  private _str?: string\n  private _names?: UsedNames\n\n  constructor(code: string | readonly CodeItem[]) {\n    super()\n    this._items = typeof code === \"string\" ? [code] : code\n  }\n\n  toString(): string {\n    return this.str\n  }\n\n  emptyStr(): boolean {\n    if (this._items.length > 1) return false\n    const item = this._items[0]\n    return item === \"\" || item === '\"\"'\n  }\n\n  get str(): string {\n    return (this._str ??= this._items.reduce((s: string, c: CodeItem) => `${s}${c}`, \"\"))\n  }\n\n  get names(): UsedNames {\n    return (this._names ??= this._items.reduce((names: UsedNames, c) => {\n      if (c instanceof Name) names[c.str] = (names[c.str] || 0) + 1\n      return names\n    }, {}))\n  }\n}\n\nexport type CodeItem = Name | string | number | boolean | null\n\nexport type UsedNames = Record<string, number | undefined>\n\nexport type Code = _Code | Name\n\nexport type SafeExpr = Code | number | boolean | null\n\nexport const nil = new _Code(\"\")\n\ntype CodeArg = SafeExpr | string | undefined\n\nexport function _(strs: TemplateStringsArray, ...args: CodeArg[]): _Code {\n  const code: CodeItem[] = [strs[0]]\n  let i = 0\n  while (i < args.length) {\n    addCodeArg(code, args[i])\n    code.push(strs[++i])\n  }\n  return new _Code(code)\n}\n\nconst plus = new _Code(\"+\")\n\nexport function str(strs: TemplateStringsArray, ...args: (CodeArg | string[])[]): _Code {\n  const expr: CodeItem[] = [safeStringify(strs[0])]\n  let i = 0\n  while (i < args.length) {\n    expr.push(plus)\n    addCodeArg(expr, args[i])\n    expr.push(plus, safeStringify(strs[++i]))\n  }\n  optimize(expr)\n  return new _Code(expr)\n}\n\nexport function addCodeArg(code: CodeItem[], arg: CodeArg | string[]): void {\n  if (arg instanceof _Code) code.push(...arg._items)\n  else if (arg instanceof Name) code.push(arg)\n  else code.push(interpolate(arg))\n}\n\nfunction optimize(expr: CodeItem[]): void {\n  let i = 1\n  while (i < expr.length - 1) {\n    if (expr[i] === plus) {\n      const res = mergeExprItems(expr[i - 1], expr[i + 1])\n      if (res !== undefined) {\n        expr.splice(i - 1, 3, res)\n        continue\n      }\n      expr[i++] = \"+\"\n    }\n    i++\n  }\n}\n\nfunction mergeExprItems(a: CodeItem, b: CodeItem): CodeItem | undefined {\n  if (b === '\"\"') return a\n  if (a === '\"\"') return b\n  if (typeof a == \"string\") {\n    if (b instanceof Name || a[a.length - 1] !== '\"') return\n    if (typeof b != \"string\") return `${a.slice(0, -1)}${b}\"`\n    if (b[0] === '\"') return a.slice(0, -1) + b.slice(1)\n    return\n  }\n  if (typeof b == \"string\" && b[0] === '\"' && !(a instanceof Name)) return `\"${a}${b.slice(1)}`\n  return\n}\n\nexport function strConcat(c1: Code, c2: Code): Code {\n  return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`\n}\n\n// TODO do not allow arrays here\nfunction interpolate(x?: string | string[] | number | boolean | null): SafeExpr | string {\n  return typeof x == \"number\" || typeof x == \"boolean\" || x === null\n    ? x\n    : safeStringify(Array.isArray(x) ? x.join(\",\") : x)\n}\n\nexport function stringify(x: unknown): Code {\n  return new _Code(safeStringify(x))\n}\n\nexport function safeStringify(x: unknown): string {\n  return JSON.stringify(x)\n    .replace(/\\u2028/g, \"\\\\u2028\")\n    .replace(/\\u2029/g, \"\\\\u2029\")\n}\n\nexport function getProperty(key: Code | string | number): Code {\n  return typeof key == \"string\" && IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`\n}\n\n//Does best effort to format the name properly\nexport function getEsmExportName(key: Code | string | number): Code {\n  if (typeof key == \"string\" && IDENTIFIER.test(key)) {\n    return new _Code(`${key}`)\n  }\n  throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`)\n}\n\nexport function regexpCode(rx: RegExp): Code {\n  return new _Code(rx.toString())\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 153, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 157, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/compile/codegen/scope.ts"],"sourcesContent":["import {_, nil, Code, Name} from \"./code\"\n\ninterface NameGroup {\n  prefix: string\n  index: number\n}\n\nexport interface NameValue {\n  ref: ValueReference // this is the reference to any value that can be referred to from generated code via `globals` var in the closure\n  key?: unknown // any key to identify a global to avoid duplicates, if not passed ref is used\n  code?: Code // this is the code creating the value needed for standalone code wit_out closure - can be a primitive value, function or import (`require`)\n}\n\nexport type ValueReference = unknown // possibly make CodeGen parameterized type on this type\n\nclass ValueError extends Error {\n  readonly value?: NameValue\n  constructor(name: ValueScopeName) {\n    super(`CodeGen: \"code\" for ${name} not defined`)\n    this.value = name.value\n  }\n}\n\ninterface ScopeOptions {\n  prefixes?: Set<string>\n  parent?: Scope\n}\n\ninterface ValueScopeOptions extends ScopeOptions {\n  scope: ScopeStore\n  es5?: boolean\n  lines?: boolean\n}\n\nexport type ScopeStore = Record<string, ValueReference[] | undefined>\n\ntype ScopeValues = {\n  [Prefix in string]?: Map<unknown, ValueScopeName>\n}\n\nexport type ScopeValueSets = {\n  [Prefix in string]?: Set<ValueScopeName>\n}\n\nexport enum UsedValueState {\n  Started,\n  Completed,\n}\n\nexport type UsedScopeValues = {\n  [Prefix in string]?: Map<ValueScopeName, UsedValueState | undefined>\n}\n\nexport const varKinds = {\n  const: new Name(\"const\"),\n  let: new Name(\"let\"),\n  var: new Name(\"var\"),\n}\n\nexport class Scope {\n  protected readonly _names: {[Prefix in string]?: NameGroup} = {}\n  protected readonly _prefixes?: Set<string>\n  protected readonly _parent?: Scope\n\n  constructor({prefixes, parent}: ScopeOptions = {}) {\n    this._prefixes = prefixes\n    this._parent = parent\n  }\n\n  toName(nameOrPrefix: Name | string): Name {\n    return nameOrPrefix instanceof Name ? nameOrPrefix : this.name(nameOrPrefix)\n  }\n\n  name(prefix: string): Name {\n    return new Name(this._newName(prefix))\n  }\n\n  protected _newName(prefix: string): string {\n    const ng = this._names[prefix] || this._nameGroup(prefix)\n    return `${prefix}${ng.index++}`\n  }\n\n  private _nameGroup(prefix: string): NameGroup {\n    if (this._parent?._prefixes?.has(prefix) || (this._prefixes && !this._prefixes.has(prefix))) {\n      throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`)\n    }\n    return (this._names[prefix] = {prefix, index: 0})\n  }\n}\n\ninterface ScopePath {\n  property: string\n  itemIndex: number\n}\n\nexport class ValueScopeName extends Name {\n  readonly prefix: string\n  value?: NameValue\n  scopePath?: Code\n\n  constructor(prefix: string, nameStr: string) {\n    super(nameStr)\n    this.prefix = prefix\n  }\n\n  setValue(value: NameValue, {property, itemIndex}: ScopePath): void {\n    this.value = value\n    this.scopePath = _`.${new Name(property)}[${itemIndex}]`\n  }\n}\n\ninterface VSOptions extends ValueScopeOptions {\n  _n: Code\n}\n\nconst line = _`\\n`\n\nexport class ValueScope extends Scope {\n  protected readonly _values: ScopeValues = {}\n  protected readonly _scope: ScopeStore\n  readonly opts: VSOptions\n\n  constructor(opts: ValueScopeOptions) {\n    super(opts)\n    this._scope = opts.scope\n    this.opts = {...opts, _n: opts.lines ? line : nil}\n  }\n\n  get(): ScopeStore {\n    return this._scope\n  }\n\n  name(prefix: string): ValueScopeName {\n    return new ValueScopeName(prefix, this._newName(prefix))\n  }\n\n  value(nameOrPrefix: ValueScopeName | string, value: NameValue): ValueScopeName {\n    if (value.ref === undefined) throw new Error(\"CodeGen: ref must be passed in value\")\n    const name = this.toName(nameOrPrefix) as ValueScopeName\n    const {prefix} = name\n    const valueKey = value.key ?? value.ref\n    let vs = this._values[prefix]\n    if (vs) {\n      const _name = vs.get(valueKey)\n      if (_name) return _name\n    } else {\n      vs = this._values[prefix] = new Map()\n    }\n    vs.set(valueKey, name)\n\n    const s = this._scope[prefix] || (this._scope[prefix] = [])\n    const itemIndex = s.length\n    s[itemIndex] = value.ref\n    name.setValue(value, {property: prefix, itemIndex})\n    return name\n  }\n\n  getValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    const vs = this._values[prefix]\n    if (!vs) return\n    return vs.get(keyOrRef)\n  }\n\n  scopeRefs(scopeName: Name, values: ScopeValues | ScopeValueSets = this._values): Code {\n    return this._reduceValues(values, (name: ValueScopeName) => {\n      if (name.scopePath === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n      return _`${scopeName}${name.scopePath}`\n    })\n  }\n\n  scopeCode(\n    values: ScopeValues | ScopeValueSets = this._values,\n    usedValues?: UsedScopeValues,\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    return this._reduceValues(\n      values,\n      (name: ValueScopeName) => {\n        if (name.value === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n        return name.value.code\n      },\n      usedValues,\n      getCode\n    )\n  }\n\n  private _reduceValues(\n    values: ScopeValues | ScopeValueSets,\n    valueCode: (n: ValueScopeName) => Code | undefined,\n    usedValues: UsedScopeValues = {},\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    let code: Code = nil\n    for (const prefix in values) {\n      const vs = values[prefix]\n      if (!vs) continue\n      const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map())\n      vs.forEach((name: ValueScopeName) => {\n        if (nameSet.has(name)) return\n        nameSet.set(name, UsedValueState.Started)\n        let c = valueCode(name)\n        if (c) {\n          const def = this.opts.es5 ? varKinds.var : varKinds.const\n          code = _`${code}${def} ${name} = ${c};${this.opts._n}`\n        } else if ((c = getCode?.(name))) {\n          code = _`${code}${c}${this.opts._n}`\n        } else {\n          throw new ValueError(name)\n        }\n        nameSet.set(name, UsedValueState.Completed)\n      })\n    }\n    return code\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 300, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 304, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/compile/codegen/index.ts"],"sourcesContent":["import type {ScopeValueSets, NameValue, ValueScope, ValueScopeName} from \"./scope\"\nimport {_, nil, _Code, Code, Name, UsedNames, CodeItem, addCodeArg, _CodeOrName} from \"./code\"\nimport {Scope, varKinds} from \"./scope\"\n\nexport {_, str, strConcat, nil, getProperty, stringify, regexpCode, Name, Code} from \"./code\"\nexport {Scope, ScopeStore, ValueScope, ValueScopeName, ScopeValueSets, varKinds} from \"./scope\"\n\n// type for expressions that can be safely inserted in code without quotes\nexport type SafeExpr = Code | number | boolean | null\n\n// type that is either Code of function that adds code to CodeGen instance using its methods\nexport type Block = Code | (() => void)\n\nexport const operators = {\n  GT: new _Code(\">\"),\n  GTE: new _Code(\">=\"),\n  LT: new _Code(\"<\"),\n  LTE: new _Code(\"<=\"),\n  EQ: new _Code(\"===\"),\n  NEQ: new _Code(\"!==\"),\n  NOT: new _Code(\"!\"),\n  OR: new _Code(\"||\"),\n  AND: new _Code(\"&&\"),\n  ADD: new _Code(\"+\"),\n}\n\nabstract class Node {\n  abstract readonly names: UsedNames\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    return this\n  }\n\n  optimizeNames(_names: UsedNames, _constants: Constants): this | undefined {\n    return this\n  }\n\n  // get count(): number {\n  //   return 1\n  // }\n}\n\nclass Def extends Node {\n  constructor(\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private rhs?: SafeExpr\n  ) {\n    super()\n  }\n\n  render({es5, _n}: CGOptions): string {\n    const varKind = es5 ? varKinds.var : this.varKind\n    const rhs = this.rhs === undefined ? \"\" : ` = ${this.rhs}`\n    return `${varKind} ${this.name}${rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!names[this.name.str]) return\n    if (this.rhs) this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.rhs instanceof _CodeOrName ? this.rhs.names : {}\n  }\n}\n\nclass Assign extends Node {\n  constructor(\n    readonly lhs: Code,\n    public rhs: SafeExpr,\n    private readonly sideEffects?: boolean\n  ) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} = ${this.rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (this.lhs instanceof Name && !names[this.lhs.str] && !this.sideEffects) return\n    this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = this.lhs instanceof Name ? {} : {...this.lhs.names}\n    return addExprNames(names, this.rhs)\n  }\n}\n\nclass AssignOp extends Assign {\n  constructor(\n    lhs: Code,\n    private readonly op: Code,\n    rhs: SafeExpr,\n    sideEffects?: boolean\n  ) {\n    super(lhs, rhs, sideEffects)\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} ${this.op}= ${this.rhs};` + _n\n  }\n}\n\nclass Label extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label: Name) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.label}:` + _n\n  }\n}\n\nclass Break extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label?: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    const label = this.label ? ` ${this.label}` : \"\"\n    return `break${label};` + _n\n  }\n}\n\nclass Throw extends Node {\n  constructor(readonly error: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `throw ${this.error};` + _n\n  }\n\n  get names(): UsedNames {\n    return this.error.names\n  }\n}\n\nclass AnyCode extends Node {\n  constructor(private code: SafeExpr) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.code};` + _n\n  }\n\n  optimizeNodes(): this | undefined {\n    return `${this.code}` ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    this.code = optimizeExpr(this.code, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.code instanceof _CodeOrName ? this.code.names : {}\n  }\n}\n\nabstract class ParentNode extends Node {\n  constructor(readonly nodes: ChildNode[] = []) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return this.nodes.reduce((code, n) => code + n.render(opts), \"\")\n  }\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      const n = nodes[i].optimizeNodes()\n      if (Array.isArray(n)) nodes.splice(i, 1, ...n)\n      else if (n) nodes[i] = n\n      else nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      // iterating backwards improves 1-pass optimization\n      const n = nodes[i]\n      if (n.optimizeNames(names, constants)) continue\n      subtractNames(names, n.names)\n      nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  get names(): UsedNames {\n    return this.nodes.reduce((names: UsedNames, n) => addNames(names, n.names), {})\n  }\n\n  // get count(): number {\n  //   return this.nodes.reduce((c, n) => c + n.count, 1)\n  // }\n}\n\nabstract class BlockNode extends ParentNode {\n  render(opts: CGOptions): string {\n    return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n\n  }\n}\n\nclass Root extends ParentNode {}\n\nclass Else extends BlockNode {\n  static readonly kind = \"else\"\n}\n\nclass If extends BlockNode {\n  static readonly kind = \"if\"\n  else?: If | Else\n  constructor(\n    private condition: Code | boolean,\n    nodes?: ChildNode[]\n  ) {\n    super(nodes)\n  }\n\n  render(opts: CGOptions): string {\n    let code = `if(${this.condition})` + super.render(opts)\n    if (this.else) code += \"else \" + this.else.render(opts)\n    return code\n  }\n\n  optimizeNodes(): If | ChildNode[] | undefined {\n    super.optimizeNodes()\n    const cond = this.condition\n    if (cond === true) return this.nodes // else is ignored here\n    let e = this.else\n    if (e) {\n      const ns = e.optimizeNodes()\n      e = this.else = Array.isArray(ns) ? new Else(ns) : (ns as Else | undefined)\n    }\n    if (e) {\n      if (cond === false) return e instanceof If ? e : e.nodes\n      if (this.nodes.length) return this\n      return new If(not(cond), e instanceof If ? [e] : e.nodes)\n    }\n    if (cond === false || !this.nodes.length) return undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    this.else = this.else?.optimizeNames(names, constants)\n    if (!(super.optimizeNames(names, constants) || this.else)) return\n    this.condition = optimizeExpr(this.condition, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    addExprNames(names, this.condition)\n    if (this.else) addNames(names, this.else.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.else?.count || 0)\n  // }\n}\n\nabstract class For extends BlockNode {\n  static readonly kind = \"for\"\n}\n\nclass ForLoop extends For {\n  constructor(private iteration: Code) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.iteration})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iteration = optimizeExpr(this.iteration, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iteration.names)\n  }\n}\n\nclass ForRange extends For {\n  constructor(\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private readonly from: SafeExpr,\n    private readonly to: SafeExpr\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const varKind = opts.es5 ? varKinds.var : this.varKind\n    const {name, from, to} = this\n    return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts)\n  }\n\n  get names(): UsedNames {\n    const names = addExprNames(super.names, this.from)\n    return addExprNames(names, this.to)\n  }\n}\n\nclass ForIter extends For {\n  constructor(\n    private readonly loop: \"of\" | \"in\",\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private iterable: Code\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iterable = optimizeExpr(this.iterable, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iterable.names)\n  }\n}\n\nclass Func extends BlockNode {\n  static readonly kind = \"func\"\n  constructor(\n    public name: Name,\n    public args: Code,\n    public async?: boolean\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const _async = this.async ? \"async \" : \"\"\n    return `${_async}function ${this.name}(${this.args})` + super.render(opts)\n  }\n}\n\nclass Return extends ParentNode {\n  static readonly kind = \"return\"\n\n  render(opts: CGOptions): string {\n    return \"return \" + super.render(opts)\n  }\n}\n\nclass Try extends BlockNode {\n  catch?: Catch\n  finally?: Finally\n\n  render(opts: CGOptions): string {\n    let code = \"try\" + super.render(opts)\n    if (this.catch) code += this.catch.render(opts)\n    if (this.finally) code += this.finally.render(opts)\n    return code\n  }\n\n  optimizeNodes(): this {\n    super.optimizeNodes()\n    this.catch?.optimizeNodes() as Catch | undefined\n    this.finally?.optimizeNodes() as Finally | undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    super.optimizeNames(names, constants)\n    this.catch?.optimizeNames(names, constants)\n    this.finally?.optimizeNames(names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    if (this.catch) addNames(names, this.catch.names)\n    if (this.finally) addNames(names, this.finally.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.catch?.count || 0) + (this.finally?.count || 0)\n  // }\n}\n\nclass Catch extends BlockNode {\n  static readonly kind = \"catch\"\n  constructor(readonly error: Name) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `catch(${this.error})` + super.render(opts)\n  }\n}\n\nclass Finally extends BlockNode {\n  static readonly kind = \"finally\"\n  render(opts: CGOptions): string {\n    return \"finally\" + super.render(opts)\n  }\n}\n\ntype StartBlockNode = If | For | Func | Return | Try\n\ntype LeafNode = Def | Assign | Label | Break | Throw | AnyCode\n\ntype ChildNode = StartBlockNode | LeafNode\n\ntype EndBlockNodeType =\n  | typeof If\n  | typeof Else\n  | typeof For\n  | typeof Func\n  | typeof Return\n  | typeof Catch\n  | typeof Finally\n\ntype Constants = Record<string, SafeExpr | undefined>\n\nexport interface CodeGenOptions {\n  es5?: boolean\n  lines?: boolean\n  ownProperties?: boolean\n}\n\ninterface CGOptions extends CodeGenOptions {\n  _n: \"\\n\" | \"\"\n}\n\nexport class CodeGen {\n  readonly _scope: Scope\n  readonly _extScope: ValueScope\n  readonly _values: ScopeValueSets = {}\n  private readonly _nodes: ParentNode[]\n  private readonly _blockStarts: number[] = []\n  private readonly _constants: Constants = {}\n  private readonly opts: CGOptions\n\n  constructor(extScope: ValueScope, opts: CodeGenOptions = {}) {\n    this.opts = {...opts, _n: opts.lines ? \"\\n\" : \"\"}\n    this._extScope = extScope\n    this._scope = new Scope({parent: extScope})\n    this._nodes = [new Root()]\n  }\n\n  toString(): string {\n    return this._root.render(this.opts)\n  }\n\n  // returns unique name in the internal scope\n  name(prefix: string): Name {\n    return this._scope.name(prefix)\n  }\n\n  // reserves unique name in the external scope\n  scopeName(prefix: string): ValueScopeName {\n    return this._extScope.name(prefix)\n  }\n\n  // reserves unique name in the external scope and assigns value to it\n  scopeValue(prefixOrName: ValueScopeName | string, value: NameValue): Name {\n    const name = this._extScope.value(prefixOrName, value)\n    const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set())\n    vs.add(name)\n    return name\n  }\n\n  getScopeValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    return this._extScope.getValue(prefix, keyOrRef)\n  }\n\n  // return code that assigns values in the external scope to the names that are used internally\n  // (same names that were returned by gen.scopeName or gen.scopeValue)\n  scopeRefs(scopeName: Name): Code {\n    return this._extScope.scopeRefs(scopeName, this._values)\n  }\n\n  scopeCode(): Code {\n    return this._extScope.scopeCode(this._values)\n  }\n\n  private _def(\n    varKind: Name,\n    nameOrPrefix: Name | string,\n    rhs?: SafeExpr,\n    constant?: boolean\n  ): Name {\n    const name = this._scope.toName(nameOrPrefix)\n    if (rhs !== undefined && constant) this._constants[name.str] = rhs\n    this._leafNode(new Def(varKind, name, rhs))\n    return name\n  }\n\n  // `const` declaration (`var` in es5 mode)\n  const(nameOrPrefix: Name | string, rhs: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.const, nameOrPrefix, rhs, _constant)\n  }\n\n  // `let` declaration with optional assignment (`var` in es5 mode)\n  let(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.let, nameOrPrefix, rhs, _constant)\n  }\n\n  // `var` declaration with optional assignment\n  var(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.var, nameOrPrefix, rhs, _constant)\n  }\n\n  // assignment code\n  assign(lhs: Code, rhs: SafeExpr, sideEffects?: boolean): CodeGen {\n    return this._leafNode(new Assign(lhs, rhs, sideEffects))\n  }\n\n  // `+=` code\n  add(lhs: Code, rhs: SafeExpr): CodeGen {\n    return this._leafNode(new AssignOp(lhs, operators.ADD, rhs))\n  }\n\n  // appends passed SafeExpr to code or executes Block\n  code(c: Block | SafeExpr): CodeGen {\n    if (typeof c == \"function\") c()\n    else if (c !== nil) this._leafNode(new AnyCode(c))\n    return this\n  }\n\n  // returns code for object literal for the passed argument list of key-value pairs\n  object(...keyValues: [Name | string, SafeExpr | string][]): _Code {\n    const code: CodeItem[] = [\"{\"]\n    for (const [key, value] of keyValues) {\n      if (code.length > 1) code.push(\",\")\n      code.push(key)\n      if (key !== value || this.opts.es5) {\n        code.push(\":\")\n        addCodeArg(code, value)\n      }\n    }\n    code.push(\"}\")\n    return new _Code(code)\n  }\n\n  // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n  if(condition: Code | boolean, thenBody?: Block, elseBody?: Block): CodeGen {\n    this._blockNode(new If(condition))\n\n    if (thenBody && elseBody) {\n      this.code(thenBody).else().code(elseBody).endIf()\n    } else if (thenBody) {\n      this.code(thenBody).endIf()\n    } else if (elseBody) {\n      throw new Error('CodeGen: \"else\" body without \"then\" body')\n    }\n    return this\n  }\n\n  // `else if` clause - invalid without `if` or after `else` clauses\n  elseIf(condition: Code | boolean): CodeGen {\n    return this._elseNode(new If(condition))\n  }\n\n  // `else` clause - only valid after `if` or `else if` clauses\n  else(): CodeGen {\n    return this._elseNode(new Else())\n  }\n\n  // end `if` statement (needed if gen.if was used only with condition)\n  endIf(): CodeGen {\n    return this._endBlockNode(If, Else)\n  }\n\n  private _for(node: For, forBody?: Block): CodeGen {\n    this._blockNode(node)\n    if (forBody) this.code(forBody).endFor()\n    return this\n  }\n\n  // a generic `for` clause (or statement if `forBody` is passed)\n  for(iteration: Code, forBody?: Block): CodeGen {\n    return this._for(new ForLoop(iteration), forBody)\n  }\n\n  // `for` statement for a range of values\n  forRange(\n    nameOrPrefix: Name | string,\n    from: SafeExpr,\n    to: SafeExpr,\n    forBody: (index: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.let\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForRange(varKind, name, from, to), () => forBody(name))\n  }\n\n  // `for-of` statement (in es5 mode replace with a normal for loop)\n  forOf(\n    nameOrPrefix: Name | string,\n    iterable: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = varKinds.const\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    if (this.opts.es5) {\n      const arr = iterable instanceof Name ? iterable : this.var(\"_arr\", iterable)\n      return this.forRange(\"_i\", 0, _`${arr}.length`, (i) => {\n        this.var(name, _`${arr}[${i}]`)\n        forBody(name)\n      })\n    }\n    return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name))\n  }\n\n  // `for-in` statement.\n  // With option `ownProperties` replaced with a `for-of` loop for object keys\n  forIn(\n    nameOrPrefix: Name | string,\n    obj: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.const\n  ): CodeGen {\n    if (this.opts.ownProperties) {\n      return this.forOf(nameOrPrefix, _`Object.keys(${obj})`, forBody)\n    }\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name))\n  }\n\n  // end `for` loop\n  endFor(): CodeGen {\n    return this._endBlockNode(For)\n  }\n\n  // `label` statement\n  label(label: Name): CodeGen {\n    return this._leafNode(new Label(label))\n  }\n\n  // `break` statement\n  break(label?: Code): CodeGen {\n    return this._leafNode(new Break(label))\n  }\n\n  // `return` statement\n  return(value: Block | SafeExpr): CodeGen {\n    const node = new Return()\n    this._blockNode(node)\n    this.code(value)\n    if (node.nodes.length !== 1) throw new Error('CodeGen: \"return\" should have one node')\n    return this._endBlockNode(Return)\n  }\n\n  // `try` statement\n  try(tryBody: Block, catchCode?: (e: Name) => void, finallyCode?: Block): CodeGen {\n    if (!catchCode && !finallyCode) throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"')\n    const node = new Try()\n    this._blockNode(node)\n    this.code(tryBody)\n    if (catchCode) {\n      const error = this.name(\"e\")\n      this._currNode = node.catch = new Catch(error)\n      catchCode(error)\n    }\n    if (finallyCode) {\n      this._currNode = node.finally = new Finally()\n      this.code(finallyCode)\n    }\n    return this._endBlockNode(Catch, Finally)\n  }\n\n  // `throw` statement\n  throw(error: Code): CodeGen {\n    return this._leafNode(new Throw(error))\n  }\n\n  // start self-balancing block\n  block(body?: Block, nodeCount?: number): CodeGen {\n    this._blockStarts.push(this._nodes.length)\n    if (body) this.code(body).endBlock(nodeCount)\n    return this\n  }\n\n  // end the current self-balancing block\n  endBlock(nodeCount?: number): CodeGen {\n    const len = this._blockStarts.pop()\n    if (len === undefined) throw new Error(\"CodeGen: not in self-balancing block\")\n    const toClose = this._nodes.length - len\n    if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {\n      throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`)\n    }\n    this._nodes.length = len\n    return this\n  }\n\n  // `function` heading (or definition if funcBody is passed)\n  func(name: Name, args: Code = nil, async?: boolean, funcBody?: Block): CodeGen {\n    this._blockNode(new Func(name, args, async))\n    if (funcBody) this.code(funcBody).endFunc()\n    return this\n  }\n\n  // end function definition\n  endFunc(): CodeGen {\n    return this._endBlockNode(Func)\n  }\n\n  optimize(n = 1): void {\n    while (n-- > 0) {\n      this._root.optimizeNodes()\n      this._root.optimizeNames(this._root.names, this._constants)\n    }\n  }\n\n  private _leafNode(node: LeafNode): CodeGen {\n    this._currNode.nodes.push(node)\n    return this\n  }\n\n  private _blockNode(node: StartBlockNode): void {\n    this._currNode.nodes.push(node)\n    this._nodes.push(node)\n  }\n\n  private _endBlockNode(N1: EndBlockNodeType, N2?: EndBlockNodeType): CodeGen {\n    const n = this._currNode\n    if (n instanceof N1 || (N2 && n instanceof N2)) {\n      this._nodes.pop()\n      return this\n    }\n    throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`)\n  }\n\n  private _elseNode(node: If | Else): CodeGen {\n    const n = this._currNode\n    if (!(n instanceof If)) {\n      throw new Error('CodeGen: \"else\" without \"if\"')\n    }\n    this._currNode = n.else = node\n    return this\n  }\n\n  private get _root(): Root {\n    return this._nodes[0] as Root\n  }\n\n  private get _currNode(): ParentNode {\n    const ns = this._nodes\n    return ns[ns.length - 1]\n  }\n\n  private set _currNode(node: ParentNode) {\n    const ns = this._nodes\n    ns[ns.length - 1] = node\n  }\n\n  // get nodeCount(): number {\n  //   return this._root.count\n  // }\n}\n\nfunction addNames(names: UsedNames, from: UsedNames): UsedNames {\n  for (const n in from) names[n] = (names[n] || 0) + (from[n] || 0)\n  return names\n}\n\nfunction addExprNames(names: UsedNames, from: SafeExpr): UsedNames {\n  return from instanceof _CodeOrName ? addNames(names, from.names) : names\n}\n\nfunction optimizeExpr<T extends SafeExpr | Code>(expr: T, names: UsedNames, constants: Constants): T\nfunction optimizeExpr(expr: SafeExpr, names: UsedNames, constants: Constants): SafeExpr {\n  if (expr instanceof Name) return replaceName(expr)\n  if (!canOptimize(expr)) return expr\n  return new _Code(\n    expr._items.reduce((items: CodeItem[], c: SafeExpr | string) => {\n      if (c instanceof Name) c = replaceName(c)\n      if (c instanceof _Code) items.push(...c._items)\n      else items.push(c)\n      return items\n    }, [])\n  )\n\n  function replaceName(n: Name): SafeExpr {\n    const c = constants[n.str]\n    if (c === undefined || names[n.str] !== 1) return n\n    delete names[n.str]\n    return c\n  }\n\n  function canOptimize(e: SafeExpr): e is _Code {\n    return (\n      e instanceof _Code &&\n      e._items.some(\n        (c) => c instanceof Name && names[c.str] === 1 && constants[c.str] !== undefined\n      )\n    )\n  }\n}\n\nfunction subtractNames(names: UsedNames, from: UsedNames): void {\n  for (const n in from) names[n] = (names[n] || 0) - (from[n] || 0)\n}\n\nexport function not<T extends Code | SafeExpr>(x: T): T\nexport function not(x: Code | SafeExpr): Code | SafeExpr {\n  return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : _`!${par(x)}`\n}\n\nconst andCode = mappend(operators.AND)\n\n// boolean AND (&&) expression with the passed arguments\nexport function and(...args: Code[]): Code {\n  return args.reduce(andCode)\n}\n\nconst orCode = mappend(operators.OR)\n\n// boolean OR (||) expression with the passed arguments\nexport function or(...args: Code[]): Code {\n  return args.reduce(orCode)\n}\n\ntype MAppend = (x: Code, y: Code) => Code\n\nfunction mappend(op: Code): MAppend {\n  return (x, y) => (x === nil ? y : y === nil ? x : _`${par(x)} ${op} ${par(y)}`)\n}\n\nfunction par(x: Code): Code {\n  return x instanceof Name ? x : _`(${x})`\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1034, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1038, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/compile/util.ts"],"sourcesContent":["import type {AnySchema, EvaluatedProperties, EvaluatedItems} from \"../types\"\nimport type {SchemaCxt, SchemaObjCxt} from \".\"\nimport {_, getProperty, Code, Name, CodeGen} from \"./codegen\"\nimport {_Code} from \"./codegen/code\"\nimport type {Rule, ValidationRules} from \"./rules\"\n\n// TODO refactor to use Set\nexport function toHash<T extends string = string>(arr: T[]): {[K in T]?: true} {\n  const hash: {[K in T]?: true} = {}\n  for (const item of arr) hash[item] = true\n  return hash\n}\n\nexport function alwaysValidSchema(it: SchemaCxt, schema: AnySchema): boolean | void {\n  if (typeof schema == \"boolean\") return schema\n  if (Object.keys(schema).length === 0) return true\n  checkUnknownRules(it, schema)\n  return !schemaHasRules(schema, it.self.RULES.all)\n}\n\nexport function checkUnknownRules(it: SchemaCxt, schema: AnySchema = it.schema): void {\n  const {opts, self} = it\n  if (!opts.strictSchema) return\n  if (typeof schema === \"boolean\") return\n  const rules = self.RULES.keywords\n  for (const key in schema) {\n    if (!rules[key]) checkStrictMode(it, `unknown keyword: \"${key}\"`)\n  }\n}\n\nexport function schemaHasRules(\n  schema: AnySchema,\n  rules: {[Key in string]?: boolean | Rule}\n): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (rules[key]) return true\n  return false\n}\n\nexport function schemaHasRulesButRef(schema: AnySchema, RULES: ValidationRules): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (key !== \"$ref\" && RULES.all[key]) return true\n  return false\n}\n\nexport function schemaRefOrVal(\n  {topSchemaRef, schemaPath}: SchemaObjCxt,\n  schema: unknown,\n  keyword: string,\n  $data?: string | false\n): Code | number | boolean {\n  if (!$data) {\n    if (typeof schema == \"number\" || typeof schema == \"boolean\") return schema\n    if (typeof schema == \"string\") return _`${schema}`\n  }\n  return _`${topSchemaRef}${schemaPath}${getProperty(keyword)}`\n}\n\nexport function unescapeFragment(str: string): string {\n  return unescapeJsonPointer(decodeURIComponent(str))\n}\n\nexport function escapeFragment(str: string | number): string {\n  return encodeURIComponent(escapeJsonPointer(str))\n}\n\nexport function escapeJsonPointer(str: string | number): string {\n  if (typeof str == \"number\") return `${str}`\n  return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\")\n}\n\nexport function unescapeJsonPointer(str: string): string {\n  return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\")\n}\n\nexport function eachItem<T>(xs: T | T[], f: (x: T) => void): void {\n  if (Array.isArray(xs)) {\n    for (const x of xs) f(x)\n  } else {\n    f(xs)\n  }\n}\n\ntype SomeEvaluated = EvaluatedProperties | EvaluatedItems\n\ntype MergeEvaluatedFunc<T extends SomeEvaluated> = (\n  gen: CodeGen,\n  from: Name | T,\n  to: Name | Exclude<T, true> | undefined,\n  toName?: typeof Name\n) => Name | T\n\ninterface MakeMergeFuncArgs<T extends SomeEvaluated> {\n  mergeNames: (gen: CodeGen, from: Name, to: Name) => void\n  mergeToName: (gen: CodeGen, from: T, to: Name) => void\n  mergeValues: (from: T, to: Exclude<T, true>) => T\n  resultToName: (gen: CodeGen, res?: T) => Name\n}\n\nfunction makeMergeEvaluated<T extends SomeEvaluated>({\n  mergeNames,\n  mergeToName,\n  mergeValues,\n  resultToName,\n}: MakeMergeFuncArgs<T>): MergeEvaluatedFunc<T> {\n  return (gen, from, to, toName) => {\n    const res =\n      to === undefined\n        ? from\n        : to instanceof Name\n        ? (from instanceof Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)\n        : from instanceof Name\n        ? (mergeToName(gen, to, from), from)\n        : mergeValues(from, to)\n    return toName === Name && !(res instanceof Name) ? resultToName(gen, res) : res\n  }\n}\n\ninterface MergeEvaluated {\n  props: MergeEvaluatedFunc<EvaluatedProperties>\n  items: MergeEvaluatedFunc<EvaluatedItems>\n}\n\nexport const mergeEvaluated: MergeEvaluated = {\n  props: makeMergeEvaluated({\n    mergeNames: (gen, from, to) =>\n      gen.if(_`${to} !== true && ${from} !== undefined`, () => {\n        gen.if(\n          _`${from} === true`,\n          () => gen.assign(to, true),\n          () => gen.assign(to, _`${to} || {}`).code(_`Object.assign(${to}, ${from})`)\n        )\n      }),\n    mergeToName: (gen, from, to) =>\n      gen.if(_`${to} !== true`, () => {\n        if (from === true) {\n          gen.assign(to, true)\n        } else {\n          gen.assign(to, _`${to} || {}`)\n          setEvaluated(gen, to, from)\n        }\n      }),\n    mergeValues: (from, to) => (from === true ? true : {...from, ...to}),\n    resultToName: evaluatedPropsToName,\n  }),\n  items: makeMergeEvaluated({\n    mergeNames: (gen, from, to) =>\n      gen.if(_`${to} !== true && ${from} !== undefined`, () =>\n        gen.assign(to, _`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)\n      ),\n    mergeToName: (gen, from, to) =>\n      gen.if(_`${to} !== true`, () =>\n        gen.assign(to, from === true ? true : _`${to} > ${from} ? ${to} : ${from}`)\n      ),\n    mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),\n    resultToName: (gen, items) => gen.var(\"items\", items),\n  }),\n}\n\nexport function evaluatedPropsToName(gen: CodeGen, ps?: EvaluatedProperties): Name {\n  if (ps === true) return gen.var(\"props\", true)\n  const props = gen.var(\"props\", _`{}`)\n  if (ps !== undefined) setEvaluated(gen, props, ps)\n  return props\n}\n\nexport function setEvaluated(gen: CodeGen, props: Name, ps: {[K in string]?: true}): void {\n  Object.keys(ps).forEach((p) => gen.assign(_`${props}${getProperty(p)}`, true))\n}\n\nconst snippets: {[S in string]?: _Code} = {}\n\nexport function useFunc(gen: CodeGen, f: {code: string}): Name {\n  return gen.scopeValue(\"func\", {\n    ref: f,\n    code: snippets[f.code] || (snippets[f.code] = new _Code(f.code)),\n  })\n}\n\nexport enum Type {\n  Num,\n  Str,\n}\n\nexport function getErrorPath(\n  dataProp: Name | string | number,\n  dataPropType?: Type,\n  jsPropertySyntax?: boolean\n): Code | string {\n  // let path\n  if (dataProp instanceof Name) {\n    const isNumber = dataPropType === Type.Num\n    return jsPropertySyntax\n      ? isNumber\n        ? _`\"[\" + ${dataProp} + \"]\"`\n        : _`\"['\" + ${dataProp} + \"']\"`\n      : isNumber\n      ? _`\"/\" + ${dataProp}`\n      : _`\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")` // TODO maybe use global escapePointer\n  }\n  return jsPropertySyntax ? getProperty(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp)\n}\n\nexport function checkStrictMode(\n  it: SchemaCxt,\n  msg: string,\n  mode: boolean | \"log\" = it.opts.strictSchema\n): void {\n  if (!mode) return\n  msg = `strict mode: ${msg}`\n  if (mode === true) throw new Error(msg)\n  it.self.logger.warn(msg)\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1186, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1190, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/compile/names.ts"],"sourcesContent":["import {Name} from \"./codegen\"\n\nconst names = {\n  // validation function arguments\n  data: new Name(\"data\"), // data passed to validation function\n  // args passed from referencing schema\n  valCxt: new Name(\"valCxt\"), // validation/data context - should not be used directly, it is destructured to the names below\n  instancePath: new Name(\"instancePath\"),\n  parentData: new Name(\"parentData\"),\n  parentDataProperty: new Name(\"parentDataProperty\"),\n  rootData: new Name(\"rootData\"), // root data - same as the data passed to the first/top validation function\n  dynamicAnchors: new Name(\"dynamicAnchors\"), // used to support recursiveRef and dynamicRef\n  // function scoped variables\n  vErrors: new Name(\"vErrors\"), // null or array of validation errors\n  errors: new Name(\"errors\"), // counter of validation errors\n  this: new Name(\"this\"),\n  // \"globals\"\n  self: new Name(\"self\"),\n  scope: new Name(\"scope\"),\n  // JTD serialize/parse name for JSON string and position\n  json: new Name(\"json\"),\n  jsonPos: new Name(\"jsonPos\"),\n  jsonLen: new Name(\"jsonLen\"),\n  jsonPart: new Name(\"jsonPart\"),\n}\n\nexport default names\n"],"names":[],"mappings":";;;;AAAA,MAAA;AAEA,MAAM,QAAQ;IACZ,gCAAgC;IAChC,MAAM,IAAI,UAAA,IAAI,CAAC;IACf,sCAAsC;IACtC,QAAQ,IAAI,UAAA,IAAI,CAAC;IACjB,cAAc,IAAI,UAAA,IAAI,CAAC;IACvB,YAAY,IAAI,UAAA,IAAI,CAAC;IACrB,oBAAoB,IAAI,UAAA,IAAI,CAAC;IAC7B,UAAU,IAAI,UAAA,IAAI,CAAC;IACnB,gBAAgB,IAAI,UAAA,IAAI,CAAC;IACzB,4BAA4B;IAC5B,SAAS,IAAI,UAAA,IAAI,CAAC;IAClB,QAAQ,IAAI,UAAA,IAAI,CAAC;IACjB,MAAM,IAAI,UAAA,IAAI,CAAC;IACf,YAAY;IACZ,MAAM,IAAI,UAAA,IAAI,CAAC;IACf,OAAO,IAAI,UAAA,IAAI,CAAC;IAChB,wDAAwD;IACxD,MAAM,IAAI,UAAA,IAAI,CAAC;IACf,SAAS,IAAI,UAAA,IAAI,CAAC;IAClB,SAAS,IAAI,UAAA,IAAI,CAAC;IAClB,UAAU,IAAI,UAAA,IAAI,CAAC;;AAGrB,QAAA,OAAA,GAAe"}},
    {"offset": {"line": 1219, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1223, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/compile/errors.ts"],"sourcesContent":["import type {KeywordErrorCxt, KeywordErrorDefinition} from \"../types\"\nimport type {SchemaCxt} from \"./index\"\nimport {CodeGen, _, str, strConcat, Code, Name} from \"./codegen\"\nimport {SafeExpr} from \"./codegen/code\"\nimport {getErrorPath, Type} from \"./util\"\nimport N from \"./names\"\n\nexport const keywordError: KeywordErrorDefinition = {\n  message: ({keyword}) => str`must pass \"${keyword}\" keyword validation`,\n}\n\nexport const keyword$DataError: KeywordErrorDefinition = {\n  message: ({keyword, schemaType}) =>\n    schemaType\n      ? str`\"${keyword}\" keyword must be ${schemaType} ($data)`\n      : str`\"${keyword}\" keyword is invalid ($data)`,\n}\n\nexport interface ErrorPaths {\n  instancePath?: Code\n  schemaPath?: string\n  parentSchema?: boolean\n}\n\nexport function reportError(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition = keywordError,\n  errorPaths?: ErrorPaths,\n  overrideAllErrors?: boolean\n): void {\n  const {it} = cxt\n  const {gen, compositeRule, allErrors} = it\n  const errObj = errorObjectCode(cxt, error, errorPaths)\n  if (overrideAllErrors ?? (compositeRule || allErrors)) {\n    addError(gen, errObj)\n  } else {\n    returnErrors(it, _`[${errObj}]`)\n  }\n}\n\nexport function reportExtraError(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition = keywordError,\n  errorPaths?: ErrorPaths\n): void {\n  const {it} = cxt\n  const {gen, compositeRule, allErrors} = it\n  const errObj = errorObjectCode(cxt, error, errorPaths)\n  addError(gen, errObj)\n  if (!(compositeRule || allErrors)) {\n    returnErrors(it, N.vErrors)\n  }\n}\n\nexport function resetErrorsCount(gen: CodeGen, errsCount: Name): void {\n  gen.assign(N.errors, errsCount)\n  gen.if(_`${N.vErrors} !== null`, () =>\n    gen.if(\n      errsCount,\n      () => gen.assign(_`${N.vErrors}.length`, errsCount),\n      () => gen.assign(N.vErrors, null)\n    )\n  )\n}\n\nexport function extendErrors({\n  gen,\n  keyword,\n  schemaValue,\n  data,\n  errsCount,\n  it,\n}: KeywordErrorCxt): void {\n  /* istanbul ignore if */\n  if (errsCount === undefined) throw new Error(\"ajv implementation error\")\n  const err = gen.name(\"err\")\n  gen.forRange(\"i\", errsCount, N.errors, (i) => {\n    gen.const(err, _`${N.vErrors}[${i}]`)\n    gen.if(_`${err}.instancePath === undefined`, () =>\n      gen.assign(_`${err}.instancePath`, strConcat(N.instancePath, it.errorPath))\n    )\n    gen.assign(_`${err}.schemaPath`, str`${it.errSchemaPath}/${keyword}`)\n    if (it.opts.verbose) {\n      gen.assign(_`${err}.schema`, schemaValue)\n      gen.assign(_`${err}.data`, data)\n    }\n  })\n}\n\nfunction addError(gen: CodeGen, errObj: Code): void {\n  const err = gen.const(\"err\", errObj)\n  gen.if(\n    _`${N.vErrors} === null`,\n    () => gen.assign(N.vErrors, _`[${err}]`),\n    _`${N.vErrors}.push(${err})`\n  )\n  gen.code(_`${N.errors}++`)\n}\n\nfunction returnErrors(it: SchemaCxt, errs: Code): void {\n  const {gen, validateName, schemaEnv} = it\n  if (schemaEnv.$async) {\n    gen.throw(_`new ${it.ValidationError as Name}(${errs})`)\n  } else {\n    gen.assign(_`${validateName}.errors`, errs)\n    gen.return(false)\n  }\n}\n\nconst E = {\n  keyword: new Name(\"keyword\"),\n  schemaPath: new Name(\"schemaPath\"), // also used in JTD errors\n  params: new Name(\"params\"),\n  propertyName: new Name(\"propertyName\"),\n  message: new Name(\"message\"),\n  schema: new Name(\"schema\"),\n  parentSchema: new Name(\"parentSchema\"),\n}\n\nfunction errorObjectCode(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition,\n  errorPaths?: ErrorPaths\n): Code {\n  const {createErrors} = cxt.it\n  if (createErrors === false) return _`{}`\n  return errorObject(cxt, error, errorPaths)\n}\n\nfunction errorObject(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition,\n  errorPaths: ErrorPaths = {}\n): Code {\n  const {gen, it} = cxt\n  const keyValues: [Name, SafeExpr | string][] = [\n    errorInstancePath(it, errorPaths),\n    errorSchemaPath(cxt, errorPaths),\n  ]\n  extraErrorProps(cxt, error, keyValues)\n  return gen.object(...keyValues)\n}\n\nfunction errorInstancePath({errorPath}: SchemaCxt, {instancePath}: ErrorPaths): [Name, Code] {\n  const instPath = instancePath\n    ? str`${errorPath}${getErrorPath(instancePath, Type.Str)}`\n    : errorPath\n  return [N.instancePath, strConcat(N.instancePath, instPath)]\n}\n\nfunction errorSchemaPath(\n  {keyword, it: {errSchemaPath}}: KeywordErrorCxt,\n  {schemaPath, parentSchema}: ErrorPaths\n): [Name, string | Code] {\n  let schPath = parentSchema ? errSchemaPath : str`${errSchemaPath}/${keyword}`\n  if (schemaPath) {\n    schPath = str`${schPath}${getErrorPath(schemaPath, Type.Str)}`\n  }\n  return [E.schemaPath, schPath]\n}\n\nfunction extraErrorProps(\n  cxt: KeywordErrorCxt,\n  {params, message}: KeywordErrorDefinition,\n  keyValues: [Name, SafeExpr | string][]\n): void {\n  const {keyword, data, schemaValue, it} = cxt\n  const {opts, propertyName, topSchemaRef, schemaPath} = it\n  keyValues.push(\n    [E.keyword, keyword],\n    [E.params, typeof params == \"function\" ? params(cxt) : params || _`{}`]\n  )\n  if (opts.messages) {\n    keyValues.push([E.message, typeof message == \"function\" ? message(cxt) : message])\n  }\n  if (opts.verbose) {\n    keyValues.push(\n      [E.schema, schemaValue],\n      [E.parentSchema, _`${topSchemaRef}${schemaPath}`],\n      [N.data, data]\n    )\n  }\n  if (propertyName) keyValues.push([E.propertyName, propertyName])\n}\n"],"names":[],"mappings":";;;;;AAEA,MAAA;AAEA,MAAA;AACA,MAAA;AAEa,QAAA,YAAY,GAA2B;IAClD,SAAS,CAAC,EAAC,OAAO,EAAC,GAAK,CAAA,GAAA,UAAA,GAAG,CAAA,CAAA,WAAA,EAAc,QAAO,oBAAA,CAAsB;;AAG3D,QAAA,iBAAiB,GAA2B;IACvD,SAAS,CAAC,EAAC,OAAO,EAAE,UAAU,EAAC,GAC7B,aACI,CAAA,GAAA,UAAA,GAAG,CAAA,CAAA,CAAA,EAAI,QAAO,kBAAA,EAAqB,WAAU,QAAA,CAAU,GACvD,CAAA,GAAA,UAAA,GAAG,CAAA,CAAA,CAAA,EAAI,QAAO,4BAAA,CAA8B;;AASpD,SAAgB,YACd,GAAoB,EACpB,QAAgC,QAAA,YAAY,EAC5C,UAAuB,EACvB,iBAA2B;IAE3B,MAAM,EAAC,EAAE,EAAC,GAAG;IACb,MAAM,EAAC,GAAG,EAAE,aAAa,EAAE,SAAS,EAAC,GAAG;IACxC,MAAM,SAAS,gBAAgB,KAAK,OAAO;IAC3C,IAAI,sBAAiB,QAAjB,sBAAiB,KAAA,IAAjB,oBAAsB,iBAAiB,WAAY;QACrD,SAAS,KAAK;IAChB,OAAO;QACL,aAAa,IAAI,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,CAAA,EAAI,OAAM,CAAA,CAAG;IACjC;AACF;AAdA,QAAA,WAAA,GAAA;AAgBA,SAAgB,iBACd,GAAoB,EACpB,QAAgC,QAAA,YAAY,EAC5C,UAAuB;IAEvB,MAAM,EAAC,EAAE,EAAC,GAAG;IACb,MAAM,EAAC,GAAG,EAAE,aAAa,EAAE,SAAS,EAAC,GAAG;IACxC,MAAM,SAAS,gBAAgB,KAAK,OAAO;IAC3C,SAAS,KAAK;IACd,IAAI,CAAC,CAAC,iBAAiB,SAAS,GAAG;QACjC,aAAa,IAAI,QAAA,OAAC,CAAC,OAAO;IAC5B;AACF;AAZA,QAAA,gBAAA,GAAA;AAcA,SAAgB,iBAAiB,GAAY,EAAE,SAAe;IAC5D,IAAI,MAAM,CAAC,QAAA,OAAC,CAAC,MAAM,EAAE;IACrB,IAAI,EAAE,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,QAAA,OAAC,CAAC,OAAO,CAAA,SAAA,CAAW,EAAE,IAC/B,IAAI,EAAE,CACJ,WACA,IAAM,IAAI,MAAM,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,QAAA,OAAC,CAAC,OAAO,CAAA,OAAA,CAAS,EAAE,YACzC,IAAM,IAAI,MAAM,CAAC,QAAA,OAAC,CAAC,OAAO,EAAE;AAGlC;AATA,QAAA,gBAAA,GAAA;AAWA,SAAgB,aAAa,EAC3B,GAAG,EACH,OAAO,EACP,WAAW,EACX,IAAI,EACJ,SAAS,EACT,EAAE,EACc;IAChB,sBAAA,GACA,IAAI,cAAc,WAAW,MAAM,IAAI,MAAM;IAC7C,MAAM,MAAM,IAAI,IAAI,CAAC;IACrB,IAAI,QAAQ,CAAC,KAAK,WAAW,QAAA,OAAC,CAAC,MAAM,EAAE,CAAC;QACtC,IAAI,KAAK,CAAC,KAAK,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,QAAA,OAAC,CAAC,OAAO,CAAA,CAAA,EAAI,EAAC,CAAA,CAAG;QACpC,IAAI,EAAE,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,IAAG,2BAAA,CAA6B,EAAE,IAC3C,IAAI,MAAM,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,IAAG,aAAA,CAAe,EAAE,CAAA,GAAA,UAAA,SAAS,EAAC,QAAA,OAAC,CAAC,YAAY,EAAE,GAAG,SAAS;QAE3E,IAAI,MAAM,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,IAAG,WAAA,CAAa,EAAE,CAAA,GAAA,UAAA,GAAG,CAAA,CAAA,EAAG,GAAG,aAAa,CAAA,CAAA,EAAI,QAAO,CAAE;QACpE,IAAI,GAAG,IAAI,CAAC,OAAO,EAAE;YACnB,IAAI,MAAM,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,IAAG,OAAA,CAAS,EAAE;YAC7B,IAAI,MAAM,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,IAAG,KAAA,CAAO,EAAE;QAC7B;IACF;AACF;AAtBA,QAAA,YAAA,GAAA;AAwBA,SAAS,SAAS,GAAY,EAAE,MAAY;IAC1C,MAAM,MAAM,IAAI,KAAK,CAAC,OAAO;IAC7B,IAAI,EAAE,CACJ,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,QAAA,OAAC,CAAC,OAAO,CAAA,SAAA,CAAW,EACxB,IAAM,IAAI,MAAM,CAAC,QAAA,OAAC,CAAC,OAAO,EAAE,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,CAAA,EAAI,IAAG,CAAA,CAAG,GACvC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,QAAA,OAAC,CAAC,OAAO,CAAA,MAAA,EAAS,IAAG,CAAA,CAAG;IAE9B,IAAI,IAAI,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,QAAA,OAAC,CAAC,MAAM,CAAA,EAAA,CAAI;AAC3B;AAEA,SAAS,aAAa,EAAa,EAAE,IAAU;IAC7C,MAAM,EAAC,GAAG,EAAE,YAAY,EAAE,SAAS,EAAC,GAAG;IACvC,IAAI,UAAU,MAAM,EAAE;QACpB,IAAI,KAAK,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,IAAA,EAAO,GAAG,eAAuB,CAAA,CAAA,EAAI,KAAI,CAAA,CAAG;IACzD,OAAO;QACL,IAAI,MAAM,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,aAAY,OAAA,CAAS,EAAE;QACtC,IAAI,MAAM,CAAC;IACb;AACF;AAEA,MAAM,IAAI;IACR,SAAS,IAAI,UAAA,IAAI,CAAC;IAClB,YAAY,IAAI,UAAA,IAAI,CAAC;IACrB,QAAQ,IAAI,UAAA,IAAI,CAAC;IACjB,cAAc,IAAI,UAAA,IAAI,CAAC;IACvB,SAAS,IAAI,UAAA,IAAI,CAAC;IAClB,QAAQ,IAAI,UAAA,IAAI,CAAC;IACjB,cAAc,IAAI,UAAA,IAAI,CAAC;;AAGzB,SAAS,gBACP,GAAoB,EACpB,KAA6B,EAC7B,UAAuB;IAEvB,MAAM,EAAC,YAAY,EAAC,GAAG,IAAI,EAAE;IAC7B,IAAI,iBAAiB,OAAO,OAAO,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAA,CAAI;IACxC,OAAO,YAAY,KAAK,OAAO;AACjC;AAEA,SAAS,YACP,GAAoB,EACpB,KAA6B,EAC7B,aAAyB,CAAA,CAAE;IAE3B,MAAM,EAAC,GAAG,EAAE,EAAE,EAAC,GAAG;IAClB,MAAM,YAAyC;QAC7C,kBAAkB,IAAI;QACtB,gBAAgB,KAAK;KACtB;IACD,gBAAgB,KAAK,OAAO;IAC5B,OAAO,IAAI,MAAM,IAAI;AACvB;AAEA,SAAS,kBAAkB,EAAC,SAAS,EAAY,EAAE,EAAC,YAAY,EAAa;IAC3E,MAAM,WAAW,eACb,CAAA,GAAA,UAAA,GAAG,CAAA,CAAA,EAAG,UAAS,EAAG,CAAA,GAAA,OAAA,YAAY,EAAC,cAAc,OAAA,IAAI,CAAC,GAAG,EAAC,CAAE,GACxD;IACJ,OAAO;QAAC,QAAA,OAAC,CAAC,YAAY;QAAE,CAAA,GAAA,UAAA,SAAS,EAAC,QAAA,OAAC,CAAC,YAAY,EAAE;KAAU;AAC9D;AAEA,SAAS,gBACP,EAAC,OAAO,EAAE,IAAI,EAAC,aAAa,EAAC,EAAkB,EAC/C,EAAC,UAAU,EAAE,YAAY,EAAa;IAEtC,IAAI,UAAU,eAAe,gBAAgB,CAAA,GAAA,UAAA,GAAG,CAAA,CAAA,EAAG,cAAa,CAAA,EAAI,QAAO,CAAE;IAC7E,IAAI,YAAY;QACd,UAAU,CAAA,GAAA,UAAA,GAAG,CAAA,CAAA,EAAG,QAAO,EAAG,CAAA,GAAA,OAAA,YAAY,EAAC,YAAY,OAAA,IAAI,CAAC,GAAG,EAAC,CAAE;IAChE;IACA,OAAO;QAAC,EAAE,UAAU;QAAE;KAAQ;AAChC;AAEA,SAAS,gBACP,GAAoB,EACpB,EAAC,MAAM,EAAE,OAAO,EAAyB,EACzC,SAAsC;IAEtC,MAAM,EAAC,OAAO,EAAE,IAAI,EAAE,WAAW,EAAE,EAAE,EAAC,GAAG;IACzC,MAAM,EAAC,IAAI,EAAE,YAAY,EAAE,YAAY,EAAE,UAAU,EAAC,GAAG;IACvD,UAAU,IAAI,CACZ;QAAC,EAAE,OAAO;QAAE;KAAQ,EACpB;QAAC,EAAE,MAAM;QAAE,OAAO,UAAU,aAAa,OAAO,OAAO,UAAU,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAA,CAAI;KAAC;IAEzE,IAAI,KAAK,QAAQ,EAAE;QACjB,UAAU,IAAI,CAAC;YAAC,EAAE,OAAO;YAAE,OAAO,WAAW,aAAa,QAAQ,OAAO;SAAQ;IACnF;IACA,IAAI,KAAK,OAAO,EAAE;QAChB,UAAU,IAAI,CACZ;YAAC,EAAE,MAAM;YAAE;SAAY,EACvB;YAAC,EAAE,YAAY;YAAE,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,aAAY,EAAG,WAAU,CAAE;SAAC,EACjD;YAAC,QAAA,OAAC,CAAC,IAAI;YAAE;SAAK;IAElB;IACA,IAAI,cAAc,UAAU,IAAI,CAAC;QAAC,EAAE,YAAY;QAAE;KAAa;AACjE"}},
    {"offset": {"line": 1364, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1368, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/compile/validate/boolSchema.ts"],"sourcesContent":["import type {KeywordErrorDefinition, KeywordErrorCxt} from \"../../types\"\nimport type {SchemaCxt} from \"..\"\nimport {reportError} from \"../errors\"\nimport {_, Name} from \"../codegen\"\nimport N from \"../names\"\n\nconst boolError: KeywordErrorDefinition = {\n  message: \"boolean schema is false\",\n}\n\nexport function topBoolOrEmptySchema(it: SchemaCxt): void {\n  const {gen, schema, validateName} = it\n  if (schema === false) {\n    falseSchemaError(it, false)\n  } else if (typeof schema == \"object\" && schema.$async === true) {\n    gen.return(N.data)\n  } else {\n    gen.assign(_`${validateName}.errors`, null)\n    gen.return(true)\n  }\n}\n\nexport function boolOrEmptySchema(it: SchemaCxt, valid: Name): void {\n  const {gen, schema} = it\n  if (schema === false) {\n    gen.var(valid, false) // TODO var\n    falseSchemaError(it)\n  } else {\n    gen.var(valid, true) // TODO var\n  }\n}\n\nfunction falseSchemaError(it: SchemaCxt, overrideAllErrors?: boolean): void {\n  const {gen, data} = it\n  // TODO maybe some other interface should be used for non-keyword validation errors...\n  const cxt: KeywordErrorCxt = {\n    gen,\n    keyword: \"false schema\",\n    data,\n    schema: false,\n    schemaCode: false,\n    schemaValue: false,\n    params: {},\n    it,\n  }\n  reportError(cxt, boolError, undefined, overrideAllErrors)\n}\n"],"names":[],"mappings":";;;;;AAEA,MAAA;AACA,MAAA;AACA,MAAA;AAEA,MAAM,YAAoC;IACxC,SAAS;;AAGX,SAAgB,qBAAqB,EAAa;IAChD,MAAM,EAAC,GAAG,EAAE,MAAM,EAAE,YAAY,EAAC,GAAG;IACpC,IAAI,WAAW,OAAO;QACpB,iBAAiB,IAAI;IACvB,OAAO,IAAI,OAAO,UAAU,YAAY,OAAO,MAAM,KAAK,MAAM;QAC9D,IAAI,MAAM,CAAC,QAAA,OAAC,CAAC,IAAI;IACnB,OAAO;QACL,IAAI,MAAM,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,aAAY,OAAA,CAAS,EAAE;QACtC,IAAI,MAAM,CAAC;IACb;AACF;AAVA,QAAA,oBAAA,GAAA;AAYA,SAAgB,kBAAkB,EAAa,EAAE,KAAW;IAC1D,MAAM,EAAC,GAAG,EAAE,MAAM,EAAC,GAAG;IACtB,IAAI,WAAW,OAAO;QACpB,IAAI,GAAG,CAAC,OAAO,QAAO,WAAW;QACjC,iBAAiB;IACnB,OAAO;QACL,IAAI,GAAG,CAAC,OAAO,OAAM,WAAW;IAClC;AACF;AARA,QAAA,iBAAA,GAAA;AAUA,SAAS,iBAAiB,EAAa,EAAE,iBAA2B;IAClE,MAAM,EAAC,GAAG,EAAE,IAAI,EAAC,GAAG;IACpB,sFAAsF;IACtF,MAAM,MAAuB;QAC3B;QACA,SAAS;QACT;QACA,QAAQ;QACR,YAAY;QACZ,aAAa;QACb,QAAQ,CAAA;QACR;;IAEF,CAAA,GAAA,SAAA,WAAW,EAAC,KAAK,WAAW,WAAW;AACzC"}},
    {"offset": {"line": 1416, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1420, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/compile/rules.ts"],"sourcesContent":["import type {AddedKeywordDefinition} from \"../types\"\n\nconst _jsonTypes = [\"string\", \"number\", \"integer\", \"boolean\", \"null\", \"object\", \"array\"] as const\n\nexport type JSONType = (typeof _jsonTypes)[number]\n\nconst jsonTypes: Set<string> = new Set(_jsonTypes)\n\nexport function isJSONType(x: unknown): x is JSONType {\n  return typeof x == \"string\" && jsonTypes.has(x)\n}\n\ntype ValidationTypes = {\n  [K in JSONType]: boolean | RuleGroup | undefined\n}\n\nexport interface ValidationRules {\n  rules: RuleGroup[]\n  post: RuleGroup\n  all: {[Key in string]?: boolean | Rule} // rules that have to be validated\n  keywords: {[Key in string]?: boolean} // all known keywords (superset of \"all\")\n  types: ValidationTypes\n}\n\nexport interface RuleGroup {\n  type?: JSONType\n  rules: Rule[]\n}\n\n// This interface wraps KeywordDefinition because definition can have multiple keywords\nexport interface Rule {\n  keyword: string\n  definition: AddedKeywordDefinition\n}\n\nexport function getRules(): ValidationRules {\n  const groups: Record<\"number\" | \"string\" | \"array\" | \"object\", RuleGroup> = {\n    number: {type: \"number\", rules: []},\n    string: {type: \"string\", rules: []},\n    array: {type: \"array\", rules: []},\n    object: {type: \"object\", rules: []},\n  }\n  return {\n    types: {...groups, integer: true, boolean: true, null: true},\n    rules: [{rules: []}, groups.number, groups.string, groups.array, groups.object],\n    post: {rules: []},\n    all: {},\n    keywords: {},\n  }\n}\n"],"names":[],"mappings":";;;;;AAEA,MAAM,aAAa;IAAC;IAAU;IAAU;IAAW;IAAW;IAAQ;IAAU;CAAiB;AAIjG,MAAM,YAAyB,IAAI,IAAI;AAEvC,SAAgB,WAAW,CAAU;IACnC,OAAO,OAAO,KAAK,YAAY,UAAU,GAAG,CAAC;AAC/C;AAFA,QAAA,UAAA,GAAA;AA2BA,SAAgB;IACd,MAAM,SAAsE;QAC1E,QAAQ;YAAC,MAAM;YAAU,OAAO,EAAE;QAAA;QAClC,QAAQ;YAAC,MAAM;YAAU,OAAO,EAAE;QAAA;QAClC,OAAO;YAAC,MAAM;YAAS,OAAO,EAAE;QAAA;QAChC,QAAQ;YAAC,MAAM;YAAU,OAAO,EAAE;QAAA;;IAEpC,OAAO;QACL,OAAO;YAAC,GAAG,MAAM;YAAE,SAAS;YAAM,SAAS;YAAM,MAAM;QAAI;QAC3D,OAAO;YAAC;gBAAC,OAAO,EAAE;YAAA;YAAG,OAAO,MAAM;YAAE,OAAO,MAAM;YAAE,OAAO,KAAK;YAAE,OAAO,MAAM;SAAC;QAC/E,MAAM;YAAC,OAAO,EAAE;QAAA;QAChB,KAAK,CAAA;QACL,UAAU,CAAA;;AAEd;AAdA,QAAA,QAAA,GAAA"}},
    {"offset": {"line": 1482, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1486, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/compile/validate/applicability.ts"],"sourcesContent":["import type {AnySchemaObject} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport type {JSONType, RuleGroup, Rule} from \"../rules\"\n\nexport function schemaHasRulesForType(\n  {schema, self}: SchemaObjCxt,\n  type: JSONType\n): boolean | undefined {\n  const group = self.RULES.types[type]\n  return group && group !== true && shouldUseGroup(schema, group)\n}\n\nexport function shouldUseGroup(schema: AnySchemaObject, group: RuleGroup): boolean {\n  return group.rules.some((rule) => shouldUseRule(schema, rule))\n}\n\nexport function shouldUseRule(schema: AnySchemaObject, rule: Rule): boolean | undefined {\n  return (\n    schema[rule.keyword] !== undefined ||\n    rule.definition.implements?.some((kwd) => schema[kwd] !== undefined)\n  )\n}\n"],"names":[],"mappings":";;;;;AAIA,SAAgB,sBACd,EAAC,MAAM,EAAE,IAAI,EAAe,EAC5B,IAAc;IAEd,MAAM,QAAQ,KAAK,KAAK,CAAC,KAAK,CAAC,KAAK;IACpC,OAAO,SAAS,UAAU,QAAQ,eAAe,QAAQ;AAC3D;AANA,QAAA,qBAAA,GAAA;AAQA,SAAgB,eAAe,MAAuB,EAAE,KAAgB;IACtE,OAAO,MAAM,KAAK,CAAC,IAAI,CAAC,CAAC,OAAS,cAAc,QAAQ;AAC1D;AAFA,QAAA,cAAA,GAAA;AAIA,SAAgB,cAAc,MAAuB,EAAE,IAAU;;IAC/D,OACE,MAAM,CAAC,KAAK,OAAO,CAAC,KAAK,cACzB,CAAA,KAAA,KAAK,UAAU,CAAC,UAAU,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,IAAI,CAAC,CAAC,MAAQ,MAAM,CAAC,IAAI,KAAK,UAAU;AAExE;AALA,QAAA,aAAA,GAAA"}},
    {"offset": {"line": 1505, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1509, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/compile/validate/dataType.ts"],"sourcesContent":["import type {\n  KeywordErrorDefinition,\n  KeywordErrorCxt,\n  ErrorObject,\n  AnySchemaObject,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {isJSONType, JSONType} from \"../rules\"\nimport {schemaHasRulesForType} from \"./applicability\"\nimport {reportError} from \"../errors\"\nimport {_, nil, and, not, operators, Code, Name} from \"../codegen\"\nimport {toHash, schemaRefOrVal} from \"../util\"\n\nexport enum DataType {\n  Correct,\n  Wrong,\n}\n\nexport function getSchemaTypes(schema: AnySchemaObject): JSONType[] {\n  const types = getJSONTypes(schema.type)\n  const hasNull = types.includes(\"null\")\n  if (hasNull) {\n    if (schema.nullable === false) throw new Error(\"type: null contradicts nullable: false\")\n  } else {\n    if (!types.length && schema.nullable !== undefined) {\n      throw new Error('\"nullable\" cannot be used without \"type\"')\n    }\n    if (schema.nullable === true) types.push(\"null\")\n  }\n  return types\n}\n\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nexport function getJSONTypes(ts: unknown | unknown[]): JSONType[] {\n  const types: unknown[] = Array.isArray(ts) ? ts : ts ? [ts] : []\n  if (types.every(isJSONType)) return types\n  throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"))\n}\n\nexport function coerceAndCheckDataType(it: SchemaObjCxt, types: JSONType[]): boolean {\n  const {gen, data, opts} = it\n  const coerceTo = coerceToTypes(types, opts.coerceTypes)\n  const checkTypes =\n    types.length > 0 &&\n    !(coerceTo.length === 0 && types.length === 1 && schemaHasRulesForType(it, types[0]))\n  if (checkTypes) {\n    const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong)\n    gen.if(wrongType, () => {\n      if (coerceTo.length) coerceData(it, types, coerceTo)\n      else reportTypeError(it)\n    })\n  }\n  return checkTypes\n}\n\nconst COERCIBLE: Set<JSONType> = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"])\nfunction coerceToTypes(types: JSONType[], coerceTypes?: boolean | \"array\"): JSONType[] {\n  return coerceTypes\n    ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === \"array\" && t === \"array\"))\n    : []\n}\n\nfunction coerceData(it: SchemaObjCxt, types: JSONType[], coerceTo: JSONType[]): void {\n  const {gen, data, opts} = it\n  const dataType = gen.let(\"dataType\", _`typeof ${data}`)\n  const coerced = gen.let(\"coerced\", _`undefined`)\n  if (opts.coerceTypes === \"array\") {\n    gen.if(_`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () =>\n      gen\n        .assign(data, _`${data}[0]`)\n        .assign(dataType, _`typeof ${data}`)\n        .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data))\n    )\n  }\n  gen.if(_`${coerced} !== undefined`)\n  for (const t of coerceTo) {\n    if (COERCIBLE.has(t) || (t === \"array\" && opts.coerceTypes === \"array\")) {\n      coerceSpecificType(t)\n    }\n  }\n  gen.else()\n  reportTypeError(it)\n  gen.endIf()\n\n  gen.if(_`${coerced} !== undefined`, () => {\n    gen.assign(data, coerced)\n    assignParentData(it, coerced)\n  })\n\n  function coerceSpecificType(t: string): void {\n    switch (t) {\n      case \"string\":\n        gen\n          .elseIf(_`${dataType} == \"number\" || ${dataType} == \"boolean\"`)\n          .assign(coerced, _`\"\" + ${data}`)\n          .elseIf(_`${data} === null`)\n          .assign(coerced, _`\"\"`)\n        return\n      case \"number\":\n        gen\n          .elseIf(\n            _`${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`\n          )\n          .assign(coerced, _`+${data}`)\n        return\n      case \"integer\":\n        gen\n          .elseIf(\n            _`${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`\n          )\n          .assign(coerced, _`+${data}`)\n        return\n      case \"boolean\":\n        gen\n          .elseIf(_`${data} === \"false\" || ${data} === 0 || ${data} === null`)\n          .assign(coerced, false)\n          .elseIf(_`${data} === \"true\" || ${data} === 1`)\n          .assign(coerced, true)\n        return\n      case \"null\":\n        gen.elseIf(_`${data} === \"\" || ${data} === 0 || ${data} === false`)\n        gen.assign(coerced, null)\n        return\n\n      case \"array\":\n        gen\n          .elseIf(\n            _`${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`\n          )\n          .assign(coerced, _`[${data}]`)\n    }\n  }\n}\n\nfunction assignParentData({gen, parentData, parentDataProperty}: SchemaObjCxt, expr: Name): void {\n  // TODO use gen.property\n  gen.if(_`${parentData} !== undefined`, () =>\n    gen.assign(_`${parentData}[${parentDataProperty}]`, expr)\n  )\n}\n\nexport function checkDataType(\n  dataType: JSONType,\n  data: Name,\n  strictNums?: boolean | \"log\",\n  correct = DataType.Correct\n): Code {\n  const EQ = correct === DataType.Correct ? operators.EQ : operators.NEQ\n  let cond: Code\n  switch (dataType) {\n    case \"null\":\n      return _`${data} ${EQ} null`\n    case \"array\":\n      cond = _`Array.isArray(${data})`\n      break\n    case \"object\":\n      cond = _`${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`\n      break\n    case \"integer\":\n      cond = numCond(_`!(${data} % 1) && !isNaN(${data})`)\n      break\n    case \"number\":\n      cond = numCond()\n      break\n    default:\n      return _`typeof ${data} ${EQ} ${dataType}`\n  }\n  return correct === DataType.Correct ? cond : not(cond)\n\n  function numCond(_cond: Code = nil): Code {\n    return and(_`typeof ${data} == \"number\"`, _cond, strictNums ? _`isFinite(${data})` : nil)\n  }\n}\n\nexport function checkDataTypes(\n  dataTypes: JSONType[],\n  data: Name,\n  strictNums?: boolean | \"log\",\n  correct?: DataType\n): Code {\n  if (dataTypes.length === 1) {\n    return checkDataType(dataTypes[0], data, strictNums, correct)\n  }\n  let cond: Code\n  const types = toHash(dataTypes)\n  if (types.array && types.object) {\n    const notObj = _`typeof ${data} != \"object\"`\n    cond = types.null ? notObj : _`!${data} || ${notObj}`\n    delete types.null\n    delete types.array\n    delete types.object\n  } else {\n    cond = nil\n  }\n  if (types.number) delete types.integer\n  for (const t in types) cond = and(cond, checkDataType(t as JSONType, data, strictNums, correct))\n  return cond\n}\n\nexport type TypeError = ErrorObject<\"type\", {type: string}>\n\nconst typeError: KeywordErrorDefinition = {\n  message: ({schema}) => `must be ${schema}`,\n  params: ({schema, schemaValue}) =>\n    typeof schema == \"string\" ? _`{type: ${schema}}` : _`{type: ${schemaValue}}`,\n}\n\nexport function reportTypeError(it: SchemaObjCxt): void {\n  const cxt = getTypeErrorContext(it)\n  reportError(cxt, typeError)\n}\n\nfunction getTypeErrorContext(it: SchemaObjCxt): KeywordErrorCxt {\n  const {gen, data, schema} = it\n  const schemaCode = schemaRefOrVal(it, schema, \"type\")\n  return {\n    gen,\n    keyword: \"type\",\n    data,\n    schema: schema.type,\n    schemaCode,\n    schemaValue: schemaCode,\n    parentSchema: schema,\n    params: {},\n    it,\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1692, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1696, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/compile/validate/defaults.ts"],"sourcesContent":["import type {SchemaObjCxt} from \"..\"\nimport {_, getProperty, stringify} from \"../codegen\"\nimport {checkStrictMode} from \"../util\"\n\nexport function assignDefaults(it: SchemaObjCxt, ty?: string): void {\n  const {properties, items} = it.schema\n  if (ty === \"object\" && properties) {\n    for (const key in properties) {\n      assignDefault(it, key, properties[key].default)\n    }\n  } else if (ty === \"array\" && Array.isArray(items)) {\n    items.forEach((sch, i: number) => assignDefault(it, i, sch.default))\n  }\n}\n\nfunction assignDefault(it: SchemaObjCxt, prop: string | number, defaultValue: unknown): void {\n  const {gen, compositeRule, data, opts} = it\n  if (defaultValue === undefined) return\n  const childData = _`${data}${getProperty(prop)}`\n  if (compositeRule) {\n    checkStrictMode(it, `default is ignored for: ${childData}`)\n    return\n  }\n\n  let condition = _`${childData} === undefined`\n  if (opts.useDefaults === \"empty\") {\n    condition = _`${condition} || ${childData} === null || ${childData} === \"\"`\n  }\n  // `${childData} === undefined` +\n  // (opts.useDefaults === \"empty\" ? ` || ${childData} === null || ${childData} === \"\"` : \"\")\n  gen.if(condition, _`${childData} = ${stringify(defaultValue)}`)\n}\n"],"names":[],"mappings":";;;;;AACA,MAAA;AACA,MAAA;AAEA,SAAgB,eAAe,EAAgB,EAAE,EAAW;IAC1D,MAAM,EAAC,UAAU,EAAE,KAAK,EAAC,GAAG,GAAG,MAAM;IACrC,IAAI,OAAO,YAAY,YAAY;QACjC,IAAK,MAAM,OAAO,WAAY;YAC5B,cAAc,IAAI,KAAK,UAAU,CAAC,IAAI,CAAC,OAAO;QAChD;IACF,OAAO,IAAI,OAAO,WAAW,MAAM,OAAO,CAAC,QAAQ;QACjD,MAAM,OAAO,CAAC,CAAC,KAAK,IAAc,cAAc,IAAI,GAAG,IAAI,OAAO;IACpE;AACF;AATA,QAAA,cAAA,GAAA;AAWA,SAAS,cAAc,EAAgB,EAAE,IAAqB,EAAE,YAAqB;IACnF,MAAM,EAAC,GAAG,EAAE,aAAa,EAAE,IAAI,EAAE,IAAI,EAAC,GAAG;IACzC,IAAI,iBAAiB,WAAW;IAChC,MAAM,YAAY,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,KAAI,EAAG,CAAA,GAAA,UAAA,WAAW,EAAC,MAAK,CAAE;IAChD,IAAI,eAAe;QACjB,CAAA,GAAA,OAAA,eAAe,EAAC,IAAI,CAAA,wBAAA,EAA2B,UAAS,CAAE;QAC1D;IACF;IAEA,IAAI,YAAY,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,UAAS,cAAA,CAAgB;IAC7C,IAAI,KAAK,WAAW,KAAK,SAAS;QAChC,YAAY,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,UAAS,IAAA,EAAO,UAAS,aAAA,EAAgB,UAAS,OAAA,CAAS;IAC7E;IACA,iCAAiC;IACjC,2FAA2F;IAC3F,IAAI,EAAE,CAAC,WAAW,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,UAAS,GAAA,EAAM,CAAA,GAAA,UAAA,SAAS,EAAC,cAAa,CAAE;AAChE"}},
    {"offset": {"line": 1730, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1734, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/code.ts"],"sourcesContent":["import type {AnySchema, SchemaMap} from \"../types\"\nimport type {SchemaCxt} from \"../compile\"\nimport type {KeywordCxt} from \"../compile/validate\"\nimport {CodeGen, _, and, or, not, nil, strConcat, getProperty, Code, Name} from \"../compile/codegen\"\nimport {alwaysValidSchema, Type} from \"../compile/util\"\nimport N from \"../compile/names\"\nimport {useFunc} from \"../compile/util\"\nexport function checkReportMissingProp(cxt: KeywordCxt, prop: string): void {\n  const {gen, data, it} = cxt\n  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n    cxt.setParams({missingProperty: _`${prop}`}, true)\n    cxt.error()\n  })\n}\n\nexport function checkMissingProp(\n  {gen, data, it: {opts}}: KeywordCxt,\n  properties: string[],\n  missing: Name\n): Code {\n  return or(\n    ...properties.map((prop) =>\n      and(noPropertyInData(gen, data, prop, opts.ownProperties), _`${missing} = ${prop}`)\n    )\n  )\n}\n\nexport function reportMissingProp(cxt: KeywordCxt, missing: Name): void {\n  cxt.setParams({missingProperty: missing}, true)\n  cxt.error()\n}\n\nexport function hasPropFunc(gen: CodeGen): Name {\n  return gen.scopeValue(\"func\", {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    ref: Object.prototype.hasOwnProperty,\n    code: _`Object.prototype.hasOwnProperty`,\n  })\n}\n\nexport function isOwnProperty(gen: CodeGen, data: Name, property: Name | string): Code {\n  return _`${hasPropFunc(gen)}.call(${data}, ${property})`\n}\n\nexport function propertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} !== undefined`\n  return ownProperties ? _`${cond} && ${isOwnProperty(gen, data, property)}` : cond\n}\n\nexport function noPropertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} === undefined`\n  return ownProperties ? or(cond, not(isOwnProperty(gen, data, property))) : cond\n}\n\nexport function allSchemaProperties(schemaMap?: SchemaMap): string[] {\n  return schemaMap ? Object.keys(schemaMap).filter((p) => p !== \"__proto__\") : []\n}\n\nexport function schemaProperties(it: SchemaCxt, schemaMap: SchemaMap): string[] {\n  return allSchemaProperties(schemaMap).filter(\n    (p) => !alwaysValidSchema(it, schemaMap[p] as AnySchema)\n  )\n}\n\nexport function callValidateCode(\n  {schemaCode, data, it: {gen, topSchemaRef, schemaPath, errorPath}, it}: KeywordCxt,\n  func: Code,\n  context: Code,\n  passSchema?: boolean\n): Code {\n  const dataAndSchema = passSchema ? _`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data\n  const valCxt: [Name, Code | number][] = [\n    [N.instancePath, strConcat(N.instancePath, errorPath)],\n    [N.parentData, it.parentData],\n    [N.parentDataProperty, it.parentDataProperty],\n    [N.rootData, N.rootData],\n  ]\n  if (it.opts.dynamicRef) valCxt.push([N.dynamicAnchors, N.dynamicAnchors])\n  const args = _`${dataAndSchema}, ${gen.object(...valCxt)}`\n  return context !== nil ? _`${func}.call(${context}, ${args})` : _`${func}(${args})`\n}\n\nconst newRegExp = _`new RegExp`\n\nexport function usePattern({gen, it: {opts}}: KeywordCxt, pattern: string): Name {\n  const u = opts.unicodeRegExp ? \"u\" : \"\"\n  const {regExp} = opts.code\n  const rx = regExp(pattern, u)\n\n  return gen.scopeValue(\"pattern\", {\n    key: rx.toString(),\n    ref: rx,\n    code: _`${regExp.code === \"new RegExp\" ? newRegExp : useFunc(gen, regExp)}(${pattern}, ${u})`,\n  })\n}\n\nexport function validateArray(cxt: KeywordCxt): Name {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  if (it.allErrors) {\n    const validArr = gen.let(\"valid\", true)\n    validateItems(() => gen.assign(validArr, false))\n    return validArr\n  }\n  gen.var(valid, true)\n  validateItems(() => gen.break())\n  return valid\n\n  function validateItems(notValid: () => void): void {\n    const len = gen.const(\"len\", _`${data}.length`)\n    gen.forRange(\"i\", 0, len, (i) => {\n      cxt.subschema(\n        {\n          keyword,\n          dataProp: i,\n          dataPropType: Type.Num,\n        },\n        valid\n      )\n      gen.if(not(valid), notValid)\n    })\n  }\n}\n\nexport function validateUnion(cxt: KeywordCxt): void {\n  const {gen, schema, keyword, it} = cxt\n  /* istanbul ignore if */\n  if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n  const alwaysValid = schema.some((sch: AnySchema) => alwaysValidSchema(it, sch))\n  if (alwaysValid && !it.opts.unevaluated) return\n\n  const valid = gen.let(\"valid\", false)\n  const schValid = gen.name(\"_valid\")\n\n  gen.block(() =>\n    schema.forEach((_sch: AnySchema, i: number) => {\n      const schCxt = cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          compositeRule: true,\n        },\n        schValid\n      )\n      gen.assign(valid, _`${valid} || ${schValid}`)\n      const merged = cxt.mergeValidEvaluated(schCxt, schValid)\n      // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n      // or if all properties and items were evaluated (it.props === true && it.items === true)\n      if (!merged) gen.if(not(valid))\n    })\n  )\n\n  cxt.result(\n    valid,\n    () => cxt.reset(),\n    () => cxt.error(true)\n  )\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1880, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1884, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/compile/validate/keyword.ts"],"sourcesContent":["import type {KeywordCxt} from \".\"\nimport type {\n  AnySchema,\n  SchemaValidateFunction,\n  AnyValidateFunction,\n  AddedKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, nil, not, stringify, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport type {JSONType} from \"../rules\"\nimport {callValidateCode} from \"../../vocabularies/code\"\nimport {extendErrors} from \"../errors\"\n\ntype KeywordCompilationResult = AnySchema | SchemaValidateFunction | AnyValidateFunction\n\nexport function macroKeywordCode(cxt: KeywordCxt, def: MacroKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, it} = cxt\n  const macroSchema = def.macro.call(it.self, schema, parentSchema, it)\n  const schemaRef = useKeyword(gen, keyword, macroSchema)\n  if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true)\n\n  const valid = gen.name(\"valid\")\n  cxt.subschema(\n    {\n      schema: macroSchema,\n      schemaPath: nil,\n      errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n      topSchemaRef: schemaRef,\n      compositeRule: true,\n    },\n    valid\n  )\n  cxt.pass(valid, () => cxt.error(true))\n}\n\nexport function funcKeywordCode(cxt: KeywordCxt, def: FuncKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, $data, it} = cxt\n  checkAsyncKeyword(it, def)\n  const validate =\n    !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate\n  const validateRef = useKeyword(gen, keyword, validate)\n  const valid = gen.let(\"valid\")\n  cxt.block$data(valid, validateKeyword)\n  cxt.ok(def.valid ?? valid)\n\n  function validateKeyword(): void {\n    if (def.errors === false) {\n      assignValid()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => cxt.error())\n    } else {\n      const ruleErrs = def.async ? validateAsync() : validateSync()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => addErrs(cxt, ruleErrs))\n    }\n  }\n\n  function validateAsync(): Name {\n    const ruleErrs = gen.let(\"ruleErrs\", null)\n    gen.try(\n      () => assignValid(_`await `),\n      (e) =>\n        gen.assign(valid, false).if(\n          _`${e} instanceof ${it.ValidationError as Name}`,\n          () => gen.assign(ruleErrs, _`${e}.errors`),\n          () => gen.throw(e)\n        )\n    )\n    return ruleErrs\n  }\n\n  function validateSync(): Code {\n    const validateErrs = _`${validateRef}.errors`\n    gen.assign(validateErrs, null)\n    assignValid(nil)\n    return validateErrs\n  }\n\n  function assignValid(_await: Code = def.async ? _`await ` : nil): void {\n    const passCxt = it.opts.passContext ? N.this : N.self\n    const passSchema = !((\"compile\" in def && !$data) || def.schema === false)\n    gen.assign(\n      valid,\n      _`${_await}${callValidateCode(cxt, validateRef, passCxt, passSchema)}`,\n      def.modifying\n    )\n  }\n\n  function reportErrs(errors: () => void): void {\n    gen.if(not(def.valid ?? valid), errors)\n  }\n}\n\nfunction modifyData(cxt: KeywordCxt): void {\n  const {gen, data, it} = cxt\n  gen.if(it.parentData, () => gen.assign(data, _`${it.parentData}[${it.parentDataProperty}]`))\n}\n\nfunction addErrs(cxt: KeywordCxt, errs: Code): void {\n  const {gen} = cxt\n  gen.if(\n    _`Array.isArray(${errs})`,\n    () => {\n      gen\n        .assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`)\n        .assign(N.errors, _`${N.vErrors}.length`)\n      extendErrors(cxt)\n    },\n    () => cxt.error()\n  )\n}\n\nfunction checkAsyncKeyword({schemaEnv}: SchemaObjCxt, def: FuncKeywordDefinition): void {\n  if (def.async && !schemaEnv.$async) throw new Error(\"async keyword in sync schema\")\n}\n\nfunction useKeyword(gen: CodeGen, keyword: string, result?: KeywordCompilationResult): Name {\n  if (result === undefined) throw new Error(`keyword \"${keyword}\" failed to compile`)\n  return gen.scopeValue(\n    \"keyword\",\n    typeof result == \"function\" ? {ref: result} : {ref: result, code: stringify(result)}\n  )\n}\n\nexport function validSchemaType(\n  schema: unknown,\n  schemaType: JSONType[],\n  allowUndefined = false\n): boolean {\n  // TODO add tests\n  return (\n    !schemaType.length ||\n    schemaType.some((st) =>\n      st === \"array\"\n        ? Array.isArray(schema)\n        : st === \"object\"\n        ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n        : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")\n    )\n  )\n}\n\nexport function validateKeywordUsage(\n  {schema, opts, self, errSchemaPath}: SchemaObjCxt,\n  def: AddedKeywordDefinition,\n  keyword: string\n): void {\n  /* istanbul ignore if */\n  if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n    throw new Error(\"ajv implementation error\")\n  }\n\n  const deps = def.dependencies\n  if (deps?.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n    throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`)\n  }\n\n  if (def.validateSchema) {\n    const valid = def.validateSchema(schema[keyword])\n    if (!valid) {\n      const msg =\n        `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` +\n        self.errorsText(def.validateSchema.errors)\n      if (opts.validateSchema === \"log\") self.logger.error(msg)\n      else throw new Error(msg)\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1997, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2001, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/compile/validate/subschema.ts"],"sourcesContent":["import type {AnySchema} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, str, getProperty, Code, Name} from \"../codegen\"\nimport {escapeFragment, getErrorPath, Type} from \"../util\"\nimport type {JSONType} from \"../rules\"\n\nexport interface SubschemaContext {\n  // TODO use Optional? align with SchemCxt property types\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef?: Code\n  errorPath?: Code\n  dataLevel?: number\n  dataTypes?: JSONType[]\n  data?: Name\n  parentData?: Name\n  parentDataProperty?: Code | number\n  dataNames?: Name[]\n  dataPathArr?: (Code | number)[]\n  propertyName?: Name\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  compositeRule?: true\n  createErrors?: boolean\n  allErrors?: boolean\n}\n\nexport type SubschemaArgs = Partial<{\n  keyword: string\n  schemaProp: string | number\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef: Code\n  data: Name | Code\n  dataProp: Code | string | number\n  dataTypes: JSONType[]\n  definedProperties: Set<string>\n  propertyName: Name\n  dataPropType: Type\n  jtdDiscriminator: string\n  jtdMetadata: boolean\n  compositeRule: true\n  createErrors: boolean\n  allErrors: boolean\n}>\n\nexport function getSubschema(\n  it: SchemaObjCxt,\n  {keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef}: SubschemaArgs\n): SubschemaContext {\n  if (keyword !== undefined && schema !== undefined) {\n    throw new Error('both \"keyword\" and \"schema\" passed, only one allowed')\n  }\n\n  if (keyword !== undefined) {\n    const sch = it.schema[keyword]\n    return schemaProp === undefined\n      ? {\n          schema: sch,\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        }\n      : {\n          schema: sch[schemaProp],\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}${getProperty(schemaProp)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}/${escapeFragment(schemaProp)}`,\n        }\n  }\n\n  if (schema !== undefined) {\n    if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n      throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"')\n    }\n    return {\n      schema,\n      schemaPath,\n      topSchemaRef,\n      errSchemaPath,\n    }\n  }\n\n  throw new Error('either \"keyword\" or \"schema\" must be passed')\n}\n\nexport function extendSubschemaData(\n  subschema: SubschemaContext,\n  it: SchemaObjCxt,\n  {dataProp, dataPropType: dpType, data, dataTypes, propertyName}: SubschemaArgs\n): void {\n  if (data !== undefined && dataProp !== undefined) {\n    throw new Error('both \"data\" and \"dataProp\" passed, only one allowed')\n  }\n\n  const {gen} = it\n\n  if (dataProp !== undefined) {\n    const {errorPath, dataPathArr, opts} = it\n    const nextData = gen.let(\"data\", _`${it.data}${getProperty(dataProp)}`, true)\n    dataContextProps(nextData)\n    subschema.errorPath = str`${errorPath}${getErrorPath(dataProp, dpType, opts.jsPropertySyntax)}`\n    subschema.parentDataProperty = _`${dataProp}`\n    subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty]\n  }\n\n  if (data !== undefined) {\n    const nextData = data instanceof Name ? data : gen.let(\"data\", data, true) // replaceable if used once?\n    dataContextProps(nextData)\n    if (propertyName !== undefined) subschema.propertyName = propertyName\n    // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n  }\n\n  if (dataTypes) subschema.dataTypes = dataTypes\n\n  function dataContextProps(_nextData: Name): void {\n    subschema.data = _nextData\n    subschema.dataLevel = it.dataLevel + 1\n    subschema.dataTypes = []\n    it.definedProperties = new Set<string>()\n    subschema.parentData = it.data\n    subschema.dataNames = [...it.dataNames, _nextData]\n  }\n}\n\nexport function extendSubschemaMode(\n  subschema: SubschemaContext,\n  {jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors}: SubschemaArgs\n): void {\n  if (compositeRule !== undefined) subschema.compositeRule = compositeRule\n  if (createErrors !== undefined) subschema.createErrors = createErrors\n  if (allErrors !== undefined) subschema.allErrors = allErrors\n  subschema.jtdDiscriminator = jtdDiscriminator // not inherited\n  subschema.jtdMetadata = jtdMetadata // not inherited\n}\n"],"names":[],"mappings":";;;;;AAEA,MAAA;AACA,MAAA;AA6CA,SAAgB,aACd,EAAgB,EAChB,EAAC,OAAO,EAAE,UAAU,EAAE,MAAM,EAAE,UAAU,EAAE,aAAa,EAAE,YAAY,EAAgB;IAErF,IAAI,YAAY,aAAa,WAAW,WAAW;QACjD,MAAM,IAAI,MAAM;IAClB;IAEA,IAAI,YAAY,WAAW;QACzB,MAAM,MAAM,GAAG,MAAM,CAAC,QAAQ;QAC9B,OAAO,eAAe,YAClB;YACE,QAAQ;YACR,YAAY,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,GAAG,UAAU,CAAA,EAAG,CAAA,GAAA,UAAA,WAAW,EAAC,SAAQ,CAAE;YACtD,eAAe,CAAA,EAAG,GAAG,aAAa,CAAA,CAAA,EAAI,QAAO,CAAE;YAEjD;YACE,QAAQ,GAAG,CAAC,WAAW;YACvB,YAAY,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,GAAG,UAAU,CAAA,EAAG,CAAA,GAAA,UAAA,WAAW,EAAC,SAAQ,EAAG,CAAA,GAAA,UAAA,WAAW,EAAC,YAAW,CAAE;YAChF,eAAe,CAAA,EAAG,GAAG,aAAa,CAAA,CAAA,EAAI,QAAO,CAAA,EAAI,CAAA,GAAA,OAAA,cAAc,EAAC,YAAW,CAAE;;IAErF;IAEA,IAAI,WAAW,WAAW;QACxB,IAAI,eAAe,aAAa,kBAAkB,aAAa,iBAAiB,WAAW;YACzF,MAAM,IAAI,MAAM;QAClB;QACA,OAAO;YACL;YACA;YACA;YACA;;IAEJ;IAEA,MAAM,IAAI,MAAM;AAClB;AApCA,QAAA,YAAA,GAAA;AAsCA,SAAgB,oBACd,SAA2B,EAC3B,EAAgB,EAChB,EAAC,QAAQ,EAAE,cAAc,MAAM,EAAE,IAAI,EAAE,SAAS,EAAE,YAAY,EAAgB;IAE9E,IAAI,SAAS,aAAa,aAAa,WAAW;QAChD,MAAM,IAAI,MAAM;IAClB;IAEA,MAAM,EAAC,GAAG,EAAC,GAAG;IAEd,IAAI,aAAa,WAAW;QAC1B,MAAM,EAAC,SAAS,EAAE,WAAW,EAAE,IAAI,EAAC,GAAG;QACvC,MAAM,WAAW,IAAI,GAAG,CAAC,QAAQ,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,GAAG,IAAI,CAAA,EAAG,CAAA,GAAA,UAAA,WAAW,EAAC,UAAS,CAAE,EAAE;QACxE,iBAAiB;QACjB,UAAU,SAAS,GAAG,CAAA,GAAA,UAAA,GAAG,CAAA,CAAA,EAAG,UAAS,EAAG,CAAA,GAAA,OAAA,YAAY,EAAC,UAAU,QAAQ,KAAK,gBAAgB,EAAC,CAAE;QAC/F,UAAU,kBAAkB,GAAG,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,SAAQ,CAAE;QAC7C,UAAU,WAAW,GAAG;eAAI;YAAa,UAAU,kBAAkB;SAAC;IACxE;IAEA,IAAI,SAAS,WAAW;QACtB,MAAM,WAAW,gBAAgB,UAAA,IAAI,GAAG,OAAO,IAAI,GAAG,CAAC,QAAQ,MAAM,OAAM,4BAA4B;QACvG,iBAAiB;QACjB,IAAI,iBAAiB,WAAW,UAAU,YAAY,GAAG;IACzD,2GAA2G;IAC7G;IAEA,IAAI,WAAW,UAAU,SAAS,GAAG;IAErC,SAAS,iBAAiB,SAAe;QACvC,UAAU,IAAI,GAAG;QACjB,UAAU,SAAS,GAAG,GAAG,SAAS,GAAG;QACrC,UAAU,SAAS,GAAG,EAAE;QACxB,GAAG,iBAAiB,GAAG,IAAI;QAC3B,UAAU,UAAU,GAAG,GAAG,IAAI;QAC9B,UAAU,SAAS,GAAG;eAAI,GAAG,SAAS;YAAE;SAAU;IACpD;AACF;AArCA,QAAA,mBAAA,GAAA;AAuCA,SAAgB,oBACd,SAA2B,EAC3B,EAAC,gBAAgB,EAAE,WAAW,EAAE,aAAa,EAAE,YAAY,EAAE,SAAS,EAAgB;IAEtF,IAAI,kBAAkB,WAAW,UAAU,aAAa,GAAG;IAC3D,IAAI,iBAAiB,WAAW,UAAU,YAAY,GAAG;IACzD,IAAI,cAAc,WAAW,UAAU,SAAS,GAAG;IACnD,UAAU,gBAAgB,GAAG,kBAAiB,gBAAgB;IAC9D,UAAU,WAAW,GAAG,aAAY,gBAAgB;AACtD;AATA,QAAA,mBAAA,GAAA"}},
    {"offset": {"line": 2082, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2086, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/compile/resolve.ts"],"sourcesContent":["import type {AnySchema, AnySchemaObject, UriResolver} from \"../types\"\nimport type Ajv from \"../ajv\"\nimport type {URIComponent} from \"fast-uri\"\nimport {eachItem} from \"./util\"\nimport * as equal from \"fast-deep-equal\"\nimport * as traverse from \"json-schema-traverse\"\n\n// the hash of local references inside the schema (created by getSchemaRefs), used for inline resolution\nexport type LocalRefs = {[Ref in string]?: AnySchemaObject}\n\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\n  \"type\",\n  \"format\",\n  \"pattern\",\n  \"maxLength\",\n  \"minLength\",\n  \"maxProperties\",\n  \"minProperties\",\n  \"maxItems\",\n  \"minItems\",\n  \"maximum\",\n  \"minimum\",\n  \"uniqueItems\",\n  \"multipleOf\",\n  \"required\",\n  \"enum\",\n  \"const\",\n])\n\nexport function inlineRef(schema: AnySchema, limit: boolean | number = true): boolean {\n  if (typeof schema == \"boolean\") return true\n  if (limit === true) return !hasRef(schema)\n  if (!limit) return false\n  return countKeys(schema) <= limit\n}\n\nconst REF_KEYWORDS = new Set([\n  \"$ref\",\n  \"$recursiveRef\",\n  \"$recursiveAnchor\",\n  \"$dynamicRef\",\n  \"$dynamicAnchor\",\n])\n\nfunction hasRef(schema: AnySchemaObject): boolean {\n  for (const key in schema) {\n    if (REF_KEYWORDS.has(key)) return true\n    const sch = schema[key]\n    if (Array.isArray(sch) && sch.some(hasRef)) return true\n    if (typeof sch == \"object\" && hasRef(sch)) return true\n  }\n  return false\n}\n\nfunction countKeys(schema: AnySchemaObject): number {\n  let count = 0\n  for (const key in schema) {\n    if (key === \"$ref\") return Infinity\n    count++\n    if (SIMPLE_INLINED.has(key)) continue\n    if (typeof schema[key] == \"object\") {\n      eachItem(schema[key], (sch) => (count += countKeys(sch)))\n    }\n    if (count === Infinity) return Infinity\n  }\n  return count\n}\n\nexport function getFullPath(resolver: UriResolver, id = \"\", normalize?: boolean): string {\n  if (normalize !== false) id = normalizeId(id)\n  const p = resolver.parse(id)\n  return _getFullPath(resolver, p)\n}\n\nexport function _getFullPath(resolver: UriResolver, p: URIComponent): string {\n  const serialized = resolver.serialize(p)\n  return serialized.split(\"#\")[0] + \"#\"\n}\n\nconst TRAILING_SLASH_HASH = /#\\/?$/\nexport function normalizeId(id: string | undefined): string {\n  return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\"\n}\n\nexport function resolveUrl(resolver: UriResolver, baseId: string, id: string): string {\n  id = normalizeId(id)\n  return resolver.resolve(baseId, id)\n}\n\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i\n\nexport function getSchemaRefs(this: Ajv, schema: AnySchema, baseId: string): LocalRefs {\n  if (typeof schema == \"boolean\") return {}\n  const {schemaId, uriResolver} = this.opts\n  const schId = normalizeId(schema[schemaId] || baseId)\n  const baseIds: {[JsonPtr in string]?: string} = {\"\": schId}\n  const pathPrefix = getFullPath(uriResolver, schId, false)\n  const localRefs: LocalRefs = {}\n  const schemaRefs: Set<string> = new Set()\n\n  traverse(schema, {allKeys: true}, (sch, jsonPtr, _, parentJsonPtr) => {\n    if (parentJsonPtr === undefined) return\n    const fullPath = pathPrefix + jsonPtr\n    let innerBaseId = baseIds[parentJsonPtr]\n    if (typeof sch[schemaId] == \"string\") innerBaseId = addRef.call(this, sch[schemaId])\n    addAnchor.call(this, sch.$anchor)\n    addAnchor.call(this, sch.$dynamicAnchor)\n    baseIds[jsonPtr] = innerBaseId\n\n    function addRef(this: Ajv, ref: string): string {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const _resolve = this.opts.uriResolver.resolve\n      ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref)\n      if (schemaRefs.has(ref)) throw ambiguos(ref)\n      schemaRefs.add(ref)\n      let schOrRef = this.refs[ref]\n      if (typeof schOrRef == \"string\") schOrRef = this.refs[schOrRef]\n      if (typeof schOrRef == \"object\") {\n        checkAmbiguosRef(sch, schOrRef.schema, ref)\n      } else if (ref !== normalizeId(fullPath)) {\n        if (ref[0] === \"#\") {\n          checkAmbiguosRef(sch, localRefs[ref], ref)\n          localRefs[ref] = sch\n        } else {\n          this.refs[ref] = fullPath\n        }\n      }\n      return ref\n    }\n\n    function addAnchor(this: Ajv, anchor: unknown): void {\n      if (typeof anchor == \"string\") {\n        if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor \"${anchor}\"`)\n        addRef.call(this, `#${anchor}`)\n      }\n    }\n  })\n\n  return localRefs\n\n  function checkAmbiguosRef(sch1: AnySchema, sch2: AnySchema | undefined, ref: string): void {\n    if (sch2 !== undefined && !equal(sch1, sch2)) throw ambiguos(ref)\n  }\n\n  function ambiguos(ref: string): Error {\n    return new Error(`reference \"${ref}\" resolves to more than one schema`)\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2227, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2231, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/compile/validate/index.ts"],"sourcesContent":["import type {\n  AddedKeywordDefinition,\n  AnySchema,\n  AnySchemaObject,\n  KeywordErrorCxt,\n  KeywordCxtParams,\n} from \"../../types\"\nimport type {SchemaCxt, SchemaObjCxt} from \"..\"\nimport type {InstanceOptions} from \"../../core\"\nimport {boolOrEmptySchema, topBoolOrEmptySchema} from \"./boolSchema\"\nimport {coerceAndCheckDataType, getSchemaTypes} from \"./dataType\"\nimport {shouldUseGroup, shouldUseRule} from \"./applicability\"\nimport {checkDataType, checkDataTypes, reportTypeError, DataType} from \"./dataType\"\nimport {assignDefaults} from \"./defaults\"\nimport {funcKeywordCode, macroKeywordCode, validateKeywordUsage, validSchemaType} from \"./keyword\"\nimport {getSubschema, extendSubschemaData, SubschemaArgs, extendSubschemaMode} from \"./subschema\"\nimport {_, nil, str, or, not, getProperty, Block, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport {resolveUrl} from \"../resolve\"\nimport {\n  schemaRefOrVal,\n  schemaHasRulesButRef,\n  checkUnknownRules,\n  checkStrictMode,\n  unescapeJsonPointer,\n  mergeEvaluated,\n} from \"../util\"\nimport type {JSONType, Rule, RuleGroup} from \"../rules\"\nimport {\n  ErrorPaths,\n  reportError,\n  reportExtraError,\n  resetErrorsCount,\n  keyword$DataError,\n} from \"../errors\"\n\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nexport function validateFunctionCode(it: SchemaCxt): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      topSchemaObjCode(it)\n      return\n    }\n  }\n  validateFunction(it, () => topBoolOrEmptySchema(it))\n}\n\nfunction validateFunction(\n  {gen, validateName, schema, schemaEnv, opts}: SchemaCxt,\n  body: Block\n): void {\n  if (opts.code.es5) {\n    gen.func(validateName, _`${N.data}, ${N.valCxt}`, schemaEnv.$async, () => {\n      gen.code(_`\"use strict\"; ${funcSourceUrl(schema, opts)}`)\n      destructureValCxtES5(gen, opts)\n      gen.code(body)\n    })\n  } else {\n    gen.func(validateName, _`${N.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () =>\n      gen.code(funcSourceUrl(schema, opts)).code(body)\n    )\n  }\n}\n\nfunction destructureValCxt(opts: InstanceOptions): Code {\n  return _`{${N.instancePath}=\"\", ${N.parentData}, ${N.parentDataProperty}, ${N.rootData}=${\n    N.data\n  }${opts.dynamicRef ? _`, ${N.dynamicAnchors}={}` : nil}}={}`\n}\n\nfunction destructureValCxtES5(gen: CodeGen, opts: InstanceOptions): void {\n  gen.if(\n    N.valCxt,\n    () => {\n      gen.var(N.instancePath, _`${N.valCxt}.${N.instancePath}`)\n      gen.var(N.parentData, _`${N.valCxt}.${N.parentData}`)\n      gen.var(N.parentDataProperty, _`${N.valCxt}.${N.parentDataProperty}`)\n      gen.var(N.rootData, _`${N.valCxt}.${N.rootData}`)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`${N.valCxt}.${N.dynamicAnchors}`)\n    },\n    () => {\n      gen.var(N.instancePath, _`\"\"`)\n      gen.var(N.parentData, _`undefined`)\n      gen.var(N.parentDataProperty, _`undefined`)\n      gen.var(N.rootData, N.data)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`{}`)\n    }\n  )\n}\n\nfunction topSchemaObjCode(it: SchemaObjCxt): void {\n  const {schema, opts, gen} = it\n  validateFunction(it, () => {\n    if (opts.$comment && schema.$comment) commentKeyword(it)\n    checkNoDefault(it)\n    gen.let(N.vErrors, null)\n    gen.let(N.errors, 0)\n    if (opts.unevaluated) resetEvaluated(it)\n    typeAndKeywords(it)\n    returnResults(it)\n  })\n  return\n}\n\nfunction resetEvaluated(it: SchemaObjCxt): void {\n  // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n  const {gen, validateName} = it\n  it.evaluated = gen.const(\"evaluated\", _`${validateName}.evaluated`)\n  gen.if(_`${it.evaluated}.dynamicProps`, () => gen.assign(_`${it.evaluated}.props`, _`undefined`))\n  gen.if(_`${it.evaluated}.dynamicItems`, () => gen.assign(_`${it.evaluated}.items`, _`undefined`))\n}\n\nfunction funcSourceUrl(schema: AnySchema, opts: InstanceOptions): Code {\n  const schId = typeof schema == \"object\" && schema[opts.schemaId]\n  return schId && (opts.code.source || opts.code.process) ? _`/*# sourceURL=${schId} */` : nil\n}\n\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it: SchemaCxt, valid: Name): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      subSchemaObjCode(it, valid)\n      return\n    }\n  }\n  boolOrEmptySchema(it, valid)\n}\n\nfunction schemaCxtHasRules({schema, self}: SchemaCxt): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (self.RULES.all[key]) return true\n  return false\n}\n\nfunction isSchemaObj(it: SchemaCxt): it is SchemaObjCxt {\n  return typeof it.schema != \"boolean\"\n}\n\nfunction subSchemaObjCode(it: SchemaObjCxt, valid: Name): void {\n  const {schema, gen, opts} = it\n  if (opts.$comment && schema.$comment) commentKeyword(it)\n  updateContext(it)\n  checkAsyncSchema(it)\n  const errsCount = gen.const(\"_errs\", N.errors)\n  typeAndKeywords(it, errsCount)\n  // TODO var\n  gen.var(valid, _`${errsCount} === ${N.errors}`)\n}\n\nfunction checkKeywords(it: SchemaObjCxt): void {\n  checkUnknownRules(it)\n  checkRefsAndKeywords(it)\n}\n\nfunction typeAndKeywords(it: SchemaObjCxt, errsCount?: Name): void {\n  if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount)\n  const types = getSchemaTypes(it.schema)\n  const checkedTypes = coerceAndCheckDataType(it, types)\n  schemaKeywords(it, types, !checkedTypes, errsCount)\n}\n\nfunction checkRefsAndKeywords(it: SchemaObjCxt): void {\n  const {schema, errSchemaPath, opts, self} = it\n  if (schema.$ref && opts.ignoreKeywordsWithRef && schemaHasRulesButRef(schema, self.RULES)) {\n    self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`)\n  }\n}\n\nfunction checkNoDefault(it: SchemaObjCxt): void {\n  const {schema, opts} = it\n  if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n    checkStrictMode(it, \"default is ignored in the schema root\")\n  }\n}\n\nfunction updateContext(it: SchemaObjCxt): void {\n  const schId = it.schema[it.opts.schemaId]\n  if (schId) it.baseId = resolveUrl(it.opts.uriResolver, it.baseId, schId)\n}\n\nfunction checkAsyncSchema(it: SchemaObjCxt): void {\n  if (it.schema.$async && !it.schemaEnv.$async) throw new Error(\"async schema in sync schema\")\n}\n\nfunction commentKeyword({gen, schemaEnv, schema, errSchemaPath, opts}: SchemaObjCxt): void {\n  const msg = schema.$comment\n  if (opts.$comment === true) {\n    gen.code(_`${N.self}.logger.log(${msg})`)\n  } else if (typeof opts.$comment == \"function\") {\n    const schemaPath = str`${errSchemaPath}/$comment`\n    const rootName = gen.scopeValue(\"root\", {ref: schemaEnv.root})\n    gen.code(_`${N.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`)\n  }\n}\n\nfunction returnResults(it: SchemaCxt): void {\n  const {gen, schemaEnv, validateName, ValidationError, opts} = it\n  if (schemaEnv.$async) {\n    // TODO assign unevaluated\n    gen.if(\n      _`${N.errors} === 0`,\n      () => gen.return(N.data),\n      () => gen.throw(_`new ${ValidationError as Name}(${N.vErrors})`)\n    )\n  } else {\n    gen.assign(_`${validateName}.errors`, N.vErrors)\n    if (opts.unevaluated) assignEvaluated(it)\n    gen.return(_`${N.errors} === 0`)\n  }\n}\n\nfunction assignEvaluated({gen, evaluated, props, items}: SchemaCxt): void {\n  if (props instanceof Name) gen.assign(_`${evaluated}.props`, props)\n  if (items instanceof Name) gen.assign(_`${evaluated}.items`, items)\n}\n\nfunction schemaKeywords(\n  it: SchemaObjCxt,\n  types: JSONType[],\n  typeErrors: boolean,\n  errsCount?: Name\n): void {\n  const {gen, schema, data, allErrors, opts, self} = it\n  const {RULES} = self\n  if (schema.$ref && (opts.ignoreKeywordsWithRef || !schemaHasRulesButRef(schema, RULES))) {\n    gen.block(() => keywordCode(it, \"$ref\", (RULES.all.$ref as Rule).definition)) // TODO typecast\n    return\n  }\n  if (!opts.jtd) checkStrictTypes(it, types)\n  gen.block(() => {\n    for (const group of RULES.rules) groupKeywords(group)\n    groupKeywords(RULES.post)\n  })\n\n  function groupKeywords(group: RuleGroup): void {\n    if (!shouldUseGroup(schema, group)) return\n    if (group.type) {\n      gen.if(checkDataType(group.type, data, opts.strictNumbers))\n      iterateKeywords(it, group)\n      if (types.length === 1 && types[0] === group.type && typeErrors) {\n        gen.else()\n        reportTypeError(it)\n      }\n      gen.endIf()\n    } else {\n      iterateKeywords(it, group)\n    }\n    // TODO make it \"ok\" call?\n    if (!allErrors) gen.if(_`${N.errors} === ${errsCount || 0}`)\n  }\n}\n\nfunction iterateKeywords(it: SchemaObjCxt, group: RuleGroup): void {\n  const {\n    gen,\n    schema,\n    opts: {useDefaults},\n  } = it\n  if (useDefaults) assignDefaults(it, group.type)\n  gen.block(() => {\n    for (const rule of group.rules) {\n      if (shouldUseRule(schema, rule)) {\n        keywordCode(it, rule.keyword, rule.definition, group.type)\n      }\n    }\n  })\n}\n\nfunction checkStrictTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (it.schemaEnv.meta || !it.opts.strictTypes) return\n  checkContextTypes(it, types)\n  if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types)\n  checkKeywordTypes(it, it.dataTypes)\n}\n\nfunction checkContextTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (!types.length) return\n  if (!it.dataTypes.length) {\n    it.dataTypes = types\n    return\n  }\n  types.forEach((t) => {\n    if (!includesType(it.dataTypes, t)) {\n      strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`)\n    }\n  })\n  narrowSchemaTypes(it, types)\n}\n\nfunction checkMultipleTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n    strictTypesError(it, \"use allowUnionTypes to allow union type keyword\")\n  }\n}\n\nfunction checkKeywordTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  const rules = it.self.RULES.all\n  for (const keyword in rules) {\n    const rule = rules[keyword]\n    if (typeof rule == \"object\" && shouldUseRule(it.schema, rule)) {\n      const {type} = rule.definition\n      if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n        strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`)\n      }\n    }\n  }\n}\n\nfunction hasApplicableType(schTs: JSONType[], kwdT: JSONType): boolean {\n  return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"))\n}\n\nfunction includesType(ts: JSONType[], t: JSONType): boolean {\n  return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"))\n}\n\nfunction narrowSchemaTypes(it: SchemaObjCxt, withTypes: JSONType[]): void {\n  const ts: JSONType[] = []\n  for (const t of it.dataTypes) {\n    if (includesType(withTypes, t)) ts.push(t)\n    else if (withTypes.includes(\"integer\") && t === \"number\") ts.push(\"integer\")\n  }\n  it.dataTypes = ts\n}\n\nfunction strictTypesError(it: SchemaObjCxt, msg: string): void {\n  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n  msg += ` at \"${schemaPath}\" (strictTypes)`\n  checkStrictMode(it, msg, it.opts.strictTypes)\n}\n\nexport class KeywordCxt implements KeywordErrorCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean\n  readonly keyword: string\n  readonly data: Name // Name referencing the current level of the data instance\n  readonly $data?: string | false\n  schema: any // keyword value in the schema\n  readonly schemaValue: Code | number | boolean // Code reference to keyword schema value or primitive value\n  readonly schemaCode: Code | number | boolean // Code reference to resolved schema value (different if schema is $data)\n  readonly schemaType: JSONType[] // allowed type(s) of keyword value in the schema\n  readonly parentSchema: AnySchemaObject\n  readonly errsCount?: Name // Name reference to the number of validation errors collected before this keyword,\n  // requires option trackErrors in keyword definition\n  params: KeywordCxtParams // object to pass parameters to error messages from keyword code\n  readonly it: SchemaObjCxt // schema compilation context (schema is guaranteed to be an object, not boolean)\n  readonly def: AddedKeywordDefinition\n\n  constructor(it: SchemaObjCxt, def: AddedKeywordDefinition, keyword: string) {\n    validateKeywordUsage(it, def, keyword)\n    this.gen = it.gen\n    this.allErrors = it.allErrors\n    this.keyword = keyword\n    this.data = it.data\n    this.schema = it.schema[keyword]\n    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data\n    this.schemaValue = schemaRefOrVal(it, this.schema, keyword, this.$data)\n    this.schemaType = def.schemaType\n    this.parentSchema = it.schema\n    this.params = {}\n    this.it = it\n    this.def = def\n\n    if (this.$data) {\n      this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it))\n    } else {\n      this.schemaCode = this.schemaValue\n      if (!validSchemaType(this.schema, def.schemaType, def.allowUndefined)) {\n        throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`)\n      }\n    }\n\n    if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n      this.errsCount = it.gen.const(\"_errs\", N.errors)\n    }\n  }\n\n  result(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.failResult(not(condition), successAction, failAction)\n  }\n\n  failResult(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.gen.if(condition)\n    if (failAction) failAction()\n    else this.error()\n    if (successAction) {\n      this.gen.else()\n      successAction()\n      if (this.allErrors) this.gen.endIf()\n    } else {\n      if (this.allErrors) this.gen.endIf()\n      else this.gen.else()\n    }\n  }\n\n  pass(condition: Code, failAction?: () => void): void {\n    this.failResult(not(condition), undefined, failAction)\n  }\n\n  fail(condition?: Code): void {\n    if (condition === undefined) {\n      this.error()\n      if (!this.allErrors) this.gen.if(false) // this branch will be removed by gen.optimize\n      return\n    }\n    this.gen.if(condition)\n    this.error()\n    if (this.allErrors) this.gen.endIf()\n    else this.gen.else()\n  }\n\n  fail$data(condition: Code): void {\n    if (!this.$data) return this.fail(condition)\n    const {schemaCode} = this\n    this.fail(_`${schemaCode} !== undefined && (${or(this.invalid$data(), condition)})`)\n  }\n\n  error(append?: boolean, errorParams?: KeywordCxtParams, errorPaths?: ErrorPaths): void {\n    if (errorParams) {\n      this.setParams(errorParams)\n      this._error(append, errorPaths)\n      this.setParams({})\n      return\n    }\n    this._error(append, errorPaths)\n  }\n\n  private _error(append?: boolean, errorPaths?: ErrorPaths): void {\n    ;(append ? reportExtraError : reportError)(this, this.def.error, errorPaths)\n  }\n\n  $dataError(): void {\n    reportError(this, this.def.$dataError || keyword$DataError)\n  }\n\n  reset(): void {\n    if (this.errsCount === undefined) throw new Error('add \"trackErrors\" to keyword definition')\n    resetErrorsCount(this.gen, this.errsCount)\n  }\n\n  ok(cond: Code | boolean): void {\n    if (!this.allErrors) this.gen.if(cond)\n  }\n\n  setParams(obj: KeywordCxtParams, assign?: true): void {\n    if (assign) Object.assign(this.params, obj)\n    else this.params = obj\n  }\n\n  block$data(valid: Name, codeBlock: () => void, $dataValid: Code = nil): void {\n    this.gen.block(() => {\n      this.check$data(valid, $dataValid)\n      codeBlock()\n    })\n  }\n\n  check$data(valid: Name = nil, $dataValid: Code = nil): void {\n    if (!this.$data) return\n    const {gen, schemaCode, schemaType, def} = this\n    gen.if(or(_`${schemaCode} === undefined`, $dataValid))\n    if (valid !== nil) gen.assign(valid, true)\n    if (schemaType.length || def.validateSchema) {\n      gen.elseIf(this.invalid$data())\n      this.$dataError()\n      if (valid !== nil) gen.assign(valid, false)\n    }\n    gen.else()\n  }\n\n  invalid$data(): Code {\n    const {gen, schemaCode, schemaType, def, it} = this\n    return or(wrong$DataType(), invalid$DataSchema())\n\n    function wrong$DataType(): Code {\n      if (schemaType.length) {\n        /* istanbul ignore if */\n        if (!(schemaCode instanceof Name)) throw new Error(\"ajv implementation error\")\n        const st = Array.isArray(schemaType) ? schemaType : [schemaType]\n        return _`${checkDataTypes(st, schemaCode, it.opts.strictNumbers, DataType.Wrong)}`\n      }\n      return nil\n    }\n\n    function invalid$DataSchema(): Code {\n      if (def.validateSchema) {\n        const validateSchemaRef = gen.scopeValue(\"validate$data\", {ref: def.validateSchema}) // TODO value.code for standalone\n        return _`!${validateSchemaRef}(${schemaCode})`\n      }\n      return nil\n    }\n  }\n\n  subschema(appl: SubschemaArgs, valid: Name): SchemaCxt {\n    const subschema = getSubschema(this.it, appl)\n    extendSubschemaData(subschema, this.it, appl)\n    extendSubschemaMode(subschema, appl)\n    const nextContext = {...this.it, ...subschema, items: undefined, props: undefined}\n    subschemaCode(nextContext, valid)\n    return nextContext\n  }\n\n  mergeEvaluated(schemaCxt: SchemaCxt, toName?: typeof Name): void {\n    const {it, gen} = this\n    if (!it.opts.unevaluated) return\n    if (it.props !== true && schemaCxt.props !== undefined) {\n      it.props = mergeEvaluated.props(gen, schemaCxt.props, it.props, toName)\n    }\n    if (it.items !== true && schemaCxt.items !== undefined) {\n      it.items = mergeEvaluated.items(gen, schemaCxt.items, it.items, toName)\n    }\n  }\n\n  mergeValidEvaluated(schemaCxt: SchemaCxt, valid: Name): boolean | void {\n    const {it, gen} = this\n    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n      gen.if(valid, () => this.mergeEvaluated(schemaCxt, Name))\n      return true\n    }\n  }\n}\n\nfunction keywordCode(\n  it: SchemaObjCxt,\n  keyword: string,\n  def: AddedKeywordDefinition,\n  ruleType?: JSONType\n): void {\n  const cxt = new KeywordCxt(it, def, keyword)\n  if (\"code\" in def) {\n    def.code(cxt, ruleType)\n  } else if (cxt.$data && def.validate) {\n    funcKeywordCode(cxt, def)\n  } else if (\"macro\" in def) {\n    macroKeywordCode(cxt, def)\n  } else if (def.compile || def.validate) {\n    funcKeywordCode(cxt, def)\n  }\n}\n\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/\nexport function getData(\n  $data: string,\n  {dataLevel, dataNames, dataPathArr}: SchemaCxt\n): Code | number {\n  let jsonPointer\n  let data: Code\n  if ($data === \"\") return N.rootData\n  if ($data[0] === \"/\") {\n    if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    jsonPointer = $data\n    data = N.rootData\n  } else {\n    const matches = RELATIVE_JSON_POINTER.exec($data)\n    if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    const up: number = +matches[1]\n    jsonPointer = matches[2]\n    if (jsonPointer === \"#\") {\n      if (up >= dataLevel) throw new Error(errorMsg(\"property/index\", up))\n      return dataPathArr[dataLevel - up]\n    }\n    if (up > dataLevel) throw new Error(errorMsg(\"data\", up))\n    data = dataNames[dataLevel - up]\n    if (!jsonPointer) return data\n  }\n\n  let expr = data\n  const segments = jsonPointer.split(\"/\")\n  for (const segment of segments) {\n    if (segment) {\n      data = _`${data}${getProperty(unescapeJsonPointer(segment))}`\n      expr = _`${expr} && ${data}`\n    }\n  }\n  return expr\n\n  function errorMsg(pointerType: string, up: number): string {\n    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`\n  }\n}\n"],"names":[],"mappings":";;;;;AASA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AASA,MAAA;AAQA,mGAAmG;AACnG,SAAgB,qBAAqB,EAAa;IAChD,IAAI,YAAY,KAAK;QACnB,cAAc;QACd,IAAI,kBAAkB,KAAK;YACzB,iBAAiB;YACjB;QACF;IACF;IACA,iBAAiB,IAAI,IAAM,CAAA,GAAA,aAAA,oBAAoB,EAAC;AAClD;AATA,QAAA,oBAAA,GAAA;AAWA,SAAS,iBACP,EAAC,GAAG,EAAE,YAAY,EAAE,MAAM,EAAE,SAAS,EAAE,IAAI,EAAY,EACvD,IAAW;IAEX,IAAI,KAAK,IAAI,CAAC,GAAG,EAAE;QACjB,IAAI,IAAI,CAAC,cAAc,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,QAAA,OAAC,CAAC,IAAI,CAAA,EAAA,EAAK,QAAA,OAAC,CAAC,MAAM,CAAA,CAAE,EAAE,UAAU,MAAM,EAAE;YAClE,IAAI,IAAI,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,cAAA,EAAiB,cAAc,QAAQ,MAAK,CAAE;YACxD,qBAAqB,KAAK;YAC1B,IAAI,IAAI,CAAC;QACX;IACF,OAAO;QACL,IAAI,IAAI,CAAC,cAAc,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,QAAA,OAAC,CAAC,IAAI,CAAA,EAAA,EAAK,kBAAkB,MAAK,CAAE,EAAE,UAAU,MAAM,EAAE,IACjF,IAAI,IAAI,CAAC,cAAc,QAAQ,OAAO,IAAI,CAAC;IAE/C;AACF;AAEA,SAAS,kBAAkB,IAAqB;IAC9C,OAAO,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,CAAA,EAAI,QAAA,OAAC,CAAC,YAAY,CAAA,KAAA,EAAQ,QAAA,OAAC,CAAC,UAAU,CAAA,EAAA,EAAK,QAAA,OAAC,CAAC,kBAAkB,CAAA,EAAA,EAAK,QAAA,OAAC,CAAC,QAAQ,CAAA,CAAA,EACpF,QAAA,OAAC,CAAC,IACJ,CAAA,EAAG,KAAK,UAAU,GAAG,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAA,EAAK,QAAA,OAAC,CAAC,cAAc,CAAA,GAAA,CAAK,GAAG,UAAA,GAAG,CAAA,IAAA,CAAM;AAC9D;AAEA,SAAS,qBAAqB,GAAY,EAAE,IAAqB;IAC/D,IAAI,EAAE,CACJ,QAAA,OAAC,CAAC,MAAM,EACR;QACE,IAAI,GAAG,CAAC,QAAA,OAAC,CAAC,YAAY,EAAE,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,QAAA,OAAC,CAAC,MAAM,CAAA,CAAA,EAAI,QAAA,OAAC,CAAC,YAAY,CAAA,CAAE;QACxD,IAAI,GAAG,CAAC,QAAA,OAAC,CAAC,UAAU,EAAE,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,QAAA,OAAC,CAAC,MAAM,CAAA,CAAA,EAAI,QAAA,OAAC,CAAC,UAAU,CAAA,CAAE;QACpD,IAAI,GAAG,CAAC,QAAA,OAAC,CAAC,kBAAkB,EAAE,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,QAAA,OAAC,CAAC,MAAM,CAAA,CAAA,EAAI,QAAA,OAAC,CAAC,kBAAkB,CAAA,CAAE;QACpE,IAAI,GAAG,CAAC,QAAA,OAAC,CAAC,QAAQ,EAAE,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,QAAA,OAAC,CAAC,MAAM,CAAA,CAAA,EAAI,QAAA,OAAC,CAAC,QAAQ,CAAA,CAAE;QAChD,IAAI,KAAK,UAAU,EAAE,IAAI,GAAG,CAAC,QAAA,OAAC,CAAC,cAAc,EAAE,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,QAAA,OAAC,CAAC,MAAM,CAAA,CAAA,EAAI,QAAA,OAAC,CAAC,cAAc,CAAA,CAAE;IACnF,GACA;QACE,IAAI,GAAG,CAAC,QAAA,OAAC,CAAC,YAAY,EAAE,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAA,CAAI;QAC7B,IAAI,GAAG,CAAC,QAAA,OAAC,CAAC,UAAU,EAAE,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,SAAA,CAAW;QAClC,IAAI,GAAG,CAAC,QAAA,OAAC,CAAC,kBAAkB,EAAE,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,SAAA,CAAW;QAC1C,IAAI,GAAG,CAAC,QAAA,OAAC,CAAC,QAAQ,EAAE,QAAA,OAAC,CAAC,IAAI;QAC1B,IAAI,KAAK,UAAU,EAAE,IAAI,GAAG,CAAC,QAAA,OAAC,CAAC,cAAc,EAAE,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAA,CAAI;IACtD;AAEJ;AAEA,SAAS,iBAAiB,EAAgB;IACxC,MAAM,EAAC,MAAM,EAAE,IAAI,EAAE,GAAG,EAAC,GAAG;IAC5B,iBAAiB,IAAI;QACnB,IAAI,KAAK,QAAQ,IAAI,OAAO,QAAQ,EAAE,eAAe;QACrD,eAAe;QACf,IAAI,GAAG,CAAC,QAAA,OAAC,CAAC,OAAO,EAAE;QACnB,IAAI,GAAG,CAAC,QAAA,OAAC,CAAC,MAAM,EAAE;QAClB,IAAI,KAAK,WAAW,EAAE,eAAe;QACrC,gBAAgB;QAChB,cAAc;IAChB;IACA;AACF;AAEA,SAAS,eAAe,EAAgB;IACtC,6GAA6G;IAC7G,MAAM,EAAC,GAAG,EAAE,YAAY,EAAC,GAAG;IAC5B,GAAG,SAAS,GAAG,IAAI,KAAK,CAAC,aAAa,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,aAAY,UAAA,CAAY;IAClE,IAAI,EAAE,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,GAAG,SAAS,CAAA,aAAA,CAAe,EAAE,IAAM,IAAI,MAAM,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,GAAG,SAAS,CAAA,MAAA,CAAQ,EAAE,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,SAAA,CAAW;IAC/F,IAAI,EAAE,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,GAAG,SAAS,CAAA,aAAA,CAAe,EAAE,IAAM,IAAI,MAAM,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,GAAG,SAAS,CAAA,MAAA,CAAQ,EAAE,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,SAAA,CAAW;AACjG;AAEA,SAAS,cAAc,MAAiB,EAAE,IAAqB;IAC7D,MAAM,QAAQ,OAAO,UAAU,YAAY,MAAM,CAAC,KAAK,QAAQ,CAAC;IAChE,OAAO,SAAS,CAAC,KAAK,IAAI,CAAC,MAAM,IAAI,KAAK,IAAI,CAAC,OAAO,IAAI,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,cAAA,EAAiB,MAAK,GAAA,CAAK,GAAG,UAAA,GAAG;AAC9F;AAEA,0FAA0F;AAC1F,SAAS,cAAc,EAAa,EAAE,KAAW;IAC/C,IAAI,YAAY,KAAK;QACnB,cAAc;QACd,IAAI,kBAAkB,KAAK;YACzB,iBAAiB,IAAI;YACrB;QACF;IACF;IACA,CAAA,GAAA,aAAA,iBAAiB,EAAC,IAAI;AACxB;AAEA,SAAS,kBAAkB,EAAC,MAAM,EAAE,IAAI,EAAY;IAClD,IAAI,OAAO,UAAU,WAAW,OAAO,CAAC;IACxC,IAAK,MAAM,OAAO,OAAQ,IAAI,KAAK,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE,OAAO;IAC1D,OAAO;AACT;AAEA,SAAS,YAAY,EAAa;IAChC,OAAO,OAAO,GAAG,MAAM,IAAI;AAC7B;AAEA,SAAS,iBAAiB,EAAgB,EAAE,KAAW;IACrD,MAAM,EAAC,MAAM,EAAE,GAAG,EAAE,IAAI,EAAC,GAAG;IAC5B,IAAI,KAAK,QAAQ,IAAI,OAAO,QAAQ,EAAE,eAAe;IACrD,cAAc;IACd,iBAAiB;IACjB,MAAM,YAAY,IAAI,KAAK,CAAC,SAAS,QAAA,OAAC,CAAC,MAAM;IAC7C,gBAAgB,IAAI;IACpB,WAAW;IACX,IAAI,GAAG,CAAC,OAAO,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,UAAS,KAAA,EAAQ,QAAA,OAAC,CAAC,MAAM,CAAA,CAAE;AAChD;AAEA,SAAS,cAAc,EAAgB;IACrC,CAAA,GAAA,OAAA,iBAAiB,EAAC;IAClB,qBAAqB;AACvB;AAEA,SAAS,gBAAgB,EAAgB,EAAE,SAAgB;IACzD,IAAI,GAAG,IAAI,CAAC,GAAG,EAAE,OAAO,eAAe,IAAI,EAAE,EAAE,OAAO;IACtD,MAAM,QAAQ,CAAA,GAAA,WAAA,cAAc,EAAC,GAAG,MAAM;IACtC,MAAM,eAAe,CAAA,GAAA,WAAA,sBAAsB,EAAC,IAAI;IAChD,eAAe,IAAI,OAAO,CAAC,cAAc;AAC3C;AAEA,SAAS,qBAAqB,EAAgB;IAC5C,MAAM,EAAC,MAAM,EAAE,aAAa,EAAE,IAAI,EAAE,IAAI,EAAC,GAAG;IAC5C,IAAI,OAAO,IAAI,IAAI,KAAK,qBAAqB,IAAI,CAAA,GAAA,OAAA,oBAAoB,EAAC,QAAQ,KAAK,KAAK,GAAG;QACzF,KAAK,MAAM,CAAC,IAAI,CAAC,CAAA,0CAAA,EAA6C,cAAa,CAAA,CAAG;IAChF;AACF;AAEA,SAAS,eAAe,EAAgB;IACtC,MAAM,EAAC,MAAM,EAAE,IAAI,EAAC,GAAG;IACvB,IAAI,OAAO,OAAO,KAAK,aAAa,KAAK,WAAW,IAAI,KAAK,YAAY,EAAE;QACzE,CAAA,GAAA,OAAA,eAAe,EAAC,IAAI;IACtB;AACF;AAEA,SAAS,cAAc,EAAgB;IACrC,MAAM,QAAQ,GAAG,MAAM,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC;IACzC,IAAI,OAAO,GAAG,MAAM,GAAG,CAAA,GAAA,UAAA,UAAU,EAAC,GAAG,IAAI,CAAC,WAAW,EAAE,GAAG,MAAM,EAAE;AACpE;AAEA,SAAS,iBAAiB,EAAgB;IACxC,IAAI,GAAG,MAAM,CAAC,MAAM,IAAI,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,MAAM,IAAI,MAAM;AAChE;AAEA,SAAS,eAAe,EAAC,GAAG,EAAE,SAAS,EAAE,MAAM,EAAE,aAAa,EAAE,IAAI,EAAe;IACjF,MAAM,MAAM,OAAO,QAAQ;IAC3B,IAAI,KAAK,QAAQ,KAAK,MAAM;QAC1B,IAAI,IAAI,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,QAAA,OAAC,CAAC,IAAI,CAAA,YAAA,EAAe,IAAG,CAAA,CAAG;IAC1C,OAAO,IAAI,OAAO,KAAK,QAAQ,IAAI,YAAY;QAC7C,MAAM,aAAa,CAAA,GAAA,UAAA,GAAG,CAAA,CAAA,EAAG,cAAa,SAAA,CAAW;QACjD,MAAM,WAAW,IAAI,UAAU,CAAC,QAAQ;YAAC,KAAK,UAAU,IAAI;QAAA;QAC5D,IAAI,IAAI,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,QAAA,OAAC,CAAC,IAAI,CAAA,eAAA,EAAkB,IAAG,EAAA,EAAK,WAAU,EAAA,EAAK,SAAQ,QAAA,CAAU;IAChF;AACF;AAEA,SAAS,cAAc,EAAa;IAClC,MAAM,EAAC,GAAG,EAAE,SAAS,EAAE,YAAY,EAAE,eAAe,EAAE,IAAI,EAAC,GAAG;IAC9D,IAAI,UAAU,MAAM,EAAE;QACpB,0BAA0B;QAC1B,IAAI,EAAE,CACJ,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,QAAA,OAAC,CAAC,MAAM,CAAA,MAAA,CAAQ,EACpB,IAAM,IAAI,MAAM,CAAC,QAAA,OAAC,CAAC,IAAI,GACvB,IAAM,IAAI,KAAK,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,IAAA,EAAO,gBAAuB,CAAA,EAAI,QAAA,OAAC,CAAC,OAAO,CAAA,CAAA,CAAG;IAEnE,OAAO;QACL,IAAI,MAAM,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,aAAY,OAAA,CAAS,EAAE,QAAA,OAAC,CAAC,OAAO;QAC/C,IAAI,KAAK,WAAW,EAAE,gBAAgB;QACtC,IAAI,MAAM,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,QAAA,OAAC,CAAC,MAAM,CAAA,MAAA,CAAQ;IACjC;AACF;AAEA,SAAS,gBAAgB,EAAC,GAAG,EAAE,SAAS,EAAE,KAAK,EAAE,KAAK,EAAY;IAChE,IAAI,iBAAiB,UAAA,IAAI,EAAE,IAAI,MAAM,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,UAAS,MAAA,CAAQ,EAAE;IAC7D,IAAI,iBAAiB,UAAA,IAAI,EAAE,IAAI,MAAM,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,UAAS,MAAA,CAAQ,EAAE;AAC/D;AAEA,SAAS,eACP,EAAgB,EAChB,KAAiB,EACjB,UAAmB,EACnB,SAAgB;IAEhB,MAAM,EAAC,GAAG,EAAE,MAAM,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAE,IAAI,EAAC,GAAG;IACnD,MAAM,EAAC,KAAK,EAAC,GAAG;IAChB,IAAI,OAAO,IAAI,IAAI,CAAC,KAAK,qBAAqB,IAAI,CAAC,CAAA,GAAA,OAAA,oBAAoB,EAAC,QAAQ,MAAM,GAAG;QACvF,IAAI,KAAK,CAAC,IAAM,YAAY,IAAI,QAAS,MAAM,GAAG,CAAC,IAAa,CAAC,UAAU,IAAG,gBAAgB;QAC9F;IACF;IACA,IAAI,CAAC,KAAK,GAAG,EAAE,iBAAiB,IAAI;IACpC,IAAI,KAAK,CAAC;QACR,KAAK,MAAM,SAAS,MAAM,KAAK,CAAE,cAAc;QAC/C,cAAc,MAAM,IAAI;IAC1B;IAEA,SAAS,cAAc,KAAgB;QACrC,IAAI,CAAC,CAAA,GAAA,gBAAA,cAAc,EAAC,QAAQ,QAAQ;QACpC,IAAI,MAAM,IAAI,EAAE;YACd,IAAI,EAAE,CAAC,CAAA,GAAA,WAAA,aAAa,EAAC,MAAM,IAAI,EAAE,MAAM,KAAK,aAAa;YACzD,gBAAgB,IAAI;YACpB,IAAI,MAAM,MAAM,KAAK,KAAK,KAAK,CAAC,EAAE,KAAK,MAAM,IAAI,IAAI,YAAY;gBAC/D,IAAI,IAAI;gBACR,CAAA,GAAA,WAAA,eAAe,EAAC;YAClB;YACA,IAAI,KAAK;QACX,OAAO;YACL,gBAAgB,IAAI;QACtB;QACA,0BAA0B;QAC1B,IAAI,CAAC,WAAW,IAAI,EAAE,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,QAAA,OAAC,CAAC,MAAM,CAAA,KAAA,EAAQ,aAAa,EAAC,CAAE;IAC7D;AACF;AAEA,SAAS,gBAAgB,EAAgB,EAAE,KAAgB;IACzD,MAAM,EACJ,GAAG,EACH,MAAM,EACN,MAAM,EAAC,WAAW,EAAC,EACpB,GAAG;IACJ,IAAI,aAAa,CAAA,GAAA,WAAA,cAAc,EAAC,IAAI,MAAM,IAAI;IAC9C,IAAI,KAAK,CAAC;QACR,KAAK,MAAM,QAAQ,MAAM,KAAK,CAAE;YAC9B,IAAI,CAAA,GAAA,gBAAA,aAAa,EAAC,QAAQ,OAAO;gBAC/B,YAAY,IAAI,KAAK,OAAO,EAAE,KAAK,UAAU,EAAE,MAAM,IAAI;YAC3D;QACF;IACF;AACF;AAEA,SAAS,iBAAiB,EAAgB,EAAE,KAAiB;IAC3D,IAAI,GAAG,SAAS,CAAC,IAAI,IAAI,CAAC,GAAG,IAAI,CAAC,WAAW,EAAE;IAC/C,kBAAkB,IAAI;IACtB,IAAI,CAAC,GAAG,IAAI,CAAC,eAAe,EAAE,mBAAmB,IAAI;IACrD,kBAAkB,IAAI,GAAG,SAAS;AACpC;AAEA,SAAS,kBAAkB,EAAgB,EAAE,KAAiB;IAC5D,IAAI,CAAC,MAAM,MAAM,EAAE;IACnB,IAAI,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE;QACxB,GAAG,SAAS,GAAG;QACf;IACF;IACA,MAAM,OAAO,CAAC,CAAC;QACb,IAAI,CAAC,aAAa,GAAG,SAAS,EAAE,IAAI;YAClC,iBAAiB,IAAI,CAAA,MAAA,EAAS,EAAC,0BAAA,EAA6B,GAAG,SAAS,CAAC,IAAI,CAAC,KAAI,CAAA,CAAG;QACvF;IACF;IACA,kBAAkB,IAAI;AACxB;AAEA,SAAS,mBAAmB,EAAgB,EAAE,EAAc;IAC1D,IAAI,GAAG,MAAM,GAAG,KAAK,CAAC,CAAC,GAAG,MAAM,KAAK,KAAK,GAAG,QAAQ,CAAC,OAAO,GAAG;QAC9D,iBAAiB,IAAI;IACvB;AACF;AAEA,SAAS,kBAAkB,EAAgB,EAAE,EAAc;IACzD,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG;IAC/B,IAAK,MAAM,WAAW,MAAO;QAC3B,MAAM,OAAO,KAAK,CAAC,QAAQ;QAC3B,IAAI,OAAO,QAAQ,YAAY,CAAA,GAAA,gBAAA,aAAa,EAAC,GAAG,MAAM,EAAE,OAAO;YAC7D,MAAM,EAAC,IAAI,EAAC,GAAG,KAAK,UAAU;YAC9B,IAAI,KAAK,MAAM,IAAI,CAAC,KAAK,IAAI,CAAC,CAAC,IAAM,kBAAkB,IAAI,KAAK;gBAC9D,iBAAiB,IAAI,CAAA,cAAA,EAAiB,KAAK,IAAI,CAAC,KAAI,eAAA,EAAkB,QAAO,CAAA,CAAG;YAClF;QACF;IACF;AACF;AAEA,SAAS,kBAAkB,KAAiB,EAAE,IAAc;IAC1D,OAAO,MAAM,QAAQ,CAAC,SAAU,SAAS,YAAY,MAAM,QAAQ,CAAC;AACtE;AAEA,SAAS,aAAa,EAAc,EAAE,CAAW;IAC/C,OAAO,GAAG,QAAQ,CAAC,MAAO,MAAM,aAAa,GAAG,QAAQ,CAAC;AAC3D;AAEA,SAAS,kBAAkB,EAAgB,EAAE,SAAqB;IAChE,MAAM,KAAiB,EAAE;IACzB,KAAK,MAAM,KAAK,GAAG,SAAS,CAAE;QAC5B,IAAI,aAAa,WAAW,IAAI,GAAG,IAAI,CAAC;aACnC,IAAI,UAAU,QAAQ,CAAC,cAAc,MAAM,UAAU,GAAG,IAAI,CAAC;IACpE;IACA,GAAG,SAAS,GAAG;AACjB;AAEA,SAAS,iBAAiB,EAAgB,EAAE,GAAW;IACrD,MAAM,aAAa,GAAG,SAAS,CAAC,MAAM,GAAG,GAAG,aAAa;IACzD,OAAO,CAAA,KAAA,EAAQ,WAAU,eAAA,CAAiB;IAC1C,CAAA,GAAA,OAAA,eAAe,EAAC,IAAI,KAAK,GAAG,IAAI,CAAC,WAAW;AAC9C;AAEA,MAAa;IAiBX,YAAY,EAAgB,EAAE,GAA2B,EAAE,OAAe,CAAA;QACxE,CAAA,GAAA,UAAA,oBAAoB,EAAC,IAAI,KAAK;QAC9B,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG;QACjB,IAAI,CAAC,SAAS,GAAG,GAAG,SAAS;QAC7B,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,IAAI,GAAG,GAAG,IAAI;QACnB,IAAI,CAAC,MAAM,GAAG,GAAG,MAAM,CAAC,QAAQ;QAChC,IAAI,CAAC,KAAK,GAAG,IAAI,KAAK,IAAI,GAAG,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK;QAC3E,IAAI,CAAC,WAAW,GAAG,CAAA,GAAA,OAAA,cAAc,EAAC,IAAI,IAAI,CAAC,MAAM,EAAE,SAAS,IAAI,CAAC,KAAK;QACtE,IAAI,CAAC,UAAU,GAAG,IAAI,UAAU;QAChC,IAAI,CAAC,YAAY,GAAG,GAAG,MAAM;QAC7B,IAAI,CAAC,MAAM,GAAG,CAAA;QACd,IAAI,CAAC,EAAE,GAAG;QACV,IAAI,CAAC,GAAG,GAAG;QAEX,IAAI,IAAI,CAAC,KAAK,EAAE;YACd,IAAI,CAAC,UAAU,GAAG,GAAG,GAAG,CAAC,KAAK,CAAC,WAAW,QAAQ,IAAI,CAAC,KAAK,EAAE;QAChE,OAAO;YACL,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,WAAW;YAClC,IAAI,CAAC,CAAA,GAAA,UAAA,eAAe,EAAC,IAAI,CAAC,MAAM,EAAE,IAAI,UAAU,EAAE,IAAI,cAAc,GAAG;gBACrE,MAAM,IAAI,MAAM,CAAA,EAAG,QAAO,eAAA,EAAkB,KAAK,SAAS,CAAC,IAAI,UAAU,EAAC,CAAE;YAC9E;QACF;QAEA,IAAI,UAAU,MAAM,IAAI,WAAW,GAAG,IAAI,MAAM,KAAK,OAAO;YAC1D,IAAI,CAAC,SAAS,GAAG,GAAG,GAAG,CAAC,KAAK,CAAC,SAAS,QAAA,OAAC,CAAC,MAAM;QACjD;IACF;IAEA,OAAO,SAAe,EAAE,aAA0B,EAAE,UAAuB,EAAA;QACzE,IAAI,CAAC,UAAU,CAAC,CAAA,GAAA,UAAA,GAAG,EAAC,YAAY,eAAe;IACjD;IAEA,WAAW,SAAe,EAAE,aAA0B,EAAE,UAAuB,EAAA;QAC7E,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC;QACZ,IAAI,YAAY;aACX,IAAI,CAAC,KAAK;QACf,IAAI,eAAe;YACjB,IAAI,CAAC,GAAG,CAAC,IAAI;YACb;YACA,IAAI,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK;QACpC,OAAO;YACL,IAAI,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK;iBAC7B,IAAI,CAAC,GAAG,CAAC,IAAI;QACpB;IACF;IAEA,KAAK,SAAe,EAAE,UAAuB,EAAA;QAC3C,IAAI,CAAC,UAAU,CAAC,CAAA,GAAA,UAAA,GAAG,EAAC,YAAY,WAAW;IAC7C;IAEA,KAAK,SAAgB,EAAA;QACnB,IAAI,cAAc,WAAW;YAC3B,IAAI,CAAC,KAAK;YACV,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,QAAO,8CAA8C;YACtF;QACF;QACA,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC;QACZ,IAAI,CAAC,KAAK;QACV,IAAI,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK;aAC7B,IAAI,CAAC,GAAG,CAAC,IAAI;IACpB;IAEA,UAAU,SAAe,EAAA;QACvB,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,OAAO,IAAI,CAAC,IAAI,CAAC;QAClC,MAAM,EAAC,UAAU,EAAC,GAAG,IAAI;QACzB,IAAI,CAAC,IAAI,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,WAAU,mBAAA,EAAsB,CAAA,GAAA,UAAA,EAAE,EAAC,IAAI,CAAC,YAAY,IAAI,WAAU,CAAA,CAAG;IACrF;IAEA,MAAM,MAAgB,EAAE,WAA8B,EAAE,UAAuB,EAAA;QAC7E,IAAI,aAAa;YACf,IAAI,CAAC,SAAS,CAAC;YACf,IAAI,CAAC,MAAM,CAAC,QAAQ;YACpB,IAAI,CAAC,SAAS,CAAC,CAAA;YACf;QACF;QACA,IAAI,CAAC,MAAM,CAAC,QAAQ;IACtB;IAEQ,OAAO,MAAgB,EAAE,UAAuB,EAAA;;QACrD,CAAC,SAAS,SAAA,gBAAgB,GAAG,SAAA,WAAW,EAAE,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE;IACnE;IAEA,aAAU;QACR,CAAA,GAAA,SAAA,WAAW,EAAC,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,UAAU,IAAI,SAAA,iBAAiB;IAC5D;IAEA,QAAK;QACH,IAAI,IAAI,CAAC,SAAS,KAAK,WAAW,MAAM,IAAI,MAAM;QAClD,CAAA,GAAA,SAAA,gBAAgB,EAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,SAAS;IAC3C;IAEA,GAAG,IAAoB,EAAA;QACrB,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC;IACnC;IAEA,UAAU,GAAqB,EAAE,MAAa,EAAA;QAC5C,IAAI,QAAQ,OAAO,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE;aAClC,IAAI,CAAC,MAAM,GAAG;IACrB;IAEA,WAAW,KAAW,EAAE,SAAqB,EAAE,aAAmB,UAAA,GAAG,EAAA;QACnE,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC;YACb,IAAI,CAAC,UAAU,CAAC,OAAO;YACvB;QACF;IACF;IAEA,WAAW,QAAc,UAAA,GAAG,EAAE,aAAmB,UAAA,GAAG,EAAA;QAClD,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE;QACjB,MAAM,EAAC,GAAG,EAAE,UAAU,EAAE,UAAU,EAAE,GAAG,EAAC,GAAG,IAAI;QAC/C,IAAI,EAAE,CAAC,CAAA,GAAA,UAAA,EAAE,EAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,WAAU,cAAA,CAAgB,EAAE;QAC1C,IAAI,UAAU,UAAA,GAAG,EAAE,IAAI,MAAM,CAAC,OAAO;QACrC,IAAI,WAAW,MAAM,IAAI,IAAI,cAAc,EAAE;YAC3C,IAAI,MAAM,CAAC,IAAI,CAAC,YAAY;YAC5B,IAAI,CAAC,UAAU;YACf,IAAI,UAAU,UAAA,GAAG,EAAE,IAAI,MAAM,CAAC,OAAO;QACvC;QACA,IAAI,IAAI;IACV;IAEA,eAAY;QACV,MAAM,EAAC,GAAG,EAAE,UAAU,EAAE,UAAU,EAAE,GAAG,EAAE,EAAE,EAAC,GAAG,IAAI;QACnD,OAAO,CAAA,GAAA,UAAA,EAAE,EAAC,kBAAkB;QAE5B,SAAS;YACP,IAAI,WAAW,MAAM,EAAE;gBACrB,sBAAA,GACA,IAAI,CAAC,CAAC,sBAAsB,UAAA,IAAI,GAAG,MAAM,IAAI,MAAM;gBACnD,MAAM,KAAK,MAAM,OAAO,CAAC,cAAc,aAAa;oBAAC;iBAAW;gBAChE,OAAO,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,CAAA,GAAA,WAAA,cAAc,EAAC,IAAI,YAAY,GAAG,IAAI,CAAC,aAAa,EAAE,WAAA,QAAQ,CAAC,KAAK,EAAC,CAAE;YACpF;YACA,OAAO,UAAA,GAAG;QACZ;QAEA,SAAS;YACP,IAAI,IAAI,cAAc,EAAE;gBACtB,MAAM,oBAAoB,IAAI,UAAU,CAAC,iBAAiB;oBAAC,KAAK,IAAI,cAAc;gBAAA,IAAG,iCAAiC;gBACtH,OAAO,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,CAAA,EAAI,kBAAiB,CAAA,EAAI,WAAU,CAAA,CAAG;YAChD;YACA,OAAO,UAAA,GAAG;QACZ;IACF;IAEA,UAAU,IAAmB,EAAE,KAAW,EAAA;QACxC,MAAM,YAAY,CAAA,GAAA,YAAA,YAAY,EAAC,IAAI,CAAC,EAAE,EAAE;QACxC,CAAA,GAAA,YAAA,mBAAmB,EAAC,WAAW,IAAI,CAAC,EAAE,EAAE;QACxC,CAAA,GAAA,YAAA,mBAAmB,EAAC,WAAW;QAC/B,MAAM,cAAc;YAAC,GAAG,IAAI,CAAC,EAAE;YAAE,GAAG,SAAS;YAAE,OAAO;YAAW,OAAO;QAAS;QACjF,cAAc,aAAa;QAC3B,OAAO;IACT;IAEA,eAAe,SAAoB,EAAE,MAAoB,EAAA;QACvD,MAAM,EAAC,EAAE,EAAE,GAAG,EAAC,GAAG,IAAI;QACtB,IAAI,CAAC,GAAG,IAAI,CAAC,WAAW,EAAE;QAC1B,IAAI,GAAG,KAAK,KAAK,QAAQ,UAAU,KAAK,KAAK,WAAW;YACtD,GAAG,KAAK,GAAG,OAAA,cAAc,CAAC,KAAK,CAAC,KAAK,UAAU,KAAK,EAAE,GAAG,KAAK,EAAE;QAClE;QACA,IAAI,GAAG,KAAK,KAAK,QAAQ,UAAU,KAAK,KAAK,WAAW;YACtD,GAAG,KAAK,GAAG,OAAA,cAAc,CAAC,KAAK,CAAC,KAAK,UAAU,KAAK,EAAE,GAAG,KAAK,EAAE;QAClE;IACF;IAEA,oBAAoB,SAAoB,EAAE,KAAW,EAAA;QACnD,MAAM,EAAC,EAAE,EAAE,GAAG,EAAC,GAAG,IAAI;QACtB,IAAI,GAAG,IAAI,CAAC,WAAW,IAAI,CAAC,GAAG,KAAK,KAAK,QAAQ,GAAG,KAAK,KAAK,IAAI,GAAG;YACnE,IAAI,EAAE,CAAC,OAAO,IAAM,IAAI,CAAC,cAAc,CAAC,WAAW,UAAA,IAAI;YACvD,OAAO;QACT;IACF;;AA3LF,QAAA,UAAA,GAAA;AA8LA,SAAS,YACP,EAAgB,EAChB,OAAe,EACf,GAA2B,EAC3B,QAAmB;IAEnB,MAAM,MAAM,IAAI,WAAW,IAAI,KAAK;IACpC,IAAI,UAAU,KAAK;QACjB,IAAI,IAAI,CAAC,KAAK;IAChB,OAAO,IAAI,IAAI,KAAK,IAAI,IAAI,QAAQ,EAAE;QACpC,CAAA,GAAA,UAAA,eAAe,EAAC,KAAK;IACvB,OAAO,IAAI,WAAW,KAAK;QACzB,CAAA,GAAA,UAAA,gBAAgB,EAAC,KAAK;IACxB,OAAO,IAAI,IAAI,OAAO,IAAI,IAAI,QAAQ,EAAE;QACtC,CAAA,GAAA,UAAA,eAAe,EAAC,KAAK;IACvB;AACF;AAEA,MAAM,eAAe;AACrB,MAAM,wBAAwB;AAC9B,SAAgB,QACd,KAAa,EACb,EAAC,SAAS,EAAE,SAAS,EAAE,WAAW,EAAY;IAE9C,IAAI;IACJ,IAAI;IACJ,IAAI,UAAU,IAAI,OAAO,QAAA,OAAC,CAAC,QAAQ;IACnC,IAAI,KAAK,CAAC,EAAE,KAAK,KAAK;QACpB,IAAI,CAAC,aAAa,IAAI,CAAC,QAAQ,MAAM,IAAI,MAAM,CAAA,sBAAA,EAAyB,MAAK,CAAE;QAC/E,cAAc;QACd,OAAO,QAAA,OAAC,CAAC,QAAQ;IACnB,OAAO;QACL,MAAM,UAAU,sBAAsB,IAAI,CAAC;QAC3C,IAAI,CAAC,SAAS,MAAM,IAAI,MAAM,CAAA,sBAAA,EAAyB,MAAK,CAAE;QAC9D,MAAM,KAAa,CAAC,OAAO,CAAC,EAAE;QAC9B,cAAc,OAAO,CAAC,EAAE;QACxB,IAAI,gBAAgB,KAAK;YACvB,IAAI,MAAM,WAAW,MAAM,IAAI,MAAM,SAAS,kBAAkB;YAChE,OAAO,WAAW,CAAC,YAAY,GAAG;QACpC;QACA,IAAI,KAAK,WAAW,MAAM,IAAI,MAAM,SAAS,QAAQ;QACrD,OAAO,SAAS,CAAC,YAAY,GAAG;QAChC,IAAI,CAAC,aAAa,OAAO;IAC3B;IAEA,IAAI,OAAO;IACX,MAAM,WAAW,YAAY,KAAK,CAAC;IACnC,KAAK,MAAM,WAAW,SAAU;QAC9B,IAAI,SAAS;YACX,OAAO,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,KAAI,EAAG,CAAA,GAAA,UAAA,WAAW,EAAC,CAAA,GAAA,OAAA,mBAAmB,EAAC,UAAS,CAAE;YAC7D,OAAO,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,KAAI,IAAA,EAAO,KAAI,CAAE;QAC9B;IACF;IACA,OAAO;IAEP,SAAS,SAAS,WAAmB,EAAE,EAAU;QAC/C,OAAO,CAAA,cAAA,EAAiB,YAAW,CAAA,EAAI,GAAE,6BAAA,EAAgC,UAAS,CAAE;IACtF;AACF;AAtCA,QAAA,OAAA,GAAA"}},
    {"offset": {"line": 2704, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2708, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/runtime/validation_error.ts"],"sourcesContent":["import type {ErrorObject} from \"../types\"\n\nexport default class ValidationError extends Error {\n  readonly errors: Partial<ErrorObject>[]\n  readonly ajv: true\n  readonly validation: true\n\n  constructor(errors: Partial<ErrorObject>[]) {\n    super(\"validation failed\")\n    this.errors = errors\n    this.ajv = this.validation = true\n  }\n}\n"],"names":[],"mappings":";;;;AAEA,MAAqB,wBAAwB;IAK3C,YAAY,MAA8B,CAAA;QACxC,KAAK,CAAC;QACN,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,UAAU,GAAG;IAC/B;;AATF,QAAA,OAAA,GAAA"}},
    {"offset": {"line": 2720, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2724, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/compile/ref_error.ts"],"sourcesContent":["import {resolveUrl, normalizeId, getFullPath} from \"./resolve\"\nimport type {UriResolver} from \"../types\"\n\nexport default class MissingRefError extends Error {\n  readonly missingRef: string\n  readonly missingSchema: string\n\n  constructor(resolver: UriResolver, baseId: string, ref: string, msg?: string) {\n    super(msg || `can't resolve reference ${ref} from id ${baseId}`)\n    this.missingRef = resolveUrl(resolver, baseId, ref)\n    this.missingSchema = normalizeId(getFullPath(resolver, this.missingRef))\n  }\n}\n"],"names":[],"mappings":";;;;AAAA,MAAA;AAGA,MAAqB,wBAAwB;IAI3C,YAAY,QAAqB,EAAE,MAAc,EAAE,GAAW,EAAE,GAAY,CAAA;QAC1E,KAAK,CAAC,OAAO,CAAA,wBAAA,EAA2B,IAAG,SAAA,EAAY,OAAM,CAAE;QAC/D,IAAI,CAAC,UAAU,GAAG,CAAA,GAAA,UAAA,UAAU,EAAC,UAAU,QAAQ;QAC/C,IAAI,CAAC,aAAa,GAAG,CAAA,GAAA,UAAA,WAAW,EAAC,CAAA,GAAA,UAAA,WAAW,EAAC,UAAU,IAAI,CAAC,UAAU;IACxE;;AARF,QAAA,OAAA,GAAA"}},
    {"offset": {"line": 2737, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2741, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/compile/index.ts"],"sourcesContent":["import type {\n  AnySchema,\n  AnySchemaObject,\n  AnyValidateFunction,\n  AsyncValidateFunction,\n  EvaluatedProperties,\n  EvaluatedItems,\n} from \"../types\"\nimport type Ajv from \"../core\"\nimport type {InstanceOptions} from \"../core\"\nimport {CodeGen, _, nil, stringify, Name, Code, ValueScopeName} from \"./codegen\"\nimport ValidationError from \"../runtime/validation_error\"\nimport N from \"./names\"\nimport {LocalRefs, getFullPath, _getFullPath, inlineRef, normalizeId, resolveUrl} from \"./resolve\"\nimport {schemaHasRulesButRef, unescapeFragment} from \"./util\"\nimport {validateFunctionCode} from \"./validate\"\nimport {URIComponent} from \"fast-uri\"\nimport {JSONType} from \"./rules\"\n\nexport type SchemaRefs = {\n  [Ref in string]?: SchemaEnv | AnySchema\n}\n\nexport interface SchemaCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean // validation mode - whether to collect all errors or break on error\n  readonly data: Name // Name with reference to the current part of data instance\n  readonly parentData: Name // should be used in keywords modifying data\n  readonly parentDataProperty: Code | number // should be used in keywords modifying data\n  readonly dataNames: Name[]\n  readonly dataPathArr: (Code | number)[]\n  readonly dataLevel: number // the level of the currently validated data,\n  // it can be used to access both the property names and the data on all levels from the top.\n  dataTypes: JSONType[] // data types applied to the current part of data instance\n  definedProperties: Set<string> // set of properties to keep track of for required checks\n  readonly topSchemaRef: Code\n  readonly validateName: Name\n  evaluated?: Name\n  readonly ValidationError?: Name\n  readonly schema: AnySchema // current schema object - equal to parentSchema passed via KeywordCxt\n  readonly schemaEnv: SchemaEnv\n  readonly rootId: string\n  baseId: string // the current schema base URI that should be used as the base for resolving URIs in references (\\$ref)\n  readonly schemaPath: Code // the run-time expression that evaluates to the property name of the current schema\n  readonly errSchemaPath: string // this is actual string, should not be changed to Code\n  readonly errorPath: Code\n  readonly propertyName?: Name\n  readonly compositeRule?: boolean // true indicates that the current schema is inside the compound keyword,\n  // where failing some rule doesn't mean validation failure (`anyOf`, `oneOf`, `not`, `if`).\n  // This flag is used to determine whether you can return validation result immediately after any error in case the option `allErrors` is not `true.\n  // You only need to use it if you have many steps in your keywords and potentially can define multiple errors.\n  props?: EvaluatedProperties | Name // properties evaluated by this schema - used by parent schema or assigned to validation function\n  items?: EvaluatedItems | Name // last item evaluated by this schema - used by parent schema or assigned to validation function\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  readonly createErrors?: boolean\n  readonly opts: InstanceOptions // Ajv instance option.\n  readonly self: Ajv // current Ajv instance\n}\n\nexport interface SchemaObjCxt extends SchemaCxt {\n  readonly schema: AnySchemaObject\n}\ninterface SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root?: SchemaEnv\n  readonly baseId?: string\n  readonly schemaPath?: string\n  readonly localRefs?: LocalRefs\n  readonly meta?: boolean\n}\n\nexport class SchemaEnv implements SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root: SchemaEnv\n  baseId: string // TODO possibly, it should be readonly\n  schemaPath?: string\n  localRefs?: LocalRefs\n  readonly meta?: boolean\n  readonly $async?: boolean // true if the current schema is asynchronous.\n  readonly refs: SchemaRefs = {}\n  readonly dynamicAnchors: {[Ref in string]?: true} = {}\n  validate?: AnyValidateFunction\n  validateName?: ValueScopeName\n  serialize?: (data: unknown) => string\n  serializeName?: ValueScopeName\n  parse?: (data: string) => unknown\n  parseName?: ValueScopeName\n\n  constructor(env: SchemaEnvArgs) {\n    let schema: AnySchemaObject | undefined\n    if (typeof env.schema == \"object\") schema = env.schema\n    this.schema = env.schema\n    this.schemaId = env.schemaId\n    this.root = env.root || this\n    this.baseId = env.baseId ?? normalizeId(schema?.[env.schemaId || \"$id\"])\n    this.schemaPath = env.schemaPath\n    this.localRefs = env.localRefs\n    this.meta = env.meta\n    this.$async = schema?.$async\n    this.refs = {}\n  }\n}\n\n// let codeSize = 0\n// let nodeCount = 0\n\n// Compiles schema in SchemaEnv\nexport function compileSchema(this: Ajv, sch: SchemaEnv): SchemaEnv {\n  // TODO refactor - remove compilations\n  const _sch = getCompilingSchema.call(this, sch)\n  if (_sch) return _sch\n  const rootId = getFullPath(this.opts.uriResolver, sch.root.baseId) // TODO if getFullPath removed 1 tests fails\n  const {es5, lines} = this.opts.code\n  const {ownProperties} = this.opts\n  const gen = new CodeGen(this.scope, {es5, lines, ownProperties})\n  let _ValidationError\n  if (sch.$async) {\n    _ValidationError = gen.scopeValue(\"Error\", {\n      ref: ValidationError,\n      code: _`require(\"ajv/dist/runtime/validation_error\").default`,\n    })\n  }\n\n  const validateName = gen.scopeName(\"validate\")\n  sch.validateName = validateName\n\n  const schemaCxt: SchemaCxt = {\n    gen,\n    allErrors: this.opts.allErrors,\n    data: N.data,\n    parentData: N.parentData,\n    parentDataProperty: N.parentDataProperty,\n    dataNames: [N.data],\n    dataPathArr: [nil], // TODO can its length be used as dataLevel if nil is removed?\n    dataLevel: 0,\n    dataTypes: [],\n    definedProperties: new Set<string>(),\n    topSchemaRef: gen.scopeValue(\n      \"schema\",\n      this.opts.code.source === true\n        ? {ref: sch.schema, code: stringify(sch.schema)}\n        : {ref: sch.schema}\n    ),\n    validateName,\n    ValidationError: _ValidationError,\n    schema: sch.schema,\n    schemaEnv: sch,\n    rootId,\n    baseId: sch.baseId || rootId,\n    schemaPath: nil,\n    errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n    errorPath: _`\"\"`,\n    opts: this.opts,\n    self: this,\n  }\n\n  let sourceCode: string | undefined\n  try {\n    this._compilations.add(sch)\n    validateFunctionCode(schemaCxt)\n    gen.optimize(this.opts.code.optimize)\n    // gen.optimize(1)\n    const validateCode = gen.toString()\n    sourceCode = `${gen.scopeRefs(N.scope)}return ${validateCode}`\n    // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n    if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n    const makeValidate = new Function(`${N.self}`, `${N.scope}`, sourceCode)\n    const validate: AnyValidateFunction = makeValidate(this, this.scope.get())\n    this.scope.value(validateName, {ref: validate})\n\n    validate.errors = null\n    validate.schema = sch.schema\n    validate.schemaEnv = sch\n    if (sch.$async) (validate as AsyncValidateFunction).$async = true\n    if (this.opts.code.source === true) {\n      validate.source = {validateName, validateCode, scopeValues: gen._values}\n    }\n    if (this.opts.unevaluated) {\n      const {props, items} = schemaCxt\n      validate.evaluated = {\n        props: props instanceof Name ? undefined : props,\n        items: items instanceof Name ? undefined : items,\n        dynamicProps: props instanceof Name,\n        dynamicItems: items instanceof Name,\n      }\n      if (validate.source) validate.source.evaluated = stringify(validate.evaluated)\n    }\n    sch.validate = validate\n    return sch\n  } catch (e) {\n    delete sch.validate\n    delete sch.validateName\n    if (sourceCode) this.logger.error(\"Error compiling schema, function code:\", sourceCode)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n    throw e\n  } finally {\n    this._compilations.delete(sch)\n  }\n}\n\nexport function resolveRef(\n  this: Ajv,\n  root: SchemaEnv,\n  baseId: string,\n  ref: string\n): AnySchema | SchemaEnv | undefined {\n  ref = resolveUrl(this.opts.uriResolver, baseId, ref)\n  const schOrFunc = root.refs[ref]\n  if (schOrFunc) return schOrFunc\n\n  let _sch = resolve.call(this, root, ref)\n  if (_sch === undefined) {\n    const schema = root.localRefs?.[ref] // TODO maybe localRefs should hold SchemaEnv\n    const {schemaId} = this.opts\n    if (schema) _sch = new SchemaEnv({schema, schemaId, root, baseId})\n  }\n\n  if (_sch === undefined) return\n  return (root.refs[ref] = inlineOrCompile.call(this, _sch))\n}\n\nfunction inlineOrCompile(this: Ajv, sch: SchemaEnv): AnySchema | SchemaEnv {\n  if (inlineRef(sch.schema, this.opts.inlineRefs)) return sch.schema\n  return sch.validate ? sch : compileSchema.call(this, sch)\n}\n\n// Index of schema compilation in the currently compiled list\nexport function getCompilingSchema(this: Ajv, schEnv: SchemaEnv): SchemaEnv | void {\n  for (const sch of this._compilations) {\n    if (sameSchemaEnv(sch, schEnv)) return sch\n  }\n}\n\nfunction sameSchemaEnv(s1: SchemaEnv, s2: SchemaEnv): boolean {\n  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId\n}\n\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(\n  this: Ajv,\n  root: SchemaEnv, // information about the root schema for the current schema\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  let sch\n  while (typeof (sch = this.refs[ref]) == \"string\") ref = sch\n  return sch || this.schemas[ref] || resolveSchema.call(this, root, ref)\n}\n\n// Resolve schema, its root and baseId\nexport function resolveSchema(\n  this: Ajv,\n  root: SchemaEnv, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  const p = this.opts.uriResolver.parse(ref)\n  const refPath = _getFullPath(this.opts.uriResolver, p)\n  let baseId = getFullPath(this.opts.uriResolver, root.baseId, undefined)\n  // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n  if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n    return getJsonPointer.call(this, p, root)\n  }\n\n  const id = normalizeId(refPath)\n  const schOrRef = this.refs[id] || this.schemas[id]\n  if (typeof schOrRef == \"string\") {\n    const sch = resolveSchema.call(this, root, schOrRef)\n    if (typeof sch?.schema !== \"object\") return\n    return getJsonPointer.call(this, p, sch)\n  }\n\n  if (typeof schOrRef?.schema !== \"object\") return\n  if (!schOrRef.validate) compileSchema.call(this, schOrRef)\n  if (id === normalizeId(ref)) {\n    const {schema} = schOrRef\n    const {schemaId} = this.opts\n    const schId = schema[schemaId]\n    if (schId) baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\n    return new SchemaEnv({schema, schemaId, root, baseId})\n  }\n  return getJsonPointer.call(this, p, schOrRef)\n}\n\nconst PREVENT_SCOPE_CHANGE = new Set([\n  \"properties\",\n  \"patternProperties\",\n  \"enum\",\n  \"dependencies\",\n  \"definitions\",\n])\n\nfunction getJsonPointer(\n  this: Ajv,\n  parsedRef: URIComponent,\n  {baseId, schema, root}: SchemaEnv\n): SchemaEnv | undefined {\n  if (parsedRef.fragment?.[0] !== \"/\") return\n  for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n    if (typeof schema === \"boolean\") return\n    const partSchema = schema[unescapeFragment(part)]\n    if (partSchema === undefined) return\n    schema = partSchema\n    // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n    const schId = typeof schema === \"object\" && schema[this.opts.schemaId]\n    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n      baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\n    }\n  }\n  let env: SchemaEnv | undefined\n  if (typeof schema != \"boolean\" && schema.$ref && !schemaHasRulesButRef(schema, this.RULES)) {\n    const $ref = resolveUrl(this.opts.uriResolver, baseId, schema.$ref)\n    env = resolveSchema.call(this, root, $ref)\n  }\n  // even though resolution failed we need to return SchemaEnv to throw exception\n  // so that compileAsync loads missing schema.\n  const {schemaId} = this.opts\n  env = env || new SchemaEnv({schema, schemaId, root, baseId})\n  if (env.schema !== env.root.schema) return env\n  return undefined\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2992, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3000, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/runtime/uri.ts"],"sourcesContent":["import * as uri from \"fast-uri\"\n\ntype URI = typeof uri & {code: string}\n;(uri as URI).code = 'require(\"ajv/dist/runtime/uri\").default'\n\nexport default uri as URI\n"],"names":[],"mappings":";;;;AAAA,MAAA;AAGE,IAAY,IAAI,GAAG;AAErB,QAAA,OAAA,GAAe"}},
    {"offset": {"line": 3007, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3011, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/core.ts"],"sourcesContent":["export {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  AnyValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n} from \"./types\"\n\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport interface Plugin<Opts> {\n  (ajv: Ajv, options?: Opts): Ajv\n  [prop: string]: any\n}\n\nexport {KeywordCxt} from \"./compile/validate\"\nexport {DefinedError} from \"./vocabularies/errors\"\nexport {JSONType} from \"./compile/rules\"\nexport {JSONSchemaType} from \"./types/json-schema\"\nexport {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\n\nimport type {\n  Schema,\n  AnySchema,\n  AnySchemaObject,\n  SchemaObject,\n  AsyncSchema,\n  Vocabulary,\n  KeywordDefinition,\n  AddedKeywordDefinition,\n  AnyValidateFunction,\n  ValidateFunction,\n  AsyncValidateFunction,\n  ErrorObject,\n  Format,\n  AddedFormat,\n  RegExpEngine,\n  UriResolver,\n} from \"./types\"\nimport type {JSONSchemaType} from \"./types/json-schema\"\nimport type {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nimport ValidationError from \"./runtime/validation_error\"\nimport MissingRefError from \"./compile/ref_error\"\nimport {getRules, ValidationRules, Rule, RuleGroup, JSONType} from \"./compile/rules\"\nimport {SchemaEnv, compileSchema, resolveSchema} from \"./compile\"\nimport {Code, ValueScope} from \"./compile/codegen\"\nimport {normalizeId, getSchemaRefs} from \"./compile/resolve\"\nimport {getJSONTypes} from \"./compile/validate/dataType\"\nimport {eachItem} from \"./compile/util\"\nimport * as $dataRefSchema from \"./refs/data.json\"\n\nimport DefaultUriResolver from \"./runtime/uri\"\n\nconst defaultRegExp: RegExpEngine = (str, flags) => new RegExp(str, flags)\ndefaultRegExp.code = \"new RegExp\"\n\nconst META_IGNORE_OPTIONS: (keyof Options)[] = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"]\nconst EXT_SCOPE_NAMES = new Set([\n  \"validate\",\n  \"serialize\",\n  \"parse\",\n  \"wrapper\",\n  \"root\",\n  \"schema\",\n  \"keyword\",\n  \"pattern\",\n  \"formats\",\n  \"validate$data\",\n  \"func\",\n  \"obj\",\n  \"Error\",\n])\n\nexport type Options = CurrentOptions & DeprecatedOptions\n\nexport interface CurrentOptions {\n  // strict mode options (NEW)\n  strict?: boolean | \"log\"\n  strictSchema?: boolean | \"log\"\n  strictNumbers?: boolean | \"log\"\n  strictTypes?: boolean | \"log\"\n  strictTuples?: boolean | \"log\"\n  strictRequired?: boolean | \"log\"\n  allowMatchingProperties?: boolean // disables a strict mode restriction\n  allowUnionTypes?: boolean\n  validateFormats?: boolean\n  // validation and reporting options:\n  $data?: boolean\n  allErrors?: boolean\n  verbose?: boolean\n  discriminator?: boolean\n  unicodeRegExp?: boolean\n  timestamp?: \"string\" | \"date\" // JTD only\n  parseDate?: boolean // JTD only\n  allowDate?: boolean // JTD only\n  $comment?:\n    | true\n    | ((comment: string, schemaPath?: string, rootSchema?: AnySchemaObject) => unknown)\n  formats?: {[Name in string]?: Format}\n  keywords?: Vocabulary\n  schemas?: AnySchema[] | {[Key in string]?: AnySchema}\n  logger?: Logger | false\n  loadSchema?: (uri: string) => Promise<AnySchemaObject>\n  // options to modify validated data:\n  removeAdditional?: boolean | \"all\" | \"failing\"\n  useDefaults?: boolean | \"empty\"\n  coerceTypes?: boolean | \"array\"\n  // advanced options:\n  next?: boolean // NEW\n  unevaluated?: boolean // NEW\n  dynamicRef?: boolean // NEW\n  schemaId?: \"id\" | \"$id\"\n  jtd?: boolean // NEW\n  meta?: SchemaObject | boolean\n  defaultMeta?: string | AnySchemaObject\n  validateSchema?: boolean | \"log\"\n  addUsedSchema?: boolean\n  inlineRefs?: boolean | number\n  passContext?: boolean\n  loopRequired?: number\n  loopEnum?: number // NEW\n  ownProperties?: boolean\n  multipleOfPrecision?: number\n  int32range?: boolean // JTD only\n  messages?: boolean\n  code?: CodeOptions // NEW\n  uriResolver?: UriResolver\n}\n\nexport interface CodeOptions {\n  es5?: boolean\n  esm?: boolean\n  lines?: boolean\n  optimize?: boolean | number\n  formats?: Code // code to require (or construct) map of available formats - for standalone code\n  source?: boolean\n  process?: (code: string, schema?: SchemaEnv) => string\n  regExp?: RegExpEngine\n}\n\ninterface InstanceCodeOptions extends CodeOptions {\n  regExp: RegExpEngine\n  optimize: number\n}\n\ninterface DeprecatedOptions {\n  /** @deprecated */\n  ignoreKeywordsWithRef?: boolean\n  /** @deprecated */\n  jsPropertySyntax?: boolean // added instead of jsonPointers\n  /** @deprecated */\n  unicode?: boolean\n}\n\ninterface RemovedOptions {\n  format?: boolean\n  errorDataPath?: \"object\" | \"property\"\n  nullable?: boolean // \"nullable\" keyword is supported by default\n  jsonPointers?: boolean\n  extendRefs?: true | \"ignore\" | \"fail\"\n  missingRefs?: true | \"ignore\" | \"fail\"\n  processCode?: (code: string, schema?: SchemaEnv) => string\n  sourceCode?: boolean\n  strictDefaults?: boolean\n  strictKeywords?: boolean\n  uniqueItems?: boolean\n  unknownFormats?: true | string[] | \"ignore\"\n  cache?: any\n  serialize?: (schema: AnySchema) => unknown\n  ajvErrors?: boolean\n}\n\ntype OptionsInfo<T extends RemovedOptions | DeprecatedOptions> = {\n  [K in keyof T]-?: string | undefined\n}\n\nconst removedOptions: OptionsInfo<RemovedOptions> = {\n  errorDataPath: \"\",\n  format: \"`validateFormats: false` can be used instead.\",\n  nullable: '\"nullable\" keyword is supported by default.',\n  jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n  extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n  missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n  processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n  sourceCode: \"Use option `code: {source: true}`\",\n  strictDefaults: \"It is default now, see option `strict`.\",\n  strictKeywords: \"It is default now, see option `strict`.\",\n  uniqueItems: '\"uniqueItems\" keyword is always validated.',\n  unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n  cache: \"Map is used as cache, schema object as key.\",\n  serialize: \"Map is used as cache, schema object as key.\",\n  ajvErrors: \"It is default now.\",\n}\n\nconst deprecatedOptions: OptionsInfo<DeprecatedOptions> = {\n  ignoreKeywordsWithRef: \"\",\n  jsPropertySyntax: \"\",\n  unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.',\n}\n\ntype RequiredInstanceOptions = {\n  [K in\n    | \"strictSchema\"\n    | \"strictNumbers\"\n    | \"strictTypes\"\n    | \"strictTuples\"\n    | \"strictRequired\"\n    | \"inlineRefs\"\n    | \"loopRequired\"\n    | \"loopEnum\"\n    | \"meta\"\n    | \"messages\"\n    | \"schemaId\"\n    | \"addUsedSchema\"\n    | \"validateSchema\"\n    | \"validateFormats\"\n    | \"int32range\"\n    | \"unicodeRegExp\"\n    | \"uriResolver\"]: NonNullable<Options[K]>\n} & {code: InstanceCodeOptions}\n\nexport type InstanceOptions = Options & RequiredInstanceOptions\n\nconst MAX_EXPRESSION = 200\n\n// eslint-disable-next-line complexity\nfunction requiredOptions(o: Options): RequiredInstanceOptions {\n  const s = o.strict\n  const _optz = o.code?.optimize\n  const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0\n  const regExp = o.code?.regExp ?? defaultRegExp\n  const uriResolver = o.uriResolver ?? DefaultUriResolver\n  return {\n    strictSchema: o.strictSchema ?? s ?? true,\n    strictNumbers: o.strictNumbers ?? s ?? true,\n    strictTypes: o.strictTypes ?? s ?? \"log\",\n    strictTuples: o.strictTuples ?? s ?? \"log\",\n    strictRequired: o.strictRequired ?? s ?? false,\n    code: o.code ? {...o.code, optimize, regExp} : {optimize, regExp},\n    loopRequired: o.loopRequired ?? MAX_EXPRESSION,\n    loopEnum: o.loopEnum ?? MAX_EXPRESSION,\n    meta: o.meta ?? true,\n    messages: o.messages ?? true,\n    inlineRefs: o.inlineRefs ?? true,\n    schemaId: o.schemaId ?? \"$id\",\n    addUsedSchema: o.addUsedSchema ?? true,\n    validateSchema: o.validateSchema ?? true,\n    validateFormats: o.validateFormats ?? true,\n    unicodeRegExp: o.unicodeRegExp ?? true,\n    int32range: o.int32range ?? true,\n    uriResolver: uriResolver,\n  }\n}\n\nexport interface Logger {\n  log(...args: unknown[]): unknown\n  warn(...args: unknown[]): unknown\n  error(...args: unknown[]): unknown\n}\n\nexport default class Ajv {\n  opts: InstanceOptions\n  errors?: ErrorObject[] | null // errors from the last validation\n  logger: Logger\n  // shared external scope values for compiled functions\n  readonly scope: ValueScope\n  readonly schemas: {[Key in string]?: SchemaEnv} = {}\n  readonly refs: {[Ref in string]?: SchemaEnv | string} = {}\n  readonly formats: {[Name in string]?: AddedFormat} = {}\n  readonly RULES: ValidationRules\n  readonly _compilations: Set<SchemaEnv> = new Set()\n  private readonly _loading: {[Ref in string]?: Promise<AnySchemaObject>} = {}\n  private readonly _cache: Map<AnySchema, SchemaEnv> = new Map()\n  private readonly _metaOpts: InstanceOptions\n\n  static ValidationError = ValidationError\n  static MissingRefError = MissingRefError\n\n  constructor(opts: Options = {}) {\n    opts = this.opts = {...opts, ...requiredOptions(opts)}\n    const {es5, lines} = this.opts.code\n\n    this.scope = new ValueScope({scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines})\n    this.logger = getLogger(opts.logger)\n    const formatOpt = opts.validateFormats\n    opts.validateFormats = false\n\n    this.RULES = getRules()\n    checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\")\n    checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\")\n    this._metaOpts = getMetaSchemaOptions.call(this)\n\n    if (opts.formats) addInitialFormats.call(this)\n    this._addVocabularies()\n    this._addDefaultMetaSchema()\n    if (opts.keywords) addInitialKeywords.call(this, opts.keywords)\n    if (typeof opts.meta == \"object\") this.addMetaSchema(opts.meta)\n    addInitialSchemas.call(this)\n    opts.validateFormats = formatOpt\n  }\n\n  _addVocabularies(): void {\n    this.addKeyword(\"$async\")\n  }\n\n  _addDefaultMetaSchema(): void {\n    const {$data, meta, schemaId} = this.opts\n    let _dataRefSchema: SchemaObject = $dataRefSchema\n    if (schemaId === \"id\") {\n      _dataRefSchema = {...$dataRefSchema}\n      _dataRefSchema.id = _dataRefSchema.$id\n      delete _dataRefSchema.$id\n    }\n    if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false)\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    const {meta, schemaId} = this.opts\n    return (this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined)\n  }\n\n  // Validate data using schema\n  // AnySchema will be compiled and cached using schema itself as a key for Map\n  validate(schema: Schema | string, data: unknown): boolean\n  validate(schemaKeyRef: AnySchema | string, data: unknown): boolean | Promise<unknown>\n  validate<T>(schema: Schema | JSONSchemaType<T> | string, data: unknown): data is T\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  validate<T>(schema: JTDSchemaType<T>, data: unknown): data is T\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  validate<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    data: unknown\n  ): data is JTDDataType<T>\n  // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n  validate<T>(schema: AsyncSchema, data: unknown | T): Promise<T>\n  validate<T>(schemaKeyRef: AnySchema | string, data: unknown): data is T | Promise<T>\n  validate<T>(\n    schemaKeyRef: AnySchema | string, // key, ref or schema object\n    // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n    data: unknown | T // to be validated\n  ): boolean | Promise<T> {\n    let v: AnyValidateFunction | undefined\n    if (typeof schemaKeyRef == \"string\") {\n      v = this.getSchema<T>(schemaKeyRef)\n      if (!v) throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`)\n    } else {\n      v = this.compile<T>(schemaKeyRef)\n    }\n\n    const valid = v(data)\n    if (!(\"$async\" in v)) this.errors = v.errors\n    return valid\n  }\n\n  // Create validation function for passed schema\n  // _meta: true if schema is a meta-schema. Used internally to compile meta schemas of user-defined keywords.\n  compile<T = unknown>(schema: Schema | JSONSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compile<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  compile<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    _meta?: boolean\n  ): ValidateFunction<JTDDataType<T>>\n  compile<T = unknown>(schema: AsyncSchema, _meta?: boolean): AsyncValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T> {\n    const sch = this._addSchema(schema, _meta)\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T>\n  }\n\n  // Creates validating function for passed schema with asynchronous loading of missing schemas.\n  // `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.\n  // TODO allow passing schema URI\n  // meta - optional true to compile meta-schema\n  compileAsync<T = unknown>(\n    schema: SchemaObject | JSONSchemaType<T>,\n    _meta?: boolean\n  ): Promise<ValidateFunction<T>>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): Promise<ValidateFunction<T>>\n  compileAsync<T = unknown>(schema: AsyncSchema, meta?: boolean): Promise<AsyncValidateFunction<T>>\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>>\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>> {\n    if (typeof this.opts.loadSchema != \"function\") {\n      throw new Error(\"options.loadSchema should be a function\")\n    }\n    const {loadSchema} = this.opts\n    return runCompileAsync.call(this, schema, meta)\n\n    async function runCompileAsync(\n      this: Ajv,\n      _schema: AnySchemaObject,\n      _meta?: boolean\n    ): Promise<AnyValidateFunction> {\n      await loadMetaSchema.call(this, _schema.$schema)\n      const sch = this._addSchema(_schema, _meta)\n      return sch.validate || _compileAsync.call(this, sch)\n    }\n\n    async function loadMetaSchema(this: Ajv, $ref?: string): Promise<void> {\n      if ($ref && !this.getSchema($ref)) {\n        await runCompileAsync.call(this, {$ref}, true)\n      }\n    }\n\n    async function _compileAsync(this: Ajv, sch: SchemaEnv): Promise<AnyValidateFunction> {\n      try {\n        return this._compileSchemaEnv(sch)\n      } catch (e) {\n        if (!(e instanceof MissingRefError)) throw e\n        checkLoaded.call(this, e)\n        await loadMissingSchema.call(this, e.missingSchema)\n        return _compileAsync.call(this, sch)\n      }\n    }\n\n    function checkLoaded(this: Ajv, {missingSchema: ref, missingRef}: MissingRefError): void {\n      if (this.refs[ref]) {\n        throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`)\n      }\n    }\n\n    async function loadMissingSchema(this: Ajv, ref: string): Promise<void> {\n      const _schema = await _loadSchema.call(this, ref)\n      if (!this.refs[ref]) await loadMetaSchema.call(this, _schema.$schema)\n      if (!this.refs[ref]) this.addSchema(_schema, ref, meta)\n    }\n\n    async function _loadSchema(this: Ajv, ref: string): Promise<AnySchemaObject> {\n      const p = this._loading[ref]\n      if (p) return p\n      try {\n        return await (this._loading[ref] = loadSchema(ref))\n      } finally {\n        delete this._loading[ref]\n      }\n    }\n  }\n\n  // Adds schema to the instance\n  addSchema(\n    schema: AnySchema | AnySchema[], // If array is passed, `key` will be ignored\n    key?: string, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta?: boolean, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n  ): Ajv {\n    if (Array.isArray(schema)) {\n      for (const sch of schema) this.addSchema(sch, undefined, _meta, _validateSchema)\n      return this\n    }\n    let id: string | undefined\n    if (typeof schema === \"object\") {\n      const {schemaId} = this.opts\n      id = schema[schemaId]\n      if (id !== undefined && typeof id != \"string\") {\n        throw new Error(`schema ${schemaId} must be string`)\n      }\n    }\n    key = normalizeId(key || id)\n    this._checkUnique(key)\n    this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true)\n    return this\n  }\n\n  // Add schema that will be used to validate other schemas\n  // options in META_IGNORE_OPTIONS are alway set to false\n  addMetaSchema(\n    schema: AnySchemaObject,\n    key?: string, // schema key\n    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n  ): Ajv {\n    this.addSchema(schema, key, true, _validateSchema)\n    return this\n  }\n\n  //  Validate schema against its meta-schema\n  validateSchema(schema: AnySchema, throwOrLogError?: boolean): boolean | Promise<unknown> {\n    if (typeof schema == \"boolean\") return true\n    let $schema: string | AnySchemaObject | undefined\n    $schema = schema.$schema\n    if ($schema !== undefined && typeof $schema != \"string\") {\n      throw new Error(\"$schema must be a string\")\n    }\n    $schema = $schema || this.opts.defaultMeta || this.defaultMeta()\n    if (!$schema) {\n      this.logger.warn(\"meta-schema not available\")\n      this.errors = null\n      return true\n    }\n    const valid = this.validate($schema, schema)\n    if (!valid && throwOrLogError) {\n      const message = \"schema is invalid: \" + this.errorsText()\n      if (this.opts.validateSchema === \"log\") this.logger.error(message)\n      else throw new Error(message)\n    }\n    return valid\n  }\n\n  // Get compiled schema by `key` or `ref`.\n  // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n  getSchema<T = unknown>(keyRef: string): AnyValidateFunction<T> | undefined {\n    let sch\n    while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\") keyRef = sch\n    if (sch === undefined) {\n      const {schemaId} = this.opts\n      const root = new SchemaEnv({schema: {}, schemaId})\n      sch = resolveSchema.call(this, root, keyRef)\n      if (!sch) return\n      this.refs[keyRef] = sch\n    }\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T> | undefined\n  }\n\n  // Remove cached schema(s).\n  // If no parameter is passed all schemas but meta-schemas are removed.\n  // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n  // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n  removeSchema(schemaKeyRef?: AnySchema | string | RegExp): Ajv {\n    if (schemaKeyRef instanceof RegExp) {\n      this._removeAllSchemas(this.schemas, schemaKeyRef)\n      this._removeAllSchemas(this.refs, schemaKeyRef)\n      return this\n    }\n    switch (typeof schemaKeyRef) {\n      case \"undefined\":\n        this._removeAllSchemas(this.schemas)\n        this._removeAllSchemas(this.refs)\n        this._cache.clear()\n        return this\n      case \"string\": {\n        const sch = getSchEnv.call(this, schemaKeyRef)\n        if (typeof sch == \"object\") this._cache.delete(sch.schema)\n        delete this.schemas[schemaKeyRef]\n        delete this.refs[schemaKeyRef]\n        return this\n      }\n      case \"object\": {\n        const cacheKey = schemaKeyRef\n        this._cache.delete(cacheKey)\n        let id = schemaKeyRef[this.opts.schemaId]\n        if (id) {\n          id = normalizeId(id)\n          delete this.schemas[id]\n          delete this.refs[id]\n        }\n        return this\n      }\n      default:\n        throw new Error(\"ajv.removeSchema: invalid parameter\")\n    }\n  }\n\n  // add \"vocabulary\" - a collection of keywords\n  addVocabulary(definitions: Vocabulary): Ajv {\n    for (const def of definitions) this.addKeyword(def)\n    return this\n  }\n\n  addKeyword(\n    kwdOrDef: string | KeywordDefinition,\n    def?: KeywordDefinition // deprecated\n  ): Ajv {\n    let keyword: string | string[]\n    if (typeof kwdOrDef == \"string\") {\n      keyword = kwdOrDef\n      if (typeof def == \"object\") {\n        this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\")\n        def.keyword = keyword\n      }\n    } else if (typeof kwdOrDef == \"object\" && def === undefined) {\n      def = kwdOrDef\n      keyword = def.keyword\n      if (Array.isArray(keyword) && !keyword.length) {\n        throw new Error(\"addKeywords: keyword must be string or non-empty array\")\n      }\n    } else {\n      throw new Error(\"invalid addKeywords parameters\")\n    }\n\n    checkKeyword.call(this, keyword, def)\n    if (!def) {\n      eachItem(keyword, (kwd) => addRule.call(this, kwd))\n      return this\n    }\n    keywordMetaschema.call(this, def)\n    const definition: AddedKeywordDefinition = {\n      ...def,\n      type: getJSONTypes(def.type),\n      schemaType: getJSONTypes(def.schemaType),\n    }\n    eachItem(\n      keyword,\n      definition.type.length === 0\n        ? (k) => addRule.call(this, k, definition)\n        : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t))\n    )\n    return this\n  }\n\n  getKeyword(keyword: string): AddedKeywordDefinition | boolean {\n    const rule = this.RULES.all[keyword]\n    return typeof rule == \"object\" ? rule.definition : !!rule\n  }\n\n  // Remove keyword\n  removeKeyword(keyword: string): Ajv {\n    // TODO return type should be Ajv\n    const {RULES} = this\n    delete RULES.keywords[keyword]\n    delete RULES.all[keyword]\n    for (const group of RULES.rules) {\n      const i = group.rules.findIndex((rule) => rule.keyword === keyword)\n      if (i >= 0) group.rules.splice(i, 1)\n    }\n    return this\n  }\n\n  // Add format\n  addFormat(name: string, format: Format): Ajv {\n    if (typeof format == \"string\") format = new RegExp(format)\n    this.formats[name] = format\n    return this\n  }\n\n  errorsText(\n    errors: ErrorObject[] | null | undefined = this.errors, // optional array of validation errors\n    {separator = \", \", dataVar = \"data\"}: ErrorsTextOptions = {} // optional options with properties `separator` and `dataVar`\n  ): string {\n    if (!errors || errors.length === 0) return \"No errors\"\n    return errors\n      .map((e) => `${dataVar}${e.instancePath} ${e.message}`)\n      .reduce((text, msg) => text + separator + msg)\n  }\n\n  $dataMetaSchema(metaSchema: AnySchemaObject, keywordsJsonPointers: string[]): AnySchemaObject {\n    const rules = this.RULES.all\n    metaSchema = JSON.parse(JSON.stringify(metaSchema))\n    for (const jsonPointer of keywordsJsonPointers) {\n      const segments = jsonPointer.split(\"/\").slice(1) // first segment is an empty string\n      let keywords = metaSchema\n      for (const seg of segments) keywords = keywords[seg] as AnySchemaObject\n\n      for (const key in rules) {\n        const rule = rules[key]\n        if (typeof rule != \"object\") continue\n        const {$data} = rule.definition\n        const schema = keywords[key] as AnySchemaObject | undefined\n        if ($data && schema) keywords[key] = schemaOrData(schema)\n      }\n    }\n\n    return metaSchema\n  }\n\n  private _removeAllSchemas(schemas: {[Ref in string]?: SchemaEnv | string}, regex?: RegExp): void {\n    for (const keyRef in schemas) {\n      const sch = schemas[keyRef]\n      if (!regex || regex.test(keyRef)) {\n        if (typeof sch == \"string\") {\n          delete schemas[keyRef]\n        } else if (sch && !sch.meta) {\n          this._cache.delete(sch.schema)\n          delete schemas[keyRef]\n        }\n      }\n    }\n  }\n\n  _addSchema(\n    schema: AnySchema,\n    meta?: boolean,\n    baseId?: string,\n    validateSchema = this.opts.validateSchema,\n    addSchema = this.opts.addUsedSchema\n  ): SchemaEnv {\n    let id: string | undefined\n    const {schemaId} = this.opts\n    if (typeof schema == \"object\") {\n      id = schema[schemaId]\n    } else {\n      if (this.opts.jtd) throw new Error(\"schema must be object\")\n      else if (typeof schema != \"boolean\") throw new Error(\"schema must be object or boolean\")\n    }\n    let sch = this._cache.get(schema)\n    if (sch !== undefined) return sch\n\n    baseId = normalizeId(id || baseId)\n    const localRefs = getSchemaRefs.call(this, schema, baseId)\n    sch = new SchemaEnv({schema, schemaId, meta, baseId, localRefs})\n    this._cache.set(sch.schema, sch)\n    if (addSchema && !baseId.startsWith(\"#\")) {\n      // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n      if (baseId) this._checkUnique(baseId)\n      this.refs[baseId] = sch\n    }\n    if (validateSchema) this.validateSchema(schema, true)\n    return sch\n  }\n\n  private _checkUnique(id: string): void {\n    if (this.schemas[id] || this.refs[id]) {\n      throw new Error(`schema with key or id \"${id}\" already exists`)\n    }\n  }\n\n  private _compileSchemaEnv(sch: SchemaEnv): AnyValidateFunction {\n    if (sch.meta) this._compileMetaSchema(sch)\n    else compileSchema.call(this, sch)\n\n    /* istanbul ignore if */\n    if (!sch.validate) throw new Error(\"ajv implementation error\")\n    return sch.validate\n  }\n\n  private _compileMetaSchema(sch: SchemaEnv): void {\n    const currentOpts = this.opts\n    this.opts = this._metaOpts\n    try {\n      compileSchema.call(this, sch)\n    } finally {\n      this.opts = currentOpts\n    }\n  }\n}\n\nexport interface ErrorsTextOptions {\n  separator?: string\n  dataVar?: string\n}\n\nfunction checkOptions(\n  this: Ajv,\n  checkOpts: OptionsInfo<RemovedOptions | DeprecatedOptions>,\n  options: Options & RemovedOptions,\n  msg: string,\n  log: \"warn\" | \"error\" = \"error\"\n): void {\n  for (const key in checkOpts) {\n    const opt = key as keyof typeof checkOpts\n    if (opt in options) this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`)\n  }\n}\n\nfunction getSchEnv(this: Ajv, keyRef: string): SchemaEnv | string | undefined {\n  keyRef = normalizeId(keyRef) // TODO tests fail without this line\n  return this.schemas[keyRef] || this.refs[keyRef]\n}\n\nfunction addInitialSchemas(this: Ajv): void {\n  const optsSchemas = this.opts.schemas\n  if (!optsSchemas) return\n  if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas)\n  else for (const key in optsSchemas) this.addSchema(optsSchemas[key] as AnySchema, key)\n}\n\nfunction addInitialFormats(this: Ajv): void {\n  for (const name in this.opts.formats) {\n    const format = this.opts.formats[name]\n    if (format) this.addFormat(name, format)\n  }\n}\n\nfunction addInitialKeywords(\n  this: Ajv,\n  defs: Vocabulary | {[K in string]?: KeywordDefinition}\n): void {\n  if (Array.isArray(defs)) {\n    this.addVocabulary(defs)\n    return\n  }\n  this.logger.warn(\"keywords option as map is deprecated, pass array\")\n  for (const keyword in defs) {\n    const def = defs[keyword] as KeywordDefinition\n    if (!def.keyword) def.keyword = keyword\n    this.addKeyword(def)\n  }\n}\n\nfunction getMetaSchemaOptions(this: Ajv): InstanceOptions {\n  const metaOpts = {...this.opts}\n  for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt]\n  return metaOpts\n}\n\nconst noLogs = {log() {}, warn() {}, error() {}}\n\nfunction getLogger(logger?: Partial<Logger> | false): Logger {\n  if (logger === false) return noLogs\n  if (logger === undefined) return console\n  if (logger.log && logger.warn && logger.error) return logger as Logger\n  throw new Error(\"logger must implement log, warn and error methods\")\n}\n\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i\n\nfunction checkKeyword(this: Ajv, keyword: string | string[], def?: KeywordDefinition): void {\n  const {RULES} = this\n  eachItem(keyword, (kwd) => {\n    if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`)\n    if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`)\n  })\n  if (!def) return\n  if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n    throw new Error('$data keyword must have \"code\" or \"validate\" function')\n  }\n}\n\nfunction addRule(\n  this: Ajv,\n  keyword: string,\n  definition?: AddedKeywordDefinition,\n  dataType?: JSONType\n): void {\n  const post = definition?.post\n  if (dataType && post) throw new Error('keyword with \"post\" flag cannot have \"type\"')\n  const {RULES} = this\n  let ruleGroup = post ? RULES.post : RULES.rules.find(({type: t}) => t === dataType)\n  if (!ruleGroup) {\n    ruleGroup = {type: dataType, rules: []}\n    RULES.rules.push(ruleGroup)\n  }\n  RULES.keywords[keyword] = true\n  if (!definition) return\n\n  const rule: Rule = {\n    keyword,\n    definition: {\n      ...definition,\n      type: getJSONTypes(definition.type),\n      schemaType: getJSONTypes(definition.schemaType),\n    },\n  }\n  if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before)\n  else ruleGroup.rules.push(rule)\n  RULES.all[keyword] = rule\n  definition.implements?.forEach((kwd) => this.addKeyword(kwd))\n}\n\nfunction addBeforeRule(this: Ajv, ruleGroup: RuleGroup, rule: Rule, before: string): void {\n  const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before)\n  if (i >= 0) {\n    ruleGroup.rules.splice(i, 0, rule)\n  } else {\n    ruleGroup.rules.push(rule)\n    this.logger.warn(`rule ${before} is not defined`)\n  }\n}\n\nfunction keywordMetaschema(this: Ajv, def: KeywordDefinition): void {\n  let {metaSchema} = def\n  if (metaSchema === undefined) return\n  if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema)\n  def.validateSchema = this.compile(metaSchema, true)\n}\n\nconst $dataRef = {\n  $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n}\n\nfunction schemaOrData(schema: AnySchema): AnySchemaObject {\n  return {anyOf: [schema, $dataRef]}\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3641, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3645, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/core/id.ts"],"sourcesContent":["import type {CodeKeywordDefinition} from \"../../types\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"id\",\n  code() {\n    throw new Error('NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID')\n  },\n}\n\nexport default def\n"],"names":[],"mappings":";;;;AAEA,MAAM,MAA6B;IACjC,SAAS;IACT;QACE,MAAM,IAAI,MAAM;IAClB;;AAGF,QAAA,OAAA,GAAe"}},
    {"offset": {"line": 3656, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3660, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/core/ref.ts"],"sourcesContent":["import type {CodeKeywordDefinition, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport MissingRefError from \"../../compile/ref_error\"\nimport {callValidateCode} from \"../code\"\nimport {_, nil, stringify, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport {SchemaEnv, resolveRef} from \"../../compile\"\nimport {mergeEvaluated} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"$ref\",\n  schemaType: \"string\",\n  code(cxt: KeywordCxt): void {\n    const {gen, schema: $ref, it} = cxt\n    const {baseId, schemaEnv: env, validateName, opts, self} = it\n    const {root} = env\n    if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId) return callRootRef()\n    const schOrEnv = resolveRef.call(self, root, baseId, $ref)\n    if (schOrEnv === undefined) throw new MissingRefError(it.opts.uriResolver, baseId, $ref)\n    if (schOrEnv instanceof SchemaEnv) return callValidate(schOrEnv)\n    return inlineRefSchema(schOrEnv)\n\n    function callRootRef(): void {\n      if (env === root) return callRef(cxt, validateName, env, env.$async)\n      const rootName = gen.scopeValue(\"root\", {ref: root})\n      return callRef(cxt, _`${rootName}.validate`, root, root.$async)\n    }\n\n    function callValidate(sch: SchemaEnv): void {\n      const v = getValidate(cxt, sch)\n      callRef(cxt, v, sch, sch.$async)\n    }\n\n    function inlineRefSchema(sch: AnySchema): void {\n      const schName = gen.scopeValue(\n        \"schema\",\n        opts.code.source === true ? {ref: sch, code: stringify(sch)} : {ref: sch}\n      )\n      const valid = gen.name(\"valid\")\n      const schCxt = cxt.subschema(\n        {\n          schema: sch,\n          dataTypes: [],\n          schemaPath: nil,\n          topSchemaRef: schName,\n          errSchemaPath: $ref,\n        },\n        valid\n      )\n      cxt.mergeEvaluated(schCxt)\n      cxt.ok(valid)\n    }\n  },\n}\n\nexport function getValidate(cxt: KeywordCxt, sch: SchemaEnv): Code {\n  const {gen} = cxt\n  return sch.validate\n    ? gen.scopeValue(\"validate\", {ref: sch.validate})\n    : _`${gen.scopeValue(\"wrapper\", {ref: sch})}.validate`\n}\n\nexport function callRef(cxt: KeywordCxt, v: Code, sch?: SchemaEnv, $async?: boolean): void {\n  const {gen, it} = cxt\n  const {allErrors, schemaEnv: env, opts} = it\n  const passCxt = opts.passContext ? N.this : nil\n  if ($async) callAsyncRef()\n  else callSyncRef()\n\n  function callAsyncRef(): void {\n    if (!env.$async) throw new Error(\"async schema referenced by sync schema\")\n    const valid = gen.let(\"valid\")\n    gen.try(\n      () => {\n        gen.code(_`await ${callValidateCode(cxt, v, passCxt)}`)\n        addEvaluatedFrom(v) // TODO will not work with async, it has to be returned with the result\n        if (!allErrors) gen.assign(valid, true)\n      },\n      (e) => {\n        gen.if(_`!(${e} instanceof ${it.ValidationError as Name})`, () => gen.throw(e))\n        addErrorsFrom(e)\n        if (!allErrors) gen.assign(valid, false)\n      }\n    )\n    cxt.ok(valid)\n  }\n\n  function callSyncRef(): void {\n    cxt.result(\n      callValidateCode(cxt, v, passCxt),\n      () => addEvaluatedFrom(v),\n      () => addErrorsFrom(v)\n    )\n  }\n\n  function addErrorsFrom(source: Code): void {\n    const errs = _`${source}.errors`\n    gen.assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`) // TODO tagged\n    gen.assign(N.errors, _`${N.vErrors}.length`)\n  }\n\n  function addEvaluatedFrom(source: Code): void {\n    if (!it.opts.unevaluated) return\n    const schEvaluated = sch?.validate?.evaluated\n    // TODO refactor\n    if (it.props !== true) {\n      if (schEvaluated && !schEvaluated.dynamicProps) {\n        if (schEvaluated.props !== undefined) {\n          it.props = mergeEvaluated.props(gen, schEvaluated.props, it.props)\n        }\n      } else {\n        const props = gen.var(\"props\", _`${source}.evaluated.props`)\n        it.props = mergeEvaluated.props(gen, props, it.props, Name)\n      }\n    }\n    if (it.items !== true) {\n      if (schEvaluated && !schEvaluated.dynamicItems) {\n        if (schEvaluated.items !== undefined) {\n          it.items = mergeEvaluated.items(gen, schEvaluated.items, it.items)\n        }\n      } else {\n        const items = gen.var(\"items\", _`${source}.evaluated.items`)\n        it.items = mergeEvaluated.items(gen, items, it.items, Name)\n      }\n    }\n  }\n}\n\nexport default def\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3780, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3784, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/core/index.ts"],"sourcesContent":["import type {Vocabulary} from \"../../types\"\nimport idKeyword from \"./id\"\nimport refKeyword from \"./ref\"\n\nconst core: Vocabulary = [\n  \"$schema\",\n  \"$id\",\n  \"$defs\",\n  \"$vocabulary\",\n  {keyword: \"$comment\"},\n  \"definitions\",\n  idKeyword,\n  refKeyword,\n]\n\nexport default core\n"],"names":[],"mappings":";;;;AACA,MAAA;AACA,MAAA;AAEA,MAAM,OAAmB;IACvB;IACA;IACA;IACA;IACA;QAAC,SAAS;IAAU;IACpB;IACA,KAAA,OAAS;IACT,MAAA,OAAU;CACX;AAED,QAAA,OAAA,GAAe"}},
    {"offset": {"line": 3803, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3807, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/validation/limitNumber.ts"],"sourcesContent":["import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators, Code} from \"../../compile/codegen\"\n\nconst ops = operators\n\ntype Kwd = \"maximum\" | \"minimum\" | \"exclusiveMaximum\" | \"exclusiveMinimum\"\n\ntype Comparison = \"<=\" | \">=\" | \"<\" | \">\"\n\nconst KWDs: {[K in Kwd]: {okStr: Comparison; ok: Code; fail: Code}} = {\n  maximum: {okStr: \"<=\", ok: ops.LTE, fail: ops.GT},\n  minimum: {okStr: \">=\", ok: ops.GTE, fail: ops.LT},\n  exclusiveMaximum: {okStr: \"<\", ok: ops.LT, fail: ops.GTE},\n  exclusiveMinimum: {okStr: \">\", ok: ops.GT, fail: ops.LTE},\n}\n\nexport type LimitNumberError = ErrorObject<\n  Kwd,\n  {limit: number; comparison: Comparison},\n  number | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({keyword, schemaCode}) => str`must be ${KWDs[keyword as Kwd].okStr} ${schemaCode}`,\n  params: ({keyword, schemaCode}) =>\n    _`{comparison: ${KWDs[keyword as Kwd].okStr}, limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: Object.keys(KWDs),\n  type: \"number\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    cxt.fail$data(_`${data} ${KWDs[keyword as Kwd].fail} ${schemaCode} || isNaN(${data})`)\n  },\n}\n\nexport default def\n"],"names":[],"mappings":";;;;AAEA,MAAA;AAEA,MAAM,MAAM,UAAA,SAAS;AAMrB,MAAM,OAAgE;IACpE,SAAS;QAAC,OAAO;QAAM,IAAI,IAAI,GAAG;QAAE,MAAM,IAAI,EAAE;IAAA;IAChD,SAAS;QAAC,OAAO;QAAM,IAAI,IAAI,GAAG;QAAE,MAAM,IAAI,EAAE;IAAA;IAChD,kBAAkB;QAAC,OAAO;QAAK,IAAI,IAAI,EAAE;QAAE,MAAM,IAAI,GAAG;IAAA;IACxD,kBAAkB;QAAC,OAAO;QAAK,IAAI,IAAI,EAAE;QAAE,MAAM,IAAI,GAAG;IAAA;;AAS1D,MAAM,QAAgC;IACpC,SAAS,CAAC,EAAC,OAAO,EAAE,UAAU,EAAC,GAAK,CAAA,GAAA,UAAA,GAAG,CAAA,CAAA,QAAA,EAAW,IAAI,CAAC,QAAe,CAAC,KAAK,CAAA,CAAA,EAAI,WAAU,CAAE;IAC5F,QAAQ,CAAC,EAAC,OAAO,EAAE,UAAU,EAAC,GAC5B,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,aAAA,EAAgB,IAAI,CAAC,QAAe,CAAC,KAAK,CAAA,SAAA,EAAY,WAAU,CAAA,CAAG;;AAGxE,MAAM,MAA6B;IACjC,SAAS,OAAO,IAAI,CAAC;IACrB,MAAM;IACN,YAAY;IACZ,OAAO;IACP;IACA,MAAK,GAAe;QAClB,MAAM,EAAC,OAAO,EAAE,IAAI,EAAE,UAAU,EAAC,GAAG;QACpC,IAAI,SAAS,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,KAAI,CAAA,EAAI,IAAI,CAAC,QAAe,CAAC,IAAI,CAAA,CAAA,EAAI,WAAU,UAAA,EAAa,KAAI,CAAA,CAAG;IACvF;;AAGF,QAAA,OAAA,GAAe"}},
    {"offset": {"line": 3851, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3855, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/validation/multipleOf.ts"],"sourcesContent":["import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\n\nexport type MultipleOfError = ErrorObject<\n  \"multipleOf\",\n  {multipleOf: number},\n  number | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must be multiple of ${schemaCode}`,\n  params: ({schemaCode}) => _`{multipleOf: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"multipleOf\",\n  type: \"number\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, schemaCode, it} = cxt\n    // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)\n    const prec = it.opts.multipleOfPrecision\n    const res = gen.let(\"res\")\n    const invalid = prec\n      ? _`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`\n      : _`${res} !== parseInt(${res})`\n    cxt.fail$data(_`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`)\n  },\n}\n\nexport default def\n"],"names":[],"mappings":";;;;AAEA,MAAA;AAQA,MAAM,QAAgC;IACpC,SAAS,CAAC,EAAC,UAAU,EAAC,GAAK,CAAA,GAAA,UAAA,GAAG,CAAA,CAAA,oBAAA,EAAuB,WAAU,CAAE;IACjE,QAAQ,CAAC,EAAC,UAAU,EAAC,GAAK,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,aAAA,EAAgB,WAAU,CAAA,CAAG;;AAG1D,MAAM,MAA6B;IACjC,SAAS;IACT,MAAM;IACN,YAAY;IACZ,OAAO;IACP;IACA,MAAK,GAAe;QAClB,MAAM,EAAC,GAAG,EAAE,IAAI,EAAE,UAAU,EAAE,EAAE,EAAC,GAAG;QACpC,sEAAsE;QACtE,MAAM,OAAO,GAAG,IAAI,CAAC,mBAAmB;QACxC,MAAM,MAAM,IAAI,GAAG,CAAC;QACpB,MAAM,UAAU,OACZ,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,oBAAA,EAAuB,IAAG,IAAA,EAAO,IAAG,OAAA,EAAU,KAAI,CAAE,GACrD,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,IAAG,cAAA,EAAiB,IAAG,CAAA,CAAG;QAClC,IAAI,SAAS,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,CAAA,EAAI,WAAU,WAAA,EAAc,IAAG,GAAA,EAAM,KAAI,CAAA,EAAI,WAAU,EAAA,EAAK,QAAO,EAAA,CAAI;IACxF;;AAGF,QAAA,OAAA,GAAe"}},
    {"offset": {"line": 3880, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3884, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/runtime/ucs2length.ts"],"sourcesContent":["// https://mathiasbynens.be/notes/javascript-encoding\n// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\nexport default function ucs2length(str: string): number {\n  const len = str.length\n  let length = 0\n  let pos = 0\n  let value: number\n  while (pos < len) {\n    length++\n    value = str.charCodeAt(pos++)\n    if (value >= 0xd800 && value <= 0xdbff && pos < len) {\n      // high surrogate, and there is a next character\n      value = str.charCodeAt(pos)\n      if ((value & 0xfc00) === 0xdc00) pos++ // low surrogate\n    }\n  }\n  return length\n}\n\nucs2length.code = 'require(\"ajv/dist/runtime/ucs2length\").default'\n"],"names":[],"mappings":";;;;AAAA,qDAAqD;AACrD,iEAAiE;AACjE,SAAwB,WAAW,GAAW;IAC5C,MAAM,MAAM,IAAI,MAAM;IACtB,IAAI,SAAS;IACb,IAAI,MAAM;IACV,IAAI;IACJ,MAAO,MAAM,IAAK;QAChB;QACA,QAAQ,IAAI,UAAU,CAAC;QACvB,IAAI,SAAS,UAAU,SAAS,UAAU,MAAM,KAAK;YACnD,gDAAgD;YAChD,QAAQ,IAAI,UAAU,CAAC;YACvB,IAAI,CAAC,QAAQ,MAAM,MAAM,QAAQ,OAAM,gBAAgB;QACzD;IACF;IACA,OAAO;AACT;AAfA,QAAA,OAAA,GAAA;AAiBA,WAAW,IAAI,GAAG"}},
    {"offset": {"line": 3908, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3912, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/validation/limitLength.ts"],"sourcesContent":["import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport ucs2length from \"../../runtime/ucs2length\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxLength\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} characters`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxLength\", \"minLength\"],\n  type: \"string\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode, it} = cxt\n    const op = keyword === \"maxLength\" ? operators.GT : operators.LT\n    const len =\n      it.opts.unicode === false ? _`${data}.length` : _`${useFunc(cxt.gen, ucs2length)}(${data})`\n    cxt.fail$data(_`${len} ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n"],"names":[],"mappings":";;;;AAEA,MAAA;AACA,MAAA;AACA,MAAA;AAEA,MAAM,QAAgC;IACpC,SAAQ,EAAC,OAAO,EAAE,UAAU,EAAC;QAC3B,MAAM,OAAO,YAAY,cAAc,SAAS;QAChD,OAAO,CAAA,GAAA,UAAA,GAAG,CAAA,CAAA,cAAA,EAAiB,KAAI,MAAA,EAAS,WAAU,WAAA,CAAa;IACjE;IACA,QAAQ,CAAC,EAAC,UAAU,EAAC,GAAK,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,QAAA,EAAW,WAAU,CAAA,CAAG;;AAGrD,MAAM,MAA6B;IACjC,SAAS;QAAC;QAAa;KAAY;IACnC,MAAM;IACN,YAAY;IACZ,OAAO;IACP;IACA,MAAK,GAAe;QAClB,MAAM,EAAC,OAAO,EAAE,IAAI,EAAE,UAAU,EAAE,EAAE,EAAC,GAAG;QACxC,MAAM,KAAK,YAAY,cAAc,UAAA,SAAS,CAAC,EAAE,GAAG,UAAA,SAAS,CAAC,EAAE;QAChE,MAAM,MACJ,GAAG,IAAI,CAAC,OAAO,KAAK,QAAQ,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,KAAI,OAAA,CAAS,GAAG,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,CAAA,GAAA,OAAA,OAAO,EAAC,IAAI,GAAG,EAAE,aAAA,OAAU,EAAC,CAAA,EAAI,KAAI,CAAA,CAAG;QAC7F,IAAI,SAAS,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,IAAG,CAAA,EAAI,GAAE,CAAA,EAAI,WAAU,CAAE;IAC7C;;AAGF,QAAA,OAAA,GAAe"}},
    {"offset": {"line": 3943, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3947, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/validation/pattern.ts"],"sourcesContent":["import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {usePattern} from \"../code\"\nimport {_, str} from \"../../compile/codegen\"\n\nexport type PatternError = ErrorObject<\"pattern\", {pattern: string}, string | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must match pattern \"${schemaCode}\"`,\n  params: ({schemaCode}) => _`{pattern: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"pattern\",\n  type: \"string\",\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {data, $data, schema, schemaCode, it} = cxt\n    // TODO regexp should be wrapped in try/catchs\n    const u = it.opts.unicodeRegExp ? \"u\" : \"\"\n    const regExp = $data ? _`(new RegExp(${schemaCode}, ${u}))` : usePattern(cxt, schema)\n    cxt.fail$data(_`!${regExp}.test(${data})`)\n  },\n}\n\nexport default def\n"],"names":[],"mappings":";;;;AAEA,MAAA;AACA,MAAA;AAIA,MAAM,QAAgC;IACpC,SAAS,CAAC,EAAC,UAAU,EAAC,GAAK,CAAA,GAAA,UAAA,GAAG,CAAA,CAAA,oBAAA,EAAuB,WAAU,CAAA,CAAG;IAClE,QAAQ,CAAC,EAAC,UAAU,EAAC,GAAK,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,UAAA,EAAa,WAAU,CAAA,CAAG;;AAGvD,MAAM,MAA6B;IACjC,SAAS;IACT,MAAM;IACN,YAAY;IACZ,OAAO;IACP;IACA,MAAK,GAAe;QAClB,MAAM,EAAC,IAAI,EAAE,KAAK,EAAE,MAAM,EAAE,UAAU,EAAE,EAAE,EAAC,GAAG;QAC9C,8CAA8C;QAC9C,MAAM,IAAI,GAAG,IAAI,CAAC,aAAa,GAAG,MAAM;QACxC,MAAM,SAAS,QAAQ,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,YAAA,EAAe,WAAU,EAAA,EAAK,EAAC,EAAA,CAAI,GAAG,CAAA,GAAA,OAAA,UAAU,EAAC,KAAK;QAC9E,IAAI,SAAS,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,CAAA,EAAI,OAAM,MAAA,EAAS,KAAI,CAAA,CAAG;IAC3C;;AAGF,QAAA,OAAA,GAAe"}},
    {"offset": {"line": 3972, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3976, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/validation/limitProperties.ts"],"sourcesContent":["import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxProperties\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} properties`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxProperties\", \"minProperties\"],\n  type: \"object\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    const op = keyword === \"maxProperties\" ? operators.GT : operators.LT\n    cxt.fail$data(_`Object.keys(${data}).length ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n"],"names":[],"mappings":";;;;AAEA,MAAA;AAEA,MAAM,QAAgC;IACpC,SAAQ,EAAC,OAAO,EAAE,UAAU,EAAC;QAC3B,MAAM,OAAO,YAAY,kBAAkB,SAAS;QACpD,OAAO,CAAA,GAAA,UAAA,GAAG,CAAA,CAAA,cAAA,EAAiB,KAAI,MAAA,EAAS,WAAU,WAAA,CAAa;IACjE;IACA,QAAQ,CAAC,EAAC,UAAU,EAAC,GAAK,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,QAAA,EAAW,WAAU,CAAA,CAAG;;AAGrD,MAAM,MAA6B;IACjC,SAAS;QAAC;QAAiB;KAAgB;IAC3C,MAAM;IACN,YAAY;IACZ,OAAO;IACP;IACA,MAAK,GAAe;QAClB,MAAM,EAAC,OAAO,EAAE,IAAI,EAAE,UAAU,EAAC,GAAG;QACpC,MAAM,KAAK,YAAY,kBAAkB,UAAA,SAAS,CAAC,EAAE,GAAG,UAAA,SAAS,CAAC,EAAE;QACpE,IAAI,SAAS,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,YAAA,EAAe,KAAI,SAAA,EAAY,GAAE,CAAA,EAAI,WAAU,CAAE;IAClE;;AAGF,QAAA,OAAA,GAAe"}},
    {"offset": {"line": 4004, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4008, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/validation/required.ts"],"sourcesContent":["import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {\n  checkReportMissingProp,\n  checkMissingProp,\n  reportMissingProp,\n  propertyInData,\n  noPropertyInData,\n} from \"../code\"\nimport {_, str, nil, not, Name, Code} from \"../../compile/codegen\"\nimport {checkStrictMode} from \"../../compile/util\"\n\nexport type RequiredError = ErrorObject<\n  \"required\",\n  {missingProperty: string},\n  string[] | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {missingProperty}}) => str`must have required property '${missingProperty}'`,\n  params: ({params: {missingProperty}}) => _`{missingProperty: ${missingProperty}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"required\",\n  type: \"object\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, schemaCode, data, $data, it} = cxt\n    const {opts} = it\n    if (!$data && schema.length === 0) return\n    const useLoop = schema.length >= opts.loopRequired\n    if (it.allErrors) allErrorsMode()\n    else exitOnErrorMode()\n\n    if (opts.strictRequired) {\n      const props = cxt.parentSchema.properties\n      const {definedProperties} = cxt.it\n      for (const requiredKey of schema) {\n        if (props?.[requiredKey] === undefined && !definedProperties.has(requiredKey)) {\n          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n          const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`\n          checkStrictMode(it, msg, it.opts.strictRequired)\n        }\n      }\n    }\n\n    function allErrorsMode(): void {\n      if (useLoop || $data) {\n        cxt.block$data(nil, loopAllRequired)\n      } else {\n        for (const prop of schema) {\n          checkReportMissingProp(cxt, prop)\n        }\n      }\n    }\n\n    function exitOnErrorMode(): void {\n      const missing = gen.let(\"missing\")\n      if (useLoop || $data) {\n        const valid = gen.let(\"valid\", true)\n        cxt.block$data(valid, () => loopUntilMissing(missing, valid))\n        cxt.ok(valid)\n      } else {\n        gen.if(checkMissingProp(cxt, schema, missing))\n        reportMissingProp(cxt, missing)\n        gen.else()\n      }\n    }\n\n    function loopAllRequired(): void {\n      gen.forOf(\"prop\", schemaCode as Code, (prop) => {\n        cxt.setParams({missingProperty: prop})\n        gen.if(noPropertyInData(gen, data, prop, opts.ownProperties), () => cxt.error())\n      })\n    }\n\n    function loopUntilMissing(missing: Name, valid: Name): void {\n      cxt.setParams({missingProperty: missing})\n      gen.forOf(\n        missing,\n        schemaCode as Code,\n        () => {\n          gen.assign(valid, propertyInData(gen, data, missing, opts.ownProperties))\n          gen.if(not(valid), () => {\n            cxt.error()\n            gen.break()\n          })\n        },\n        nil\n      )\n    }\n  },\n}\n\nexport default def\n"],"names":[],"mappings":";;;;AAEA,MAAA;AAOA,MAAA;AACA,MAAA;AAQA,MAAM,QAAgC;IACpC,SAAS,CAAC,EAAC,QAAQ,EAAC,eAAe,EAAC,EAAC,GAAK,CAAA,GAAA,UAAA,GAAG,CAAA,CAAA,6BAAA,EAAgC,gBAAe,CAAA,CAAG;IAC/F,QAAQ,CAAC,EAAC,QAAQ,EAAC,eAAe,EAAC,EAAC,GAAK,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,kBAAA,EAAqB,gBAAe,CAAA,CAAG;;AAGnF,MAAM,MAA6B;IACjC,SAAS;IACT,MAAM;IACN,YAAY;IACZ,OAAO;IACP;IACA,MAAK,GAAe;QAClB,MAAM,EAAC,GAAG,EAAE,MAAM,EAAE,UAAU,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,EAAC,GAAG;QACnD,MAAM,EAAC,IAAI,EAAC,GAAG;QACf,IAAI,CAAC,SAAS,OAAO,MAAM,KAAK,GAAG;QACnC,MAAM,UAAU,OAAO,MAAM,IAAI,KAAK,YAAY;QAClD,IAAI,GAAG,SAAS,EAAE;aACb;QAEL,IAAI,KAAK,cAAc,EAAE;YACvB,MAAM,QAAQ,IAAI,YAAY,CAAC,UAAU;YACzC,MAAM,EAAC,iBAAiB,EAAC,GAAG,IAAI,EAAE;YAClC,KAAK,MAAM,eAAe,OAAQ;gBAChC,IAAI,CAAA,UAAK,QAAL,UAAK,KAAA,IAAA,KAAA,IAAL,KAAK,CAAG,YAAY,MAAK,aAAa,CAAC,kBAAkB,GAAG,CAAC,cAAc;oBAC7E,MAAM,aAAa,GAAG,SAAS,CAAC,MAAM,GAAG,GAAG,aAAa;oBACzD,MAAM,MAAM,CAAA,mBAAA,EAAsB,YAAW,qBAAA,EAAwB,WAAU,kBAAA,CAAoB;oBACnG,CAAA,GAAA,OAAA,eAAe,EAAC,IAAI,KAAK,GAAG,IAAI,CAAC,cAAc;gBACjD;YACF;QACF;QAEA,SAAS;YACP,IAAI,WAAW,OAAO;gBACpB,IAAI,UAAU,CAAC,UAAA,GAAG,EAAE;YACtB,OAAO;gBACL,KAAK,MAAM,QAAQ,OAAQ;oBACzB,CAAA,GAAA,OAAA,sBAAsB,EAAC,KAAK;gBAC9B;YACF;QACF;QAEA,SAAS;YACP,MAAM,UAAU,IAAI,GAAG,CAAC;YACxB,IAAI,WAAW,OAAO;gBACpB,MAAM,QAAQ,IAAI,GAAG,CAAC,SAAS;gBAC/B,IAAI,UAAU,CAAC,OAAO,IAAM,iBAAiB,SAAS;gBACtD,IAAI,EAAE,CAAC;YACT,OAAO;gBACL,IAAI,EAAE,CAAC,CAAA,GAAA,OAAA,gBAAgB,EAAC,KAAK,QAAQ;gBACrC,CAAA,GAAA,OAAA,iBAAiB,EAAC,KAAK;gBACvB,IAAI,IAAI;YACV;QACF;QAEA,SAAS;YACP,IAAI,KAAK,CAAC,QAAQ,YAAoB,CAAC;gBACrC,IAAI,SAAS,CAAC;oBAAC,iBAAiB;gBAAI;gBACpC,IAAI,EAAE,CAAC,CAAA,GAAA,OAAA,gBAAgB,EAAC,KAAK,MAAM,MAAM,KAAK,aAAa,GAAG,IAAM,IAAI,KAAK;YAC/E;QACF;QAEA,SAAS,iBAAiB,OAAa,EAAE,KAAW;YAClD,IAAI,SAAS,CAAC;gBAAC,iBAAiB;YAAO;YACvC,IAAI,KAAK,CACP,SACA,YACA;gBACE,IAAI,MAAM,CAAC,OAAO,CAAA,GAAA,OAAA,cAAc,EAAC,KAAK,MAAM,SAAS,KAAK,aAAa;gBACvE,IAAI,EAAE,CAAC,CAAA,GAAA,UAAA,GAAG,EAAC,QAAQ;oBACjB,IAAI,KAAK;oBACT,IAAI,KAAK;gBACX;YACF,GACA,UAAA,GAAG;QAEP;IACF;;AAGF,QAAA,OAAA,GAAe"}},
    {"offset": {"line": 4087, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4091, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/validation/limitItems.ts"],"sourcesContent":["import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxItems\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} items`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxItems\", \"minItems\"],\n  type: \"array\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    const op = keyword === \"maxItems\" ? operators.GT : operators.LT\n    cxt.fail$data(_`${data}.length ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n"],"names":[],"mappings":";;;;AAEA,MAAA;AAEA,MAAM,QAAgC;IACpC,SAAQ,EAAC,OAAO,EAAE,UAAU,EAAC;QAC3B,MAAM,OAAO,YAAY,aAAa,SAAS;QAC/C,OAAO,CAAA,GAAA,UAAA,GAAG,CAAA,CAAA,cAAA,EAAiB,KAAI,MAAA,EAAS,WAAU,MAAA,CAAQ;IAC5D;IACA,QAAQ,CAAC,EAAC,UAAU,EAAC,GAAK,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,QAAA,EAAW,WAAU,CAAA,CAAG;;AAGrD,MAAM,MAA6B;IACjC,SAAS;QAAC;QAAY;KAAW;IACjC,MAAM;IACN,YAAY;IACZ,OAAO;IACP;IACA,MAAK,GAAe;QAClB,MAAM,EAAC,OAAO,EAAE,IAAI,EAAE,UAAU,EAAC,GAAG;QACpC,MAAM,KAAK,YAAY,aAAa,UAAA,SAAS,CAAC,EAAE,GAAG,UAAA,SAAS,CAAC,EAAE;QAC/D,IAAI,SAAS,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,KAAI,QAAA,EAAW,GAAE,CAAA,EAAI,WAAU,CAAE;IACrD;;AAGF,QAAA,OAAA,GAAe"}},
    {"offset": {"line": 4119, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4123, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/runtime/equal.ts"],"sourcesContent":["// https://github.com/ajv-validator/ajv/issues/889\nimport * as equal from \"fast-deep-equal\"\n\ntype Equal = typeof equal & {code: string}\n;(equal as Equal).code = 'require(\"ajv/dist/runtime/equal\").default'\n\nexport default equal as Equal\n"],"names":[],"mappings":";;;;AAAA,kDAAkD;AAClD,MAAA;AAGE,MAAgB,IAAI,GAAG;AAEzB,QAAA,OAAA,GAAe"}},
    {"offset": {"line": 4131, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4135, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/validation/uniqueItems.ts"],"sourcesContent":["import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {checkDataTypes, getSchemaTypes, DataType} from \"../../compile/validate/dataType\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type UniqueItemsError = ErrorObject<\n  \"uniqueItems\",\n  {i: number; j: number},\n  boolean | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {i, j}}) =>\n    str`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\n  params: ({params: {i, j}}) => _`{i: ${i}, j: ${j}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"uniqueItems\",\n  type: \"array\",\n  schemaType: \"boolean\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, parentSchema, schemaCode, it} = cxt\n    if (!$data && !schema) return\n    const valid = gen.let(\"valid\")\n    const itemTypes = parentSchema.items ? getSchemaTypes(parentSchema.items) : []\n    cxt.block$data(valid, validateUniqueItems, _`${schemaCode} === false`)\n    cxt.ok(valid)\n\n    function validateUniqueItems(): void {\n      const i = gen.let(\"i\", _`${data}.length`)\n      const j = gen.let(\"j\")\n      cxt.setParams({i, j})\n      gen.assign(valid, true)\n      gen.if(_`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j))\n    }\n\n    function canOptimize(): boolean {\n      return itemTypes.length > 0 && !itemTypes.some((t) => t === \"object\" || t === \"array\")\n    }\n\n    function loopN(i: Name, j: Name): void {\n      const item = gen.name(\"item\")\n      const wrongType = checkDataTypes(itemTypes, item, it.opts.strictNumbers, DataType.Wrong)\n      const indices = gen.const(\"indices\", _`{}`)\n      gen.for(_`;${i}--;`, () => {\n        gen.let(item, _`${data}[${i}]`)\n        gen.if(wrongType, _`continue`)\n        if (itemTypes.length > 1) gen.if(_`typeof ${item} == \"string\"`, _`${item} += \"_\"`)\n        gen\n          .if(_`typeof ${indices}[${item}] == \"number\"`, () => {\n            gen.assign(j, _`${indices}[${item}]`)\n            cxt.error()\n            gen.assign(valid, false).break()\n          })\n          .code(_`${indices}[${item}] = ${i}`)\n      })\n    }\n\n    function loopN2(i: Name, j: Name): void {\n      const eql = useFunc(gen, equal)\n      const outer = gen.name(\"outer\")\n      gen.label(outer).for(_`;${i}--;`, () =>\n        gen.for(_`${j} = ${i}; ${j}--;`, () =>\n          gen.if(_`${eql}(${data}[${i}], ${data}[${j}])`, () => {\n            cxt.error()\n            gen.assign(valid, false).break(outer)\n          })\n        )\n      )\n    }\n  },\n}\n\nexport default def\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4199, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4203, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/validation/const.ts"],"sourcesContent":["import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type ConstError = ErrorObject<\"const\", {allowedValue: any}>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to constant\",\n  params: ({schemaCode}) => _`{allowedValue: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"const\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schemaCode, schema} = cxt\n    if ($data || (schema && typeof schema == \"object\")) {\n      cxt.fail$data(_`!${useFunc(gen, equal)}(${data}, ${schemaCode})`)\n    } else {\n      cxt.fail(_`${schema} !== ${data}`)\n    }\n  },\n}\n\nexport default def\n"],"names":[],"mappings":";;;;AAEA,MAAA;AACA,MAAA;AACA,MAAA;AAIA,MAAM,QAAgC;IACpC,SAAS;IACT,QAAQ,CAAC,EAAC,UAAU,EAAC,GAAK,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,eAAA,EAAkB,WAAU,CAAA,CAAG;;AAG5D,MAAM,MAA6B;IACjC,SAAS;IACT,OAAO;IACP;IACA,MAAK,GAAe;QAClB,MAAM,EAAC,GAAG,EAAE,IAAI,EAAE,KAAK,EAAE,UAAU,EAAE,MAAM,EAAC,GAAG;QAC/C,IAAI,SAAU,UAAU,OAAO,UAAU,UAAW;YAClD,IAAI,SAAS,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,CAAA,EAAI,CAAA,GAAA,OAAA,OAAO,EAAC,KAAK,QAAA,OAAK,EAAC,CAAA,EAAI,KAAI,EAAA,EAAK,WAAU,CAAA,CAAG;QAClE,OAAO;YACL,IAAI,IAAI,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,OAAM,KAAA,EAAQ,KAAI,CAAE;QACnC;IACF;;AAGF,QAAA,OAAA,GAAe"}},
    {"offset": {"line": 4228, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4232, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/validation/enum.ts"],"sourcesContent":["import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, or, Name, Code} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type EnumError = ErrorObject<\"enum\", {allowedValues: any[]}, any[] | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to one of the allowed values\",\n  params: ({schemaCode}) => _`{allowedValues: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"enum\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    if (!$data && schema.length === 0) throw new Error(\"enum must have non-empty array\")\n    const useLoop = schema.length >= it.opts.loopEnum\n    let eql: Name | undefined\n    const getEql = (): Name => (eql ??= useFunc(gen, equal))\n\n    let valid: Code\n    if (useLoop || $data) {\n      valid = gen.let(\"valid\")\n      cxt.block$data(valid, loopEnum)\n    } else {\n      /* istanbul ignore if */\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n      const vSchema = gen.const(\"vSchema\", schemaCode)\n      valid = or(...schema.map((_x: unknown, i: number) => equalCode(vSchema, i)))\n    }\n    cxt.pass(valid)\n\n    function loopEnum(): void {\n      gen.assign(valid, false)\n      gen.forOf(\"v\", schemaCode as Code, (v) =>\n        gen.if(_`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break())\n      )\n    }\n\n    function equalCode(vSchema: Name, i: number): Code {\n      const sch = schema[i]\n      return typeof sch === \"object\" && sch !== null\n        ? _`${getEql()}(${data}, ${vSchema}[${i}])`\n        : _`${data} === ${sch}`\n    }\n  },\n}\n\nexport default def\n"],"names":[],"mappings":";;;;AAEA,MAAA;AACA,MAAA;AACA,MAAA;AAIA,MAAM,QAAgC;IACpC,SAAS;IACT,QAAQ,CAAC,EAAC,UAAU,EAAC,GAAK,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,gBAAA,EAAmB,WAAU,CAAA,CAAG;;AAG7D,MAAM,MAA6B;IACjC,SAAS;IACT,YAAY;IACZ,OAAO;IACP;IACA,MAAK,GAAe;QAClB,MAAM,EAAC,GAAG,EAAE,IAAI,EAAE,KAAK,EAAE,MAAM,EAAE,UAAU,EAAE,EAAE,EAAC,GAAG;QACnD,IAAI,CAAC,SAAS,OAAO,MAAM,KAAK,GAAG,MAAM,IAAI,MAAM;QACnD,MAAM,UAAU,OAAO,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ;QACjD,IAAI;QACJ,MAAM,SAAS,IAAa,QAAG,QAAH,QAAG,KAAA,IAAH,MAAA,MAAQ,CAAA,GAAA,OAAA,OAAO,EAAC,KAAK,QAAA,OAAK;QAEtD,IAAI;QACJ,IAAI,WAAW,OAAO;YACpB,QAAQ,IAAI,GAAG,CAAC;YAChB,IAAI,UAAU,CAAC,OAAO;QACxB,OAAO;YACL,sBAAA,GACA,IAAI,CAAC,MAAM,OAAO,CAAC,SAAS,MAAM,IAAI,MAAM;YAC5C,MAAM,UAAU,IAAI,KAAK,CAAC,WAAW;YACrC,QAAQ,CAAA,GAAA,UAAA,EAAE,KAAI,OAAO,GAAG,CAAC,CAAC,IAAa,IAAc,UAAU,SAAS;QAC1E;QACA,IAAI,IAAI,CAAC;QAET,SAAS;YACP,IAAI,MAAM,CAAC,OAAO;YAClB,IAAI,KAAK,CAAC,KAAK,YAAoB,CAAC,IAClC,IAAI,EAAE,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,SAAQ,CAAA,EAAI,KAAI,EAAA,EAAK,EAAC,CAAA,CAAG,EAAE,IAAM,IAAI,MAAM,CAAC,OAAO,MAAM,KAAK;QAE7E;QAEA,SAAS,UAAU,OAAa,EAAE,CAAS;YACzC,MAAM,MAAM,MAAM,CAAC,EAAE;YACrB,OAAO,OAAO,QAAQ,YAAY,QAAQ,OACtC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,SAAQ,CAAA,EAAI,KAAI,EAAA,EAAK,QAAO,CAAA,EAAI,EAAC,EAAA,CAAI,GACzC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,KAAI,KAAA,EAAQ,IAAG,CAAE;QAC3B;IACF;;AAGF,QAAA,OAAA,GAAe"}},
    {"offset": {"line": 4275, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4279, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/validation/index.ts"],"sourcesContent":["import type {ErrorObject, Vocabulary} from \"../../types\"\nimport limitNumber, {LimitNumberError} from \"./limitNumber\"\nimport multipleOf, {MultipleOfError} from \"./multipleOf\"\nimport limitLength from \"./limitLength\"\nimport pattern, {PatternError} from \"./pattern\"\nimport limitProperties from \"./limitProperties\"\nimport required, {RequiredError} from \"./required\"\nimport limitItems from \"./limitItems\"\nimport uniqueItems, {UniqueItemsError} from \"./uniqueItems\"\nimport constKeyword, {ConstError} from \"./const\"\nimport enumKeyword, {EnumError} from \"./enum\"\n\nconst validation: Vocabulary = [\n  // number\n  limitNumber,\n  multipleOf,\n  // string\n  limitLength,\n  pattern,\n  // object\n  limitProperties,\n  required,\n  // array\n  limitItems,\n  uniqueItems,\n  // any\n  {keyword: \"type\", schemaType: [\"string\", \"array\"]},\n  {keyword: \"nullable\", schemaType: \"boolean\"},\n  constKeyword,\n  enumKeyword,\n]\n\nexport default validation\n\ntype LimitError = ErrorObject<\n  \"maxItems\" | \"minItems\" | \"minProperties\" | \"maxProperties\" | \"minLength\" | \"maxLength\",\n  {limit: number},\n  number | {$data: string}\n>\n\nexport type ValidationKeywordError =\n  | LimitError\n  | LimitNumberError\n  | MultipleOfError\n  | PatternError\n  | RequiredError\n  | UniqueItemsError\n  | ConstError\n  | EnumError\n"],"names":[],"mappings":";;;;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AAEA,MAAM,aAAyB;IAC7B,SAAS;IACT,cAAA,OAAW;IACX,aAAA,OAAU;IACV,SAAS;IACT,cAAA,OAAW;IACX,UAAA,OAAO;IACP,SAAS;IACT,kBAAA,OAAe;IACf,WAAA,OAAQ;IACR,QAAQ;IACR,aAAA,OAAU;IACV,cAAA,OAAW;IACX,MAAM;IACN;QAAC,SAAS;QAAQ,YAAY;YAAC;YAAU;SAAQ;IAAA;IACjD;QAAC,SAAS;QAAY,YAAY;IAAS;IAC3C,QAAA,OAAY;IACZ,OAAA,OAAW;CACZ;AAED,QAAA,OAAA,GAAe"}},
    {"offset": {"line": 4322, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4326, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/applicator/additionalItems.ts"],"sourcesContent":["import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type AdditionalItemsError = ErrorObject<\"additionalItems\", {limit: number}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {len}}) => str`must NOT have more than ${len} items`,\n  params: ({params: {len}}) => _`{limit: ${len}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"additionalItems\" as const,\n  type: \"array\",\n  schemaType: [\"boolean\", \"object\"],\n  before: \"uniqueItems\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {parentSchema, it} = cxt\n    const {items} = parentSchema\n    if (!Array.isArray(items)) {\n      checkStrictMode(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas')\n      return\n    }\n    validateAdditionalItems(cxt, items)\n  },\n}\n\nexport function validateAdditionalItems(cxt: KeywordCxt, items: AnySchema[]): void {\n  const {gen, schema, data, keyword, it} = cxt\n  it.items = true\n  const len = gen.const(\"len\", _`${data}.length`)\n  if (schema === false) {\n    cxt.setParams({len: items.length})\n    cxt.pass(_`${len} <= ${items.length}`)\n  } else if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n    const valid = gen.var(\"valid\", _`${len} <= ${items.length}`) // TODO var\n    gen.if(not(valid), () => validateItems(valid))\n    cxt.ok(valid)\n  }\n\n  function validateItems(valid: Name): void {\n    gen.forRange(\"i\", items.length, len, (i) => {\n      cxt.subschema({keyword, dataProp: i, dataPropType: Type.Num}, valid)\n      if (!it.allErrors) gen.if(not(valid), () => gen.break())\n    })\n  }\n}\n\nexport default def\n"],"names":[],"mappings":";;;;;AAOA,MAAA;AACA,MAAA;AAIA,MAAM,QAAgC;IACpC,SAAS,CAAC,EAAC,QAAQ,EAAC,GAAG,EAAC,EAAC,GAAK,CAAA,GAAA,UAAA,GAAG,CAAA,CAAA,wBAAA,EAA2B,IAAG,MAAA,CAAQ;IACvE,QAAQ,CAAC,EAAC,QAAQ,EAAC,GAAG,EAAC,EAAC,GAAK,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,QAAA,EAAW,IAAG,CAAA,CAAG;;AAGjD,MAAM,MAA6B;IACjC,SAAS;IACT,MAAM;IACN,YAAY;QAAC;QAAW;KAAS;IACjC,QAAQ;IACR;IACA,MAAK,GAAe;QAClB,MAAM,EAAC,YAAY,EAAE,EAAE,EAAC,GAAG;QAC3B,MAAM,EAAC,KAAK,EAAC,GAAG;QAChB,IAAI,CAAC,MAAM,OAAO,CAAC,QAAQ;YACzB,CAAA,GAAA,OAAA,eAAe,EAAC,IAAI;YACpB;QACF;QACA,wBAAwB,KAAK;IAC/B;;AAGF,SAAgB,wBAAwB,GAAe,EAAE,KAAkB;IACzE,MAAM,EAAC,GAAG,EAAE,MAAM,EAAE,IAAI,EAAE,OAAO,EAAE,EAAE,EAAC,GAAG;IACzC,GAAG,KAAK,GAAG;IACX,MAAM,MAAM,IAAI,KAAK,CAAC,OAAO,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,KAAI,OAAA,CAAS;IAC9C,IAAI,WAAW,OAAO;QACpB,IAAI,SAAS,CAAC;YAAC,KAAK,MAAM,MAAM;QAAA;QAChC,IAAI,IAAI,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,IAAG,IAAA,EAAO,MAAM,MAAM,CAAA,CAAE;IACvC,OAAO,IAAI,OAAO,UAAU,YAAY,CAAC,CAAA,GAAA,OAAA,iBAAiB,EAAC,IAAI,SAAS;QACtE,MAAM,QAAQ,IAAI,GAAG,CAAC,SAAS,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,IAAG,IAAA,EAAO,MAAM,MAAM,CAAA,CAAE,GAAE,WAAW;QACxE,IAAI,EAAE,CAAC,CAAA,GAAA,UAAA,GAAG,EAAC,QAAQ,IAAM,cAAc;QACvC,IAAI,EAAE,CAAC;IACT;IAEA,SAAS,cAAc,KAAW;QAChC,IAAI,QAAQ,CAAC,KAAK,MAAM,MAAM,EAAE,KAAK,CAAC;YACpC,IAAI,SAAS,CAAC;gBAAC;gBAAS,UAAU;gBAAG,cAAc,OAAA,IAAI,CAAC,GAAG;YAAA,GAAG;YAC9D,IAAI,CAAC,GAAG,SAAS,EAAE,IAAI,EAAE,CAAC,CAAA,GAAA,UAAA,GAAG,EAAC,QAAQ,IAAM,IAAI,KAAK;QACvD;IACF;AACF;AAnBA,QAAA,uBAAA,GAAA;AAqBA,QAAA,OAAA,GAAe"}},
    {"offset": {"line": 4383, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4387, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/applicator/items.ts"],"sourcesContent":["import type {CodeKeywordDefinition, AnySchema, AnySchemaObject} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_} from \"../../compile/codegen\"\nimport {alwaysValidSchema, mergeEvaluated, checkStrictMode} from \"../../compile/util\"\nimport {validateArray} from \"../code\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"array\", \"boolean\"],\n  before: \"uniqueItems\",\n  code(cxt: KeywordCxt) {\n    const {schema, it} = cxt\n    if (Array.isArray(schema)) return validateTuple(cxt, \"additionalItems\", schema)\n    it.items = true\n    if (alwaysValidSchema(it, schema)) return\n    cxt.ok(validateArray(cxt))\n  },\n}\n\nexport function validateTuple(\n  cxt: KeywordCxt,\n  extraItems: string,\n  schArr: AnySchema[] = cxt.schema\n): void {\n  const {gen, parentSchema, data, keyword, it} = cxt\n  checkStrictTuple(parentSchema)\n  if (it.opts.unevaluated && schArr.length && it.items !== true) {\n    it.items = mergeEvaluated.items(gen, schArr.length, it.items)\n  }\n  const valid = gen.name(\"valid\")\n  const len = gen.const(\"len\", _`${data}.length`)\n  schArr.forEach((sch: AnySchema, i: number) => {\n    if (alwaysValidSchema(it, sch)) return\n    gen.if(_`${len} > ${i}`, () =>\n      cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          dataProp: i,\n        },\n        valid\n      )\n    )\n    cxt.ok(valid)\n  })\n\n  function checkStrictTuple(sch: AnySchemaObject): void {\n    const {opts, errSchemaPath} = it\n    const l = schArr.length\n    const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false)\n    if (opts.strictTuples && !fullTuple) {\n      const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`\n      checkStrictMode(it, msg, opts.strictTuples)\n    }\n  }\n}\n\nexport default def\n"],"names":[],"mappings":";;;;;AAEA,MAAA;AACA,MAAA;AACA,MAAA;AAEA,MAAM,MAA6B;IACjC,SAAS;IACT,MAAM;IACN,YAAY;QAAC;QAAU;QAAS;KAAU;IAC1C,QAAQ;IACR,MAAK,GAAe;QAClB,MAAM,EAAC,MAAM,EAAE,EAAE,EAAC,GAAG;QACrB,IAAI,MAAM,OAAO,CAAC,SAAS,OAAO,cAAc,KAAK,mBAAmB;QACxE,GAAG,KAAK,GAAG;QACX,IAAI,CAAA,GAAA,OAAA,iBAAiB,EAAC,IAAI,SAAS;QACnC,IAAI,EAAE,CAAC,CAAA,GAAA,OAAA,aAAa,EAAC;IACvB;;AAGF,SAAgB,cACd,GAAe,EACf,UAAkB,EAClB,SAAsB,IAAI,MAAM;IAEhC,MAAM,EAAC,GAAG,EAAE,YAAY,EAAE,IAAI,EAAE,OAAO,EAAE,EAAE,EAAC,GAAG;IAC/C,iBAAiB;IACjB,IAAI,GAAG,IAAI,CAAC,WAAW,IAAI,OAAO,MAAM,IAAI,GAAG,KAAK,KAAK,MAAM;QAC7D,GAAG,KAAK,GAAG,OAAA,cAAc,CAAC,KAAK,CAAC,KAAK,OAAO,MAAM,EAAE,GAAG,KAAK;IAC9D;IACA,MAAM,QAAQ,IAAI,IAAI,CAAC;IACvB,MAAM,MAAM,IAAI,KAAK,CAAC,OAAO,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,KAAI,OAAA,CAAS;IAC9C,OAAO,OAAO,CAAC,CAAC,KAAgB;QAC9B,IAAI,CAAA,GAAA,OAAA,iBAAiB,EAAC,IAAI,MAAM;QAChC,IAAI,EAAE,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,IAAG,GAAA,EAAM,EAAC,CAAE,EAAE,IACvB,IAAI,SAAS,CACX;gBACE;gBACA,YAAY;gBACZ,UAAU;eAEZ;QAGJ,IAAI,EAAE,CAAC;IACT;IAEA,SAAS,iBAAiB,GAAoB;QAC5C,MAAM,EAAC,IAAI,EAAE,aAAa,EAAC,GAAG;QAC9B,MAAM,IAAI,OAAO,MAAM;QACvB,MAAM,YAAY,MAAM,IAAI,QAAQ,IAAI,CAAC,MAAM,IAAI,QAAQ,IAAI,GAAG,CAAC,WAAW,KAAK,KAAK;QACxF,IAAI,KAAK,YAAY,IAAI,CAAC,WAAW;YACnC,MAAM,MAAM,CAAA,CAAA,EAAI,QAAO,KAAA,EAAQ,EAAC,iCAAA,EAAoC,WAAU,yCAAA,EAA4C,cAAa,CAAA,CAAG;YAC1I,CAAA,GAAA,OAAA,eAAe,EAAC,IAAI,KAAK,KAAK,YAAY;QAC5C;IACF;AACF;AApCA,QAAA,aAAA,GAAA;AAsCA,QAAA,OAAA,GAAe"}},
    {"offset": {"line": 4441, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4445, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/applicator/prefixItems.ts"],"sourcesContent":["import type {CodeKeywordDefinition} from \"../../types\"\nimport {validateTuple} from \"./items\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"prefixItems\",\n  type: \"array\",\n  schemaType: [\"array\"],\n  before: \"uniqueItems\",\n  code: (cxt) => validateTuple(cxt, \"items\"),\n}\n\nexport default def\n"],"names":[],"mappings":";;;;AACA,MAAA;AAEA,MAAM,MAA6B;IACjC,SAAS;IACT,MAAM;IACN,YAAY;QAAC;KAAQ;IACrB,QAAQ;IACR,MAAM,CAAC,MAAQ,CAAA,GAAA,QAAA,aAAa,EAAC,KAAK;;AAGpC,QAAA,OAAA,GAAe"}},
    {"offset": {"line": 4460, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4464, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/applicator/items2020.ts"],"sourcesContent":["import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {validateArray} from \"../code\"\nimport {validateAdditionalItems} from \"./additionalItems\"\n\nexport type ItemsError = ErrorObject<\"items\", {limit: number}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {len}}) => str`must NOT have more than ${len} items`,\n  params: ({params: {len}}) => _`{limit: ${len}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {schema, parentSchema, it} = cxt\n    const {prefixItems} = parentSchema\n    it.items = true\n    if (alwaysValidSchema(it, schema)) return\n    if (prefixItems) validateAdditionalItems(cxt, prefixItems)\n    else cxt.ok(validateArray(cxt))\n  },\n}\n\nexport default def\n"],"names":[],"mappings":";;;;AAOA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AAIA,MAAM,QAAgC;IACpC,SAAS,CAAC,EAAC,QAAQ,EAAC,GAAG,EAAC,EAAC,GAAK,CAAA,GAAA,UAAA,GAAG,CAAA,CAAA,wBAAA,EAA2B,IAAG,MAAA,CAAQ;IACvE,QAAQ,CAAC,EAAC,QAAQ,EAAC,GAAG,EAAC,EAAC,GAAK,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,QAAA,EAAW,IAAG,CAAA,CAAG;;AAGjD,MAAM,MAA6B;IACjC,SAAS;IACT,MAAM;IACN,YAAY;QAAC;QAAU;KAAU;IACjC,QAAQ;IACR;IACA,MAAK,GAAe;QAClB,MAAM,EAAC,MAAM,EAAE,YAAY,EAAE,EAAE,EAAC,GAAG;QACnC,MAAM,EAAC,WAAW,EAAC,GAAG;QACtB,GAAG,KAAK,GAAG;QACX,IAAI,CAAA,GAAA,OAAA,iBAAiB,EAAC,IAAI,SAAS;QACnC,IAAI,aAAa,CAAA,GAAA,kBAAA,uBAAuB,EAAC,KAAK;aACzC,IAAI,EAAE,CAAC,CAAA,GAAA,OAAA,aAAa,EAAC;IAC5B;;AAGF,QAAA,OAAA,GAAe"}},
    {"offset": {"line": 4495, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4499, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/applicator/contains.ts"],"sourcesContent":["import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type ContainsError = ErrorObject<\n  \"contains\",\n  {minContains: number; maxContains?: number},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {min, max}}) =>\n    max === undefined\n      ? str`must contain at least ${min} valid item(s)`\n      : str`must contain at least ${min} and no more than ${max} valid item(s)`,\n  params: ({params: {min, max}}) =>\n    max === undefined ? _`{minContains: ${min}}` : _`{minContains: ${min}, maxContains: ${max}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"contains\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    let min: number\n    let max: number | undefined\n    const {minContains, maxContains} = parentSchema\n    if (it.opts.next) {\n      min = minContains === undefined ? 1 : minContains\n      max = maxContains\n    } else {\n      min = 1\n    }\n    const len = gen.const(\"len\", _`${data}.length`)\n    cxt.setParams({min, max})\n    if (max === undefined && min === 0) {\n      checkStrictMode(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`)\n      return\n    }\n    if (max !== undefined && min > max) {\n      checkStrictMode(it, `\"minContains\" > \"maxContains\" is always invalid`)\n      cxt.fail()\n      return\n    }\n    if (alwaysValidSchema(it, schema)) {\n      let cond = _`${len} >= ${min}`\n      if (max !== undefined) cond = _`${cond} && ${len} <= ${max}`\n      cxt.pass(cond)\n      return\n    }\n\n    it.items = true\n    const valid = gen.name(\"valid\")\n    if (max === undefined && min === 1) {\n      validateItems(valid, () => gen.if(valid, () => gen.break()))\n    } else if (min === 0) {\n      gen.let(valid, true)\n      if (max !== undefined) gen.if(_`${data}.length > 0`, validateItemsWithCount)\n    } else {\n      gen.let(valid, false)\n      validateItemsWithCount()\n    }\n    cxt.result(valid, () => cxt.reset())\n\n    function validateItemsWithCount(): void {\n      const schValid = gen.name(\"_valid\")\n      const count = gen.let(\"count\", 0)\n      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)))\n    }\n\n    function validateItems(_valid: Name, block: () => void): void {\n      gen.forRange(\"i\", 0, len, (i) => {\n        cxt.subschema(\n          {\n            keyword: \"contains\",\n            dataProp: i,\n            dataPropType: Type.Num,\n            compositeRule: true,\n          },\n          _valid\n        )\n        block()\n      })\n    }\n\n    function checkLimits(count: Name): void {\n      gen.code(_`${count}++`)\n      if (max === undefined) {\n        gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true).break())\n      } else {\n        gen.if(_`${count} > ${max}`, () => gen.assign(valid, false).break())\n        if (min === 1) gen.assign(valid, true)\n        else gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true))\n      }\n    }\n  },\n}\n\nexport default def\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4591, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4595, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/applicator/dependencies.ts"],"sourcesContent":["import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  SchemaMap,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {checkReportMissingProp, checkMissingProp, reportMissingProp, propertyInData} from \"../code\"\n\nexport type PropertyDependencies = {[K in string]?: string[]}\n\nexport interface DependenciesErrorParams {\n  property: string\n  missingProperty: string\n  depsCount: number\n  deps: string // TODO change to string[]\n}\n\ntype SchemaDependencies = SchemaMap\n\nexport type DependenciesError = ErrorObject<\n  \"dependencies\",\n  DependenciesErrorParams,\n  {[K in string]?: string[] | AnySchema}\n>\n\nexport const error: KeywordErrorDefinition = {\n  message: ({params: {property, depsCount, deps}}) => {\n    const property_ies = depsCount === 1 ? \"property\" : \"properties\"\n    return str`must have ${property_ies} ${deps} when property ${property} is present`\n  },\n  params: ({params: {property, depsCount, deps, missingProperty}}) =>\n    _`{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`, // TODO change to reference\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"dependencies\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const [propDeps, schDeps] = splitDependencies(cxt)\n    validatePropertyDeps(cxt, propDeps)\n    validateSchemaDeps(cxt, schDeps)\n  },\n}\n\nfunction splitDependencies({schema}: KeywordCxt): [PropertyDependencies, SchemaDependencies] {\n  const propertyDeps: PropertyDependencies = {}\n  const schemaDeps: SchemaDependencies = {}\n  for (const key in schema) {\n    if (key === \"__proto__\") continue\n    const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps\n    deps[key] = schema[key]\n  }\n  return [propertyDeps, schemaDeps]\n}\n\nexport function validatePropertyDeps(\n  cxt: KeywordCxt,\n  propertyDeps: {[K in string]?: string[]} = cxt.schema\n): void {\n  const {gen, data, it} = cxt\n  if (Object.keys(propertyDeps).length === 0) return\n  const missing = gen.let(\"missing\")\n  for (const prop in propertyDeps) {\n    const deps = propertyDeps[prop] as string[]\n    if (deps.length === 0) continue\n    const hasProperty = propertyInData(gen, data, prop, it.opts.ownProperties)\n    cxt.setParams({\n      property: prop,\n      depsCount: deps.length,\n      deps: deps.join(\", \"),\n    })\n    if (it.allErrors) {\n      gen.if(hasProperty, () => {\n        for (const depProp of deps) {\n          checkReportMissingProp(cxt, depProp)\n        }\n      })\n    } else {\n      gen.if(_`${hasProperty} && (${checkMissingProp(cxt, deps, missing)})`)\n      reportMissingProp(cxt, missing)\n      gen.else()\n    }\n  }\n}\n\nexport function validateSchemaDeps(cxt: KeywordCxt, schemaDeps: SchemaMap = cxt.schema): void {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  for (const prop in schemaDeps) {\n    if (alwaysValidSchema(it, schemaDeps[prop] as AnySchema)) continue\n    gen.if(\n      propertyInData(gen, data, prop, it.opts.ownProperties),\n      () => {\n        const schCxt = cxt.subschema({keyword, schemaProp: prop}, valid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n      },\n      () => gen.var(valid, true) // TODO var\n    )\n    cxt.ok(valid)\n  }\n}\n\nexport default def\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4682, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4686, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/applicator/propertyNames.ts"],"sourcesContent":["import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, not} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nexport type PropertyNamesError = ErrorObject<\"propertyNames\", {propertyName: string}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: \"property name must be valid\",\n  params: ({params}) => _`{propertyName: ${params.propertyName}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"propertyNames\",\n  type: \"object\",\n  schemaType: [\"object\", \"boolean\"],\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, it} = cxt\n    if (alwaysValidSchema(it, schema)) return\n    const valid = gen.name(\"valid\")\n\n    gen.forIn(\"key\", data, (key) => {\n      cxt.setParams({propertyName: key})\n      cxt.subschema(\n        {\n          keyword: \"propertyNames\",\n          data: key,\n          dataTypes: [\"string\"],\n          propertyName: key,\n          compositeRule: true,\n        },\n        valid\n      )\n      gen.if(not(valid), () => {\n        cxt.error(true)\n        if (!it.allErrors) gen.break()\n      })\n    })\n\n    cxt.ok(valid)\n  },\n}\n\nexport default def\n"],"names":[],"mappings":";;;;AAOA,MAAA;AACA,MAAA;AAIA,MAAM,QAAgC;IACpC,SAAS;IACT,QAAQ,CAAC,EAAC,MAAM,EAAC,GAAK,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,eAAA,EAAkB,OAAO,YAAY,CAAA,CAAA,CAAG;;AAGjE,MAAM,MAA6B;IACjC,SAAS;IACT,MAAM;IACN,YAAY;QAAC;QAAU;KAAU;IACjC;IACA,MAAK,GAAe;QAClB,MAAM,EAAC,GAAG,EAAE,MAAM,EAAE,IAAI,EAAE,EAAE,EAAC,GAAG;QAChC,IAAI,CAAA,GAAA,OAAA,iBAAiB,EAAC,IAAI,SAAS;QACnC,MAAM,QAAQ,IAAI,IAAI,CAAC;QAEvB,IAAI,KAAK,CAAC,OAAO,MAAM,CAAC;YACtB,IAAI,SAAS,CAAC;gBAAC,cAAc;YAAG;YAChC,IAAI,SAAS,CACX;gBACE,SAAS;gBACT,MAAM;gBACN,WAAW;oBAAC;iBAAS;gBACrB,cAAc;gBACd,eAAe;eAEjB;YAEF,IAAI,EAAE,CAAC,CAAA,GAAA,UAAA,GAAG,EAAC,QAAQ;gBACjB,IAAI,KAAK,CAAC;gBACV,IAAI,CAAC,GAAG,SAAS,EAAE,IAAI,KAAK;YAC9B;QACF;QAEA,IAAI,EAAE,CAAC;IACT;;AAGF,QAAA,OAAA,GAAe"}},
    {"offset": {"line": 4730, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4734, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/applicator/additionalProperties.ts"],"sourcesContent":["import type {\n  CodeKeywordDefinition,\n  AddedKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport {allSchemaProperties, usePattern, isOwnProperty} from \"../code\"\nimport {_, nil, or, not, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport type {SubschemaArgs} from \"../../compile/validate/subschema\"\nimport {alwaysValidSchema, schemaRefOrVal, Type} from \"../../compile/util\"\n\nexport type AdditionalPropertiesError = ErrorObject<\n  \"additionalProperties\",\n  {additionalProperty: string},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must NOT have additional properties\",\n  params: ({params}) => _`{additionalProperty: ${params.additionalProperty}}`,\n}\n\nconst def: CodeKeywordDefinition & AddedKeywordDefinition = {\n  keyword: \"additionalProperties\",\n  type: [\"object\"],\n  schemaType: [\"boolean\", \"object\"],\n  allowUndefined: true,\n  trackErrors: true,\n  error,\n  code(cxt) {\n    const {gen, schema, parentSchema, data, errsCount, it} = cxt\n    /* istanbul ignore if */\n    if (!errsCount) throw new Error(\"ajv implementation error\")\n    const {allErrors, opts} = it\n    it.props = true\n    if (opts.removeAdditional !== \"all\" && alwaysValidSchema(it, schema)) return\n    const props = allSchemaProperties(parentSchema.properties)\n    const patProps = allSchemaProperties(parentSchema.patternProperties)\n    checkAdditionalProperties()\n    cxt.ok(_`${errsCount} === ${N.errors}`)\n\n    function checkAdditionalProperties(): void {\n      gen.forIn(\"key\", data, (key: Name) => {\n        if (!props.length && !patProps.length) additionalPropertyCode(key)\n        else gen.if(isAdditional(key), () => additionalPropertyCode(key))\n      })\n    }\n\n    function isAdditional(key: Name): Code {\n      let definedProp: Code\n      if (props.length > 8) {\n        // TODO maybe an option instead of hard-coded 8?\n        const propsSchema = schemaRefOrVal(it, parentSchema.properties, \"properties\")\n        definedProp = isOwnProperty(gen, propsSchema as Code, key)\n      } else if (props.length) {\n        definedProp = or(...props.map((p) => _`${key} === ${p}`))\n      } else {\n        definedProp = nil\n      }\n      if (patProps.length) {\n        definedProp = or(definedProp, ...patProps.map((p) => _`${usePattern(cxt, p)}.test(${key})`))\n      }\n      return not(definedProp)\n    }\n\n    function deleteAdditional(key: Name): void {\n      gen.code(_`delete ${data}[${key}]`)\n    }\n\n    function additionalPropertyCode(key: Name): void {\n      if (opts.removeAdditional === \"all\" || (opts.removeAdditional && schema === false)) {\n        deleteAdditional(key)\n        return\n      }\n\n      if (schema === false) {\n        cxt.setParams({additionalProperty: key})\n        cxt.error()\n        if (!allErrors) gen.break()\n        return\n      }\n\n      if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n        const valid = gen.name(\"valid\")\n        if (opts.removeAdditional === \"failing\") {\n          applyAdditionalSchema(key, valid, false)\n          gen.if(not(valid), () => {\n            cxt.reset()\n            deleteAdditional(key)\n          })\n        } else {\n          applyAdditionalSchema(key, valid)\n          if (!allErrors) gen.if(not(valid), () => gen.break())\n        }\n      }\n    }\n\n    function applyAdditionalSchema(key: Name, valid: Name, errors?: false): void {\n      const subschema: SubschemaArgs = {\n        keyword: \"additionalProperties\",\n        dataProp: key,\n        dataPropType: Type.Str,\n      }\n      if (errors === false) {\n        Object.assign(subschema, {\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        })\n      }\n      cxt.subschema(subschema, valid)\n    }\n  },\n}\n\nexport default def\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4838, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4842, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/applicator/properties.ts"],"sourcesContent":["import type {CodeKeywordDefinition} from \"../../types\"\nimport {KeywordCxt} from \"../../compile/validate\"\nimport {propertyInData, allSchemaProperties} from \"../code\"\nimport {alwaysValidSchema, toHash, mergeEvaluated} from \"../../compile/util\"\nimport apDef from \"./additionalProperties\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"properties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    if (it.opts.removeAdditional === \"all\" && parentSchema.additionalProperties === undefined) {\n      apDef.code(new KeywordCxt(it, apDef, \"additionalProperties\"))\n    }\n    const allProps = allSchemaProperties(schema)\n    for (const prop of allProps) {\n      it.definedProperties.add(prop)\n    }\n    if (it.opts.unevaluated && allProps.length && it.props !== true) {\n      it.props = mergeEvaluated.props(gen, toHash(allProps), it.props)\n    }\n    const properties = allProps.filter((p) => !alwaysValidSchema(it, schema[p]))\n    if (properties.length === 0) return\n    const valid = gen.name(\"valid\")\n\n    for (const prop of properties) {\n      if (hasDefault(prop)) {\n        applyPropertySchema(prop)\n      } else {\n        gen.if(propertyInData(gen, data, prop, it.opts.ownProperties))\n        applyPropertySchema(prop)\n        if (!it.allErrors) gen.else().var(valid, true)\n        gen.endIf()\n      }\n      cxt.it.definedProperties.add(prop)\n      cxt.ok(valid)\n    }\n\n    function hasDefault(prop: string): boolean | undefined {\n      return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined\n    }\n\n    function applyPropertySchema(prop: string): void {\n      cxt.subschema(\n        {\n          keyword: \"properties\",\n          schemaProp: prop,\n          dataProp: prop,\n        },\n        valid\n      )\n    }\n  },\n}\n\nexport default def\n"],"names":[],"mappings":";;;;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AAEA,MAAM,MAA6B;IACjC,SAAS;IACT,MAAM;IACN,YAAY;IACZ,MAAK,GAAe;QAClB,MAAM,EAAC,GAAG,EAAE,MAAM,EAAE,YAAY,EAAE,IAAI,EAAE,EAAE,EAAC,GAAG;QAC9C,IAAI,GAAG,IAAI,CAAC,gBAAgB,KAAK,SAAS,aAAa,oBAAoB,KAAK,WAAW;YACzF,uBAAA,OAAK,CAAC,IAAI,CAAC,IAAI,WAAA,UAAU,CAAC,IAAI,uBAAA,OAAK,EAAE;QACvC;QACA,MAAM,WAAW,CAAA,GAAA,OAAA,mBAAmB,EAAC;QACrC,KAAK,MAAM,QAAQ,SAAU;YAC3B,GAAG,iBAAiB,CAAC,GAAG,CAAC;QAC3B;QACA,IAAI,GAAG,IAAI,CAAC,WAAW,IAAI,SAAS,MAAM,IAAI,GAAG,KAAK,KAAK,MAAM;YAC/D,GAAG,KAAK,GAAG,OAAA,cAAc,CAAC,KAAK,CAAC,KAAK,CAAA,GAAA,OAAA,MAAM,EAAC,WAAW,GAAG,KAAK;QACjE;QACA,MAAM,aAAa,SAAS,MAAM,CAAC,CAAC,IAAM,CAAC,CAAA,GAAA,OAAA,iBAAiB,EAAC,IAAI,MAAM,CAAC,EAAE;QAC1E,IAAI,WAAW,MAAM,KAAK,GAAG;QAC7B,MAAM,QAAQ,IAAI,IAAI,CAAC;QAEvB,KAAK,MAAM,QAAQ,WAAY;YAC7B,IAAI,WAAW,OAAO;gBACpB,oBAAoB;YACtB,OAAO;gBACL,IAAI,EAAE,CAAC,CAAA,GAAA,OAAA,cAAc,EAAC,KAAK,MAAM,MAAM,GAAG,IAAI,CAAC,aAAa;gBAC5D,oBAAoB;gBACpB,IAAI,CAAC,GAAG,SAAS,EAAE,IAAI,IAAI,GAAG,GAAG,CAAC,OAAO;gBACzC,IAAI,KAAK;YACX;YACA,IAAI,EAAE,CAAC,iBAAiB,CAAC,GAAG,CAAC;YAC7B,IAAI,EAAE,CAAC;QACT;QAEA,SAAS,WAAW,IAAY;YAC9B,OAAO,GAAG,IAAI,CAAC,WAAW,IAAI,CAAC,GAAG,aAAa,IAAI,MAAM,CAAC,KAAK,CAAC,OAAO,KAAK;QAC9E;QAEA,SAAS,oBAAoB,IAAY;YACvC,IAAI,SAAS,CACX;gBACE,SAAS;gBACT,YAAY;gBACZ,UAAU;eAEZ;QAEJ;IACF;;AAGF,QAAA,OAAA,GAAe"}},
    {"offset": {"line": 4894, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4898, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/applicator/patternProperties.ts"],"sourcesContent":["import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {allSchemaProperties, usePattern} from \"../code\"\nimport {_, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\nimport {evaluatedPropsToName, Type} from \"../../compile/util\"\nimport {AnySchema} from \"../../types\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"patternProperties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, parentSchema, it} = cxt\n    const {opts} = it\n    const patterns = allSchemaProperties(schema)\n    const alwaysValidPatterns = patterns.filter((p) =>\n      alwaysValidSchema(it, schema[p] as AnySchema)\n    )\n\n    if (\n      patterns.length === 0 ||\n      (alwaysValidPatterns.length === patterns.length &&\n        (!it.opts.unevaluated || it.props === true))\n    ) {\n      return\n    }\n\n    const checkProperties =\n      opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties\n    const valid = gen.name(\"valid\")\n    if (it.props !== true && !(it.props instanceof Name)) {\n      it.props = evaluatedPropsToName(gen, it.props)\n    }\n    const {props} = it\n    validatePatternProperties()\n\n    function validatePatternProperties(): void {\n      for (const pat of patterns) {\n        if (checkProperties) checkMatchingProperties(pat)\n        if (it.allErrors) {\n          validateProperties(pat)\n        } else {\n          gen.var(valid, true) // TODO var\n          validateProperties(pat)\n          gen.if(valid)\n        }\n      }\n    }\n\n    function checkMatchingProperties(pat: string): void {\n      for (const prop in checkProperties) {\n        if (new RegExp(pat).test(prop)) {\n          checkStrictMode(\n            it,\n            `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`\n          )\n        }\n      }\n    }\n\n    function validateProperties(pat: string): void {\n      gen.forIn(\"key\", data, (key) => {\n        gen.if(_`${usePattern(cxt, pat)}.test(${key})`, () => {\n          const alwaysValid = alwaysValidPatterns.includes(pat)\n          if (!alwaysValid) {\n            cxt.subschema(\n              {\n                keyword: \"patternProperties\",\n                schemaProp: pat,\n                dataProp: key,\n                dataPropType: Type.Str,\n              },\n              valid\n            )\n          }\n\n          if (it.opts.unevaluated && props !== true) {\n            gen.assign(_`${props}[${key}]`, true)\n          } else if (!alwaysValid && !it.allErrors) {\n            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n            // or if all properties were evaluated (props === true)\n            gen.if(not(valid), () => gen.break())\n          }\n        })\n      })\n    }\n  },\n}\n\nexport default def\n"],"names":[],"mappings":";;;;AAEA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AAGA,MAAM,MAA6B;IACjC,SAAS;IACT,MAAM;IACN,YAAY;IACZ,MAAK,GAAe;QAClB,MAAM,EAAC,GAAG,EAAE,MAAM,EAAE,IAAI,EAAE,YAAY,EAAE,EAAE,EAAC,GAAG;QAC9C,MAAM,EAAC,IAAI,EAAC,GAAG;QACf,MAAM,WAAW,CAAA,GAAA,OAAA,mBAAmB,EAAC;QACrC,MAAM,sBAAsB,SAAS,MAAM,CAAC,CAAC,IAC3C,CAAA,GAAA,OAAA,iBAAiB,EAAC,IAAI,MAAM,CAAC,EAAe;QAG9C,IACE,SAAS,MAAM,KAAK,KACnB,oBAAoB,MAAM,KAAK,SAAS,MAAM,IAC7C,CAAC,CAAC,GAAG,IAAI,CAAC,WAAW,IAAI,GAAG,KAAK,KAAK,IAAI,GAC5C;YACA;QACF;QAEA,MAAM,kBACJ,KAAK,YAAY,IAAI,CAAC,KAAK,uBAAuB,IAAI,aAAa,UAAU;QAC/E,MAAM,QAAQ,IAAI,IAAI,CAAC;QACvB,IAAI,GAAG,KAAK,KAAK,QAAQ,CAAC,CAAC,GAAG,KAAK,YAAY,UAAA,IAAI,GAAG;YACpD,GAAG,KAAK,GAAG,CAAA,GAAA,OAAA,oBAAoB,EAAC,KAAK,GAAG,KAAK;QAC/C;QACA,MAAM,EAAC,KAAK,EAAC,GAAG;QAChB;QAEA,SAAS;YACP,KAAK,MAAM,OAAO,SAAU;gBAC1B,IAAI,iBAAiB,wBAAwB;gBAC7C,IAAI,GAAG,SAAS,EAAE;oBAChB,mBAAmB;gBACrB,OAAO;oBACL,IAAI,GAAG,CAAC,OAAO,OAAM,WAAW;oBAChC,mBAAmB;oBACnB,IAAI,EAAE,CAAC;gBACT;YACF;QACF;QAEA,SAAS,wBAAwB,GAAW;YAC1C,IAAK,MAAM,QAAQ,gBAAiB;gBAClC,IAAI,IAAI,OAAO,KAAK,IAAI,CAAC,OAAO;oBAC9B,CAAA,GAAA,OAAA,eAAe,EACb,IACA,CAAA,SAAA,EAAY,KAAI,iBAAA,EAAoB,IAAG,8BAAA,CAAgC;gBAE3E;YACF;QACF;QAEA,SAAS,mBAAmB,GAAW;YACrC,IAAI,KAAK,CAAC,OAAO,MAAM,CAAC;gBACtB,IAAI,EAAE,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,CAAA,GAAA,OAAA,UAAU,EAAC,KAAK,KAAI,MAAA,EAAS,IAAG,CAAA,CAAG,EAAE;oBAC9C,MAAM,cAAc,oBAAoB,QAAQ,CAAC;oBACjD,IAAI,CAAC,aAAa;wBAChB,IAAI,SAAS,CACX;4BACE,SAAS;4BACT,YAAY;4BACZ,UAAU;4BACV,cAAc,OAAA,IAAI,CAAC,GAAG;2BAExB;oBAEJ;oBAEA,IAAI,GAAG,IAAI,CAAC,WAAW,IAAI,UAAU,MAAM;wBACzC,IAAI,MAAM,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,MAAK,CAAA,EAAI,IAAG,CAAA,CAAG,EAAE;oBAClC,OAAO,IAAI,CAAC,eAAe,CAAC,GAAG,SAAS,EAAE;wBACxC,sFAAsF;wBACtF,uDAAuD;wBACvD,IAAI,EAAE,CAAC,CAAA,GAAA,UAAA,GAAG,EAAC,QAAQ,IAAM,IAAI,KAAK;oBACpC;gBACF;YACF;QACF;IACF;;AAGF,QAAA,OAAA,GAAe"}},
    {"offset": {"line": 4969, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4973, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/applicator/not.ts"],"sourcesContent":["import type {CodeKeywordDefinition, ErrorNoParams, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nexport type NotKeywordError = ErrorNoParams<\"not\", AnySchema>\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"not\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, it} = cxt\n    if (alwaysValidSchema(it, schema)) {\n      cxt.fail()\n      return\n    }\n\n    const valid = gen.name(\"valid\")\n    cxt.subschema(\n      {\n        keyword: \"not\",\n        compositeRule: true,\n        createErrors: false,\n        allErrors: false,\n      },\n      valid\n    )\n\n    cxt.failResult(\n      valid,\n      () => cxt.reset(),\n      () => cxt.error()\n    )\n  },\n  error: {message: \"must NOT be valid\"},\n}\n\nexport default def\n"],"names":[],"mappings":";;;;AAEA,MAAA;AAIA,MAAM,MAA6B;IACjC,SAAS;IACT,YAAY;QAAC;QAAU;KAAU;IACjC,aAAa;IACb,MAAK,GAAe;QAClB,MAAM,EAAC,GAAG,EAAE,MAAM,EAAE,EAAE,EAAC,GAAG;QAC1B,IAAI,CAAA,GAAA,OAAA,iBAAiB,EAAC,IAAI,SAAS;YACjC,IAAI,IAAI;YACR;QACF;QAEA,MAAM,QAAQ,IAAI,IAAI,CAAC;QACvB,IAAI,SAAS,CACX;YACE,SAAS;YACT,eAAe;YACf,cAAc;YACd,WAAW;WAEb;QAGF,IAAI,UAAU,CACZ,OACA,IAAM,IAAI,KAAK,IACf,IAAM,IAAI,KAAK;IAEnB;IACA,OAAO;QAAC,SAAS;IAAmB;;AAGtC,QAAA,OAAA,GAAe"}},
    {"offset": {"line": 5005, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5009, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/applicator/anyOf.ts"],"sourcesContent":["import type {CodeKeywordDefinition, ErrorNoParams, AnySchema} from \"../../types\"\nimport {validateUnion} from \"../code\"\n\nexport type AnyOfError = ErrorNoParams<\"anyOf\", AnySchema[]>\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"anyOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  code: validateUnion,\n  error: {message: \"must match a schema in anyOf\"},\n}\n\nexport default def\n"],"names":[],"mappings":";;;;AACA,MAAA;AAIA,MAAM,MAA6B;IACjC,SAAS;IACT,YAAY;IACZ,aAAa;IACb,MAAM,OAAA,aAAa;IACnB,OAAO;QAAC,SAAS;IAA8B;;AAGjD,QAAA,OAAA,GAAe"}},
    {"offset": {"line": 5024, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5028, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/applicator/oneOf.ts"],"sourcesContent":["import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {SchemaCxt} from \"../../compile\"\n\nexport type OneOfError = ErrorObject<\n  \"oneOf\",\n  {passingSchemas: [number, number] | null},\n  AnySchema[]\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must match exactly one schema in oneOf\",\n  params: ({params}) => _`{passingSchemas: ${params.passing}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"oneOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, it} = cxt\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n    if (it.opts.discriminator && parentSchema.discriminator) return\n    const schArr: AnySchema[] = schema\n    const valid = gen.let(\"valid\", false)\n    const passing = gen.let(\"passing\", null)\n    const schValid = gen.name(\"_valid\")\n    cxt.setParams({passing})\n    // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n\n    gen.block(validateOneOf)\n\n    cxt.result(\n      valid,\n      () => cxt.reset(),\n      () => cxt.error(true)\n    )\n\n    function validateOneOf(): void {\n      schArr.forEach((sch: AnySchema, i: number) => {\n        let schCxt: SchemaCxt | undefined\n        if (alwaysValidSchema(it, sch)) {\n          gen.var(schValid, true)\n        } else {\n          schCxt = cxt.subschema(\n            {\n              keyword: \"oneOf\",\n              schemaProp: i,\n              compositeRule: true,\n            },\n            schValid\n          )\n        }\n\n        if (i > 0) {\n          gen\n            .if(_`${schValid} && ${valid}`)\n            .assign(valid, false)\n            .assign(passing, _`[${passing}, ${i}]`)\n            .else()\n        }\n\n        gen.if(schValid, () => {\n          gen.assign(valid, true)\n          gen.assign(passing, i)\n          if (schCxt) cxt.mergeEvaluated(schCxt, Name)\n        })\n      })\n    }\n  },\n}\n\nexport default def\n"],"names":[],"mappings":";;;;AAOA,MAAA;AACA,MAAA;AASA,MAAM,QAAgC;IACpC,SAAS;IACT,QAAQ,CAAC,EAAC,MAAM,EAAC,GAAK,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,iBAAA,EAAoB,OAAO,OAAO,CAAA,CAAA,CAAG;;AAG9D,MAAM,MAA6B;IACjC,SAAS;IACT,YAAY;IACZ,aAAa;IACb;IACA,MAAK,GAAe;QAClB,MAAM,EAAC,GAAG,EAAE,MAAM,EAAE,YAAY,EAAE,EAAE,EAAC,GAAG;QACxC,sBAAA,GACA,IAAI,CAAC,MAAM,OAAO,CAAC,SAAS,MAAM,IAAI,MAAM;QAC5C,IAAI,GAAG,IAAI,CAAC,aAAa,IAAI,aAAa,aAAa,EAAE;QACzD,MAAM,SAAsB;QAC5B,MAAM,QAAQ,IAAI,GAAG,CAAC,SAAS;QAC/B,MAAM,UAAU,IAAI,GAAG,CAAC,WAAW;QACnC,MAAM,WAAW,IAAI,IAAI,CAAC;QAC1B,IAAI,SAAS,CAAC;YAAC;QAAO;QACtB,2GAA2G;QAE3G,IAAI,KAAK,CAAC;QAEV,IAAI,MAAM,CACR,OACA,IAAM,IAAI,KAAK,IACf,IAAM,IAAI,KAAK,CAAC;QAGlB,SAAS;YACP,OAAO,OAAO,CAAC,CAAC,KAAgB;gBAC9B,IAAI;gBACJ,IAAI,CAAA,GAAA,OAAA,iBAAiB,EAAC,IAAI,MAAM;oBAC9B,IAAI,GAAG,CAAC,UAAU;gBACpB,OAAO;oBACL,SAAS,IAAI,SAAS,CACpB;wBACE,SAAS;wBACT,YAAY;wBACZ,eAAe;uBAEjB;gBAEJ;gBAEA,IAAI,IAAI,GAAG;oBACT,IACG,EAAE,CAAC,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,SAAQ,IAAA,EAAO,MAAK,CAAE,EAC7B,MAAM,CAAC,OAAO,OACd,MAAM,CAAC,SAAS,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,CAAA,EAAI,QAAO,EAAA,EAAK,EAAC,CAAA,CAAG,EACrC,IAAI;gBACT;gBAEA,IAAI,EAAE,CAAC,UAAU;oBACf,IAAI,MAAM,CAAC,OAAO;oBAClB,IAAI,MAAM,CAAC,SAAS;oBACpB,IAAI,QAAQ,IAAI,cAAc,CAAC,QAAQ,UAAA,IAAI;gBAC7C;YACF;QACF;IACF;;AAGF,QAAA,OAAA,GAAe"}},
    {"offset": {"line": 5082, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5086, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/applicator/allOf.ts"],"sourcesContent":["import type {CodeKeywordDefinition, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"allOf\",\n  schemaType: \"array\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, it} = cxt\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n    const valid = gen.name(\"valid\")\n    schema.forEach((sch: AnySchema, i: number) => {\n      if (alwaysValidSchema(it, sch)) return\n      const schCxt = cxt.subschema({keyword: \"allOf\", schemaProp: i}, valid)\n      cxt.ok(valid)\n      cxt.mergeEvaluated(schCxt)\n    })\n  },\n}\n\nexport default def\n"],"names":[],"mappings":";;;;AAEA,MAAA;AAEA,MAAM,MAA6B;IACjC,SAAS;IACT,YAAY;IACZ,MAAK,GAAe;QAClB,MAAM,EAAC,GAAG,EAAE,MAAM,EAAE,EAAE,EAAC,GAAG;QAC1B,sBAAA,GACA,IAAI,CAAC,MAAM,OAAO,CAAC,SAAS,MAAM,IAAI,MAAM;QAC5C,MAAM,QAAQ,IAAI,IAAI,CAAC;QACvB,OAAO,OAAO,CAAC,CAAC,KAAgB;YAC9B,IAAI,CAAA,GAAA,OAAA,iBAAiB,EAAC,IAAI,MAAM;YAChC,MAAM,SAAS,IAAI,SAAS,CAAC;gBAAC,SAAS;gBAAS,YAAY;YAAC,GAAG;YAChE,IAAI,EAAE,CAAC;YACP,IAAI,cAAc,CAAC;QACrB;IACF;;AAGF,QAAA,OAAA,GAAe"}},
    {"offset": {"line": 5110, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5114, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/applicator/if.ts"],"sourcesContent":["import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"../../compile\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\n\nexport type IfKeywordError = ErrorObject<\"if\", {failingKeyword: string}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params}) => str`must match \"${params.ifClause}\" schema`,\n  params: ({params}) => _`{failingKeyword: ${params.ifClause}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"if\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, parentSchema, it} = cxt\n    if (parentSchema.then === undefined && parentSchema.else === undefined) {\n      checkStrictMode(it, '\"if\" without \"then\" and \"else\" is ignored')\n    }\n    const hasThen = hasSchema(it, \"then\")\n    const hasElse = hasSchema(it, \"else\")\n    if (!hasThen && !hasElse) return\n\n    const valid = gen.let(\"valid\", true)\n    const schValid = gen.name(\"_valid\")\n    validateIf()\n    cxt.reset()\n\n    if (hasThen && hasElse) {\n      const ifClause = gen.let(\"ifClause\")\n      cxt.setParams({ifClause})\n      gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause))\n    } else if (hasThen) {\n      gen.if(schValid, validateClause(\"then\"))\n    } else {\n      gen.if(not(schValid), validateClause(\"else\"))\n    }\n\n    cxt.pass(valid, () => cxt.error(true))\n\n    function validateIf(): void {\n      const schCxt = cxt.subschema(\n        {\n          keyword: \"if\",\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        },\n        schValid\n      )\n      cxt.mergeEvaluated(schCxt)\n    }\n\n    function validateClause(keyword: string, ifClause?: Name): () => void {\n      return () => {\n        const schCxt = cxt.subschema({keyword}, schValid)\n        gen.assign(valid, schValid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n        if (ifClause) gen.assign(ifClause, _`${keyword}`)\n        else cxt.setParams({ifClause: keyword})\n      }\n    }\n  },\n}\n\nfunction hasSchema(it: SchemaObjCxt, keyword: string): boolean {\n  const schema = it.schema[keyword]\n  return schema !== undefined && !alwaysValidSchema(it, schema)\n}\n\nexport default def\n"],"names":[],"mappings":";;;;AAQA,MAAA;AACA,MAAA;AAIA,MAAM,QAAgC;IACpC,SAAS,CAAC,EAAC,MAAM,EAAC,GAAK,CAAA,GAAA,UAAA,GAAG,CAAA,CAAA,YAAA,EAAe,OAAO,QAAQ,CAAA,QAAA,CAAU;IAClE,QAAQ,CAAC,EAAC,MAAM,EAAC,GAAK,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,iBAAA,EAAoB,OAAO,QAAQ,CAAA,CAAA,CAAG;;AAG/D,MAAM,MAA6B;IACjC,SAAS;IACT,YAAY;QAAC;QAAU;KAAU;IACjC,aAAa;IACb;IACA,MAAK,GAAe;QAClB,MAAM,EAAC,GAAG,EAAE,YAAY,EAAE,EAAE,EAAC,GAAG;QAChC,IAAI,aAAa,IAAI,KAAK,aAAa,aAAa,IAAI,KAAK,WAAW;YACtE,CAAA,GAAA,OAAA,eAAe,EAAC,IAAI;QACtB;QACA,MAAM,UAAU,UAAU,IAAI;QAC9B,MAAM,UAAU,UAAU,IAAI;QAC9B,IAAI,CAAC,WAAW,CAAC,SAAS;QAE1B,MAAM,QAAQ,IAAI,GAAG,CAAC,SAAS;QAC/B,MAAM,WAAW,IAAI,IAAI,CAAC;QAC1B;QACA,IAAI,KAAK;QAET,IAAI,WAAW,SAAS;YACtB,MAAM,WAAW,IAAI,GAAG,CAAC;YACzB,IAAI,SAAS,CAAC;gBAAC;YAAQ;YACvB,IAAI,EAAE,CAAC,UAAU,eAAe,QAAQ,WAAW,eAAe,QAAQ;QAC5E,OAAO,IAAI,SAAS;YAClB,IAAI,EAAE,CAAC,UAAU,eAAe;QAClC,OAAO;YACL,IAAI,EAAE,CAAC,CAAA,GAAA,UAAA,GAAG,EAAC,WAAW,eAAe;QACvC;QAEA,IAAI,IAAI,CAAC,OAAO,IAAM,IAAI,KAAK,CAAC;QAEhC,SAAS;YACP,MAAM,SAAS,IAAI,SAAS,CAC1B;gBACE,SAAS;gBACT,eAAe;gBACf,cAAc;gBACd,WAAW;eAEb;YAEF,IAAI,cAAc,CAAC;QACrB;QAEA,SAAS,eAAe,OAAe,EAAE,QAAe;YACtD,OAAO;gBACL,MAAM,SAAS,IAAI,SAAS,CAAC;oBAAC;gBAAO,GAAG;gBACxC,IAAI,MAAM,CAAC,OAAO;gBAClB,IAAI,mBAAmB,CAAC,QAAQ;gBAChC,IAAI,UAAU,IAAI,MAAM,CAAC,UAAU,CAAA,GAAA,UAAA,CAAC,CAAA,CAAA,EAAG,QAAO,CAAE;qBAC3C,IAAI,SAAS,CAAC;oBAAC,UAAU;gBAAO;YACvC;QACF;IACF;;AAGF,SAAS,UAAU,EAAgB,EAAE,OAAe;IAClD,MAAM,SAAS,GAAG,MAAM,CAAC,QAAQ;IACjC,OAAO,WAAW,aAAa,CAAC,CAAA,GAAA,OAAA,iBAAiB,EAAC,IAAI;AACxD;AAEA,QAAA,OAAA,GAAe"}},
    {"offset": {"line": 5185, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5189, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/applicator/thenElse.ts"],"sourcesContent":["import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {checkStrictMode} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"then\", \"else\"],\n  schemaType: [\"object\", \"boolean\"],\n  code({keyword, parentSchema, it}: KeywordCxt) {\n    if (parentSchema.if === undefined) checkStrictMode(it, `\"${keyword}\" without \"if\" is ignored`)\n  },\n}\n\nexport default def\n"],"names":[],"mappings":";;;;AAEA,MAAA;AAEA,MAAM,MAA6B;IACjC,SAAS;QAAC;QAAQ;KAAO;IACzB,YAAY;QAAC;QAAU;KAAU;IACjC,MAAK,EAAC,OAAO,EAAE,YAAY,EAAE,EAAE,EAAa;QAC1C,IAAI,aAAa,EAAE,KAAK,WAAW,CAAA,GAAA,OAAA,eAAe,EAAC,IAAI,CAAA,CAAA,EAAI,QAAO,yBAAA,CAA2B;IAC/F;;AAGF,QAAA,OAAA,GAAe"}},
    {"offset": {"line": 5208, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5212, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/applicator/index.ts"],"sourcesContent":["import type {ErrorNoParams, Vocabulary} from \"../../types\"\nimport additionalItems, {AdditionalItemsError} from \"./additionalItems\"\nimport prefixItems from \"./prefixItems\"\nimport items from \"./items\"\nimport items2020, {ItemsError} from \"./items2020\"\nimport contains, {ContainsError} from \"./contains\"\nimport dependencies, {DependenciesError} from \"./dependencies\"\nimport propertyNames, {PropertyNamesError} from \"./propertyNames\"\nimport additionalProperties, {AdditionalPropertiesError} from \"./additionalProperties\"\nimport properties from \"./properties\"\nimport patternProperties from \"./patternProperties\"\nimport notKeyword, {NotKeywordError} from \"./not\"\nimport anyOf, {AnyOfError} from \"./anyOf\"\nimport oneOf, {OneOfError} from \"./oneOf\"\nimport allOf from \"./allOf\"\nimport ifKeyword, {IfKeywordError} from \"./if\"\nimport thenElse from \"./thenElse\"\n\nexport default function getApplicator(draft2020 = false): Vocabulary {\n  const applicator = [\n    // any\n    notKeyword,\n    anyOf,\n    oneOf,\n    allOf,\n    ifKeyword,\n    thenElse,\n    // object\n    propertyNames,\n    additionalProperties,\n    dependencies,\n    properties,\n    patternProperties,\n  ]\n  // array\n  if (draft2020) applicator.push(prefixItems, items2020)\n  else applicator.push(additionalItems, items)\n  applicator.push(contains)\n  return applicator\n}\n\nexport type ApplicatorKeywordError =\n  | ErrorNoParams<\"false schema\">\n  | AdditionalItemsError\n  | ItemsError\n  | ContainsError\n  | AdditionalPropertiesError\n  | DependenciesError\n  | IfKeywordError\n  | AnyOfError\n  | OneOfError\n  | NotKeywordError\n  | PropertyNamesError\n"],"names":[],"mappings":";;;;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AAEA,SAAwB,cAAc,YAAY,KAAK;IACrD,MAAM,aAAa;QACjB,MAAM;QACN,MAAA,OAAU;QACV,QAAA,OAAK;QACL,QAAA,OAAK;QACL,QAAA,OAAK;QACL,KAAA,OAAS;QACT,WAAA,OAAQ;QACR,SAAS;QACT,gBAAA,OAAa;QACb,uBAAA,OAAoB;QACpB,eAAA,OAAY;QACZ,aAAA,OAAU;QACV,oBAAA,OAAiB;KAClB;IACD,QAAQ;IACR,IAAI,WAAW,WAAW,IAAI,CAAC,cAAA,OAAW,EAAE,YAAA,OAAS;SAChD,WAAW,IAAI,CAAC,kBAAA,OAAe,EAAE,QAAA,OAAK;IAC3C,WAAW,IAAI,CAAC,WAAA,OAAQ;IACxB,OAAO;AACT;AArBA,QAAA,OAAA,GAAA"}},
    {"offset": {"line": 5255, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5259, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/format/format.ts"],"sourcesContent":["import type {\n  AddedFormat,\n  FormatValidator,\n  AsyncFormatValidator,\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, nil, or, Code, getProperty, regexpCode} from \"../../compile/codegen\"\n\ntype FormatValidate =\n  | FormatValidator<string>\n  | FormatValidator<number>\n  | AsyncFormatValidator<string>\n  | AsyncFormatValidator<number>\n  | RegExp\n  | string\n  | true\n\nexport type FormatError = ErrorObject<\"format\", {format: string}, string | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must match format \"${schemaCode}\"`,\n  params: ({schemaCode}) => _`{format: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"format\",\n  type: [\"number\", \"string\"],\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt, ruleType?: string) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    const {opts, errSchemaPath, schemaEnv, self} = it\n    if (!opts.validateFormats) return\n\n    if ($data) validate$DataFormat()\n    else validateFormat()\n\n    function validate$DataFormat(): void {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats,\n      })\n      const fDef = gen.const(\"fDef\", _`${fmts}[${schemaCode}]`)\n      const fType = gen.let(\"fType\")\n      const format = gen.let(\"format\")\n      // TODO simplify\n      gen.if(\n        _`typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`,\n        () => gen.assign(fType, _`${fDef}.type || \"string\"`).assign(format, _`${fDef}.validate`),\n        () => gen.assign(fType, _`\"string\"`).assign(format, fDef)\n      )\n      cxt.fail$data(or(unknownFmt(), invalidFmt()))\n\n      function unknownFmt(): Code {\n        if (opts.strictSchema === false) return nil\n        return _`${schemaCode} && !${format}`\n      }\n\n      function invalidFmt(): Code {\n        const callFormat = schemaEnv.$async\n          ? _`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`\n          : _`${format}(${data})`\n        const validData = _`(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`\n        return _`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`\n      }\n    }\n\n    function validateFormat(): void {\n      const formatDef: AddedFormat | undefined = self.formats[schema]\n      if (!formatDef) {\n        unknownFormat()\n        return\n      }\n      if (formatDef === true) return\n      const [fmtType, format, fmtRef] = getFormat(formatDef)\n      if (fmtType === ruleType) cxt.pass(validCondition())\n\n      function unknownFormat(): void {\n        if (opts.strictSchema === false) {\n          self.logger.warn(unknownMsg())\n          return\n        }\n        throw new Error(unknownMsg())\n\n        function unknownMsg(): string {\n          return `unknown format \"${schema as string}\" ignored in schema at path \"${errSchemaPath}\"`\n        }\n      }\n\n      function getFormat(fmtDef: AddedFormat): [string, FormatValidate, Code] {\n        const code =\n          fmtDef instanceof RegExp\n            ? regexpCode(fmtDef)\n            : opts.code.formats\n            ? _`${opts.code.formats}${getProperty(schema)}`\n            : undefined\n        const fmt = gen.scopeValue(\"formats\", {key: schema, ref: fmtDef, code})\n        if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n          return [fmtDef.type || \"string\", fmtDef.validate, _`${fmt}.validate`]\n        }\n\n        return [\"string\", fmtDef, fmt]\n      }\n\n      function validCondition(): Code {\n        if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n          if (!schemaEnv.$async) throw new Error(\"async format in sync schema\")\n          return _`await ${fmtRef}(${data})`\n        }\n        return typeof format == \"function\" ? _`${fmtRef}(${data})` : _`${fmtRef}.test(${data})`\n      }\n    }\n  },\n}\n\nexport default def\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5354, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5358, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/format/index.ts"],"sourcesContent":["import type {Vocabulary} from \"../../types\"\nimport formatKeyword from \"./format\"\n\nconst format: Vocabulary = [formatKeyword]\n\nexport default format\n"],"names":[],"mappings":";;;;AACA,MAAA;AAEA,MAAM,SAAqB;IAAC,SAAA,OAAa;CAAC;AAE1C,QAAA,OAAA,GAAe"}},
    {"offset": {"line": 5367, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5371, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/metadata.ts"],"sourcesContent":["import type {Vocabulary} from \"../types\"\n\nexport const metadataVocabulary: Vocabulary = [\n  \"title\",\n  \"description\",\n  \"default\",\n  \"deprecated\",\n  \"readOnly\",\n  \"writeOnly\",\n  \"examples\",\n]\n\nexport const contentVocabulary: Vocabulary = [\n  \"contentMediaType\",\n  \"contentEncoding\",\n  \"contentSchema\",\n]\n"],"names":[],"mappings":";;;;;AAEa,QAAA,kBAAkB,GAAe;IAC5C;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAEY,QAAA,iBAAiB,GAAe;IAC3C;IACA;IACA;CACD"}},
    {"offset": {"line": 5390, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5394, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/draft7.ts"],"sourcesContent":["import type {Vocabulary} from \"../types\"\nimport coreVocabulary from \"./core\"\nimport validationVocabulary from \"./validation\"\nimport getApplicatorVocabulary from \"./applicator\"\nimport formatVocabulary from \"./format\"\nimport {metadataVocabulary, contentVocabulary} from \"./metadata\"\n\nconst draft7Vocabularies: Vocabulary[] = [\n  coreVocabulary,\n  validationVocabulary,\n  getApplicatorVocabulary(),\n  formatVocabulary,\n  metadataVocabulary,\n  contentVocabulary,\n]\n\nexport default draft7Vocabularies\n"],"names":[],"mappings":";;;;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AAEA,MAAM,qBAAmC;IACvC,OAAA,OAAc;IACd,aAAA,OAAoB;IACpB,CAAA,GAAA,aAAA,OAAuB;IACvB,SAAA,OAAgB;IAChB,WAAA,kBAAkB;IAClB,WAAA,iBAAiB;CAClB;AAED,QAAA,OAAA,GAAe"}},
    {"offset": {"line": 5412, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5416, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/discriminator/types.ts"],"sourcesContent":["import type {ErrorObject} from \"../../types\"\n\nexport enum DiscrError {\n  Tag = \"tag\",\n  Mapping = \"mapping\",\n}\n\nexport type DiscrErrorObj<E extends DiscrError> = ErrorObject<\n  \"discriminator\",\n  {error: E; tag: string; tagValue: unknown},\n  string\n>\n"],"names":[],"mappings":";;;;;AAEA,IAAY;AAAZ,CAAA,SAAY,UAAU;IACpB,UAAA,CAAA,MAAA,GAAA;IACA,UAAA,CAAA,UAAA,GAAA;AACF,CAAC,EAHW,cAAU,CAAA,QAAA,UAAA,GAAV,aAAU,CAAA,CAAA"}},
    {"offset": {"line": 5426, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5430, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/vocabularies/discriminator/index.ts"],"sourcesContent":["import type {CodeKeywordDefinition, AnySchemaObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, getProperty, Name} from \"../../compile/codegen\"\nimport {DiscrError, DiscrErrorObj} from \"../discriminator/types\"\nimport {resolveRef, SchemaEnv} from \"../../compile\"\nimport MissingRefError from \"../../compile/ref_error\"\nimport {schemaHasRulesButRef} from \"../../compile/util\"\n\nexport type DiscriminatorError = DiscrErrorObj<DiscrError.Tag> | DiscrErrorObj<DiscrError.Mapping>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {discrError, tagName}}) =>\n    discrError === DiscrError.Tag\n      ? `tag \"${tagName}\" must be string`\n      : `value of tag \"${tagName}\" must be in oneOf`,\n  params: ({params: {discrError, tag, tagName}}) =>\n    _`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"discriminator\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, schema, parentSchema, it} = cxt\n    const {oneOf} = parentSchema\n    if (!it.opts.discriminator) {\n      throw new Error(\"discriminator: requires discriminator option\")\n    }\n    const tagName = schema.propertyName\n    if (typeof tagName != \"string\") throw new Error(\"discriminator: requires propertyName\")\n    if (schema.mapping) throw new Error(\"discriminator: mapping is not supported\")\n    if (!oneOf) throw new Error(\"discriminator: requires oneOf keyword\")\n    const valid = gen.let(\"valid\", false)\n    const tag = gen.const(\"tag\", _`${data}${getProperty(tagName)}`)\n    gen.if(\n      _`typeof ${tag} == \"string\"`,\n      () => validateMapping(),\n      () => cxt.error(false, {discrError: DiscrError.Tag, tag, tagName})\n    )\n    cxt.ok(valid)\n\n    function validateMapping(): void {\n      const mapping = getMapping()\n      gen.if(false)\n      for (const tagValue in mapping) {\n        gen.elseIf(_`${tag} === ${tagValue}`)\n        gen.assign(valid, applyTagSchema(mapping[tagValue]))\n      }\n      gen.else()\n      cxt.error(false, {discrError: DiscrError.Mapping, tag, tagName})\n      gen.endIf()\n    }\n\n    function applyTagSchema(schemaProp?: number): Name {\n      const _valid = gen.name(\"valid\")\n      const schCxt = cxt.subschema({keyword: \"oneOf\", schemaProp}, _valid)\n      cxt.mergeEvaluated(schCxt, Name)\n      return _valid\n    }\n\n    function getMapping(): {[T in string]?: number} {\n      const oneOfMapping: {[T in string]?: number} = {}\n      const topRequired = hasRequired(parentSchema)\n      let tagRequired = true\n      for (let i = 0; i < oneOf.length; i++) {\n        let sch = oneOf[i]\n        if (sch?.$ref && !schemaHasRulesButRef(sch, it.self.RULES)) {\n          const ref = sch.$ref\n          sch = resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref)\n          if (sch instanceof SchemaEnv) sch = sch.schema\n          if (sch === undefined) throw new MissingRefError(it.opts.uriResolver, it.baseId, ref)\n        }\n        const propSch = sch?.properties?.[tagName]\n        if (typeof propSch != \"object\") {\n          throw new Error(\n            `discriminator: oneOf subschemas (or referenced schemas) must have \"properties/${tagName}\"`\n          )\n        }\n        tagRequired = tagRequired && (topRequired || hasRequired(sch))\n        addMappings(propSch, i)\n      }\n      if (!tagRequired) throw new Error(`discriminator: \"${tagName}\" must be required`)\n      return oneOfMapping\n\n      function hasRequired({required}: AnySchemaObject): boolean {\n        return Array.isArray(required) && required.includes(tagName)\n      }\n\n      function addMappings(sch: AnySchemaObject, i: number): void {\n        if (sch.const) {\n          addMapping(sch.const, i)\n        } else if (sch.enum) {\n          for (const tagValue of sch.enum) {\n            addMapping(tagValue, i)\n          }\n        } else {\n          throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`)\n        }\n      }\n\n      function addMapping(tagValue: unknown, i: number): void {\n        if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n          throw new Error(`discriminator: \"${tagName}\" values must be unique strings`)\n        }\n        oneOfMapping[tagValue] = i\n      }\n    }\n  },\n}\n\nexport default def\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5536, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5544, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/ajv/lib/ajv.ts"],"sourcesContent":["import type {AnySchemaObject} from \"./types\"\nimport AjvCore from \"./core\"\nimport draft7Vocabularies from \"./vocabularies/draft7\"\nimport discriminator from \"./vocabularies/discriminator\"\nimport * as draft7MetaSchema from \"./refs/json-schema-draft-07.json\"\n\nconst META_SUPPORT_DATA = [\"/properties\"]\n\nconst META_SCHEMA_ID = \"http://json-schema.org/draft-07/schema\"\n\nexport class Ajv extends AjvCore {\n  _addVocabularies(): void {\n    super._addVocabularies()\n    draft7Vocabularies.forEach((v) => this.addVocabulary(v))\n    if (this.opts.discriminator) this.addKeyword(discriminator)\n  }\n\n  _addDefaultMetaSchema(): void {\n    super._addDefaultMetaSchema()\n    if (!this.opts.meta) return\n    const metaSchema = this.opts.$data\n      ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)\n      : draft7MetaSchema\n    this.addMetaSchema(metaSchema, META_SCHEMA_ID, false)\n    this.refs[\"http://json-schema.org/schema\"] = META_SCHEMA_ID\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    return (this.opts.defaultMeta =\n      super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined))\n  }\n}\n\nmodule.exports = exports = Ajv\nmodule.exports.Ajv = Ajv\nObject.defineProperty(exports, \"__esModule\", {value: true})\n\nexport default Ajv\n\nexport {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  SchemaValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n} from \"./types\"\n\nexport {Plugin, Options, CodeOptions, InstanceOptions, Logger, ErrorsTextOptions} from \"./core\"\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport {KeywordCxt} from \"./compile/validate\"\nexport {DefinedError} from \"./vocabularies/errors\"\nexport {JSONType} from \"./compile/rules\"\nexport {JSONSchemaType} from \"./types/json-schema\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\nexport {default as ValidationError} from \"./runtime/validation_error\"\nexport {default as MissingRefError} from \"./compile/ref_error\"\n"],"names":[],"mappings":";;;;;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AAEA,MAAM,oBAAoB;IAAC;CAAc;AAEzC,MAAM,iBAAiB;AAEvB,MAAa,YAAY,OAAA,OAAO;IAC9B,mBAAgB;QACd,KAAK,CAAC;QACN,SAAA,OAAkB,CAAC,OAAO,CAAC,CAAC,IAAM,IAAI,CAAC,aAAa,CAAC;QACrD,IAAI,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,IAAI,CAAC,UAAU,CAAC,gBAAA,OAAa;IAC5D;IAEA,wBAAqB;QACnB,KAAK,CAAC;QACN,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;QACrB,MAAM,aAAa,IAAI,CAAC,IAAI,CAAC,KAAK,GAC9B,IAAI,CAAC,eAAe,CAAC,kBAAkB,qBACvC;QACJ,IAAI,CAAC,aAAa,CAAC,YAAY,gBAAgB;QAC/C,IAAI,CAAC,IAAI,CAAC,gCAAgC,GAAG;IAC/C;IAEA,cAAW;QACT,OAAQ,IAAI,CAAC,IAAI,CAAC,WAAW,GAC3B,KAAK,CAAC,iBAAiB,CAAC,IAAI,CAAC,SAAS,CAAC,kBAAkB,iBAAiB,SAAS;IACvF;;AApBF,QAAA,GAAA,GAAA;AAuBA,OAAO,OAAO,GAAG,UAAU;AAC3B,OAAO,OAAO,CAAC,GAAG,GAAG;AACrB,OAAO,cAAc,CAAC,SAAS,cAAc;IAAC,OAAO;AAAI;AAEzD,QAAA,OAAA,GAAe;AA0Bf,IAAA;AAAQ,OAAA,cAAA,CAAA,SAAA,cAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,WAAA,UAAU;IAAA;AAAA;AAIlB,IAAA;AAAQ,OAAA,cAAA,CAAA,SAAA,KAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,UAAA,CAAC;IAAA;AAAA;AAAE,OAAA,cAAA,CAAA,SAAA,OAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,UAAA,GAAG;IAAA;AAAA;AAAE,OAAA,cAAA,CAAA,SAAA,aAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,UAAA,SAAS;IAAA;AAAA;AAAE,OAAA,cAAA,CAAA,SAAA,OAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,UAAA,GAAG;IAAA;AAAA;AAAE,OAAA,cAAA,CAAA,SAAA,QAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,UAAA,IAAI;IAAA;AAAA;AAAQ,OAAA,cAAA,CAAA,SAAA,WAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,UAAA,OAAO;IAAA;AAAA;AACnD,IAAA;AAAQ,OAAA,cAAA,CAAA,SAAA,mBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,mBAAA,OAAO;IAAA;AAAA;AACf,IAAA;AAAQ,OAAA,cAAA,CAAA,SAAA,mBAAA;IAAA,YAAA;IAAA,KAAA;QAAA,OAAA,YAAA,OAAO;IAAA;AAAA"}},
    {"offset": {"line": 5639, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}