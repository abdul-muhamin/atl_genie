{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk-core/src/internal/utils/string.ts"],"sourcesContent":["import {Buffer} from 'buffer';\n\nexport const decodeFromBase64 = (base64: string) => {\n  return Buffer.from(base64, 'base64').toString('utf8');\n};\n\nexport const encodeToBase64 = (str: string) => {\n  return Buffer.from(str, 'utf-8').toString('base64');\n};\n"],"names":[],"mappings":";;;;;AAAA,MAAA;AAEO,MAAM,mBAAmB,CAAC;IAC/B,OAAO,SAAA,MAAM,CAAC,IAAI,CAAC,QAAQ,UAAU,QAAQ,CAAC;AAChD;AAFa,QAAA,gBAAgB,GAAA;AAItB,MAAM,iBAAiB,CAAC;IAC7B,OAAO,SAAA,MAAM,CAAC,IAAI,CAAC,KAAK,SAAS,QAAQ,CAAC;AAC5C;AAFa,QAAA,cAAc,GAAA"}},
    {"offset": {"line": 18, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 22, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk-core/src/internal/utils/validators.ts"],"sourcesContent":["import {InvalidArgumentError} from '../../errors';\nimport {ExpiresIn} from '../../utils';\nimport {decodeFromBase64, encodeToBase64} from './string';\n\nexport function validateStoreName(name: string) {\n  if (isEmpty(name)) {\n    throw new InvalidArgumentError('store name must not be empty');\n  }\n}\n\nexport function validateCacheName(name: string) {\n  if (isEmpty(name)) {\n    throw new InvalidArgumentError('cache name must not be empty');\n  }\n}\n\nexport function validateCacheKeyOrPrefix(name: string) {\n  if (isEmpty(name)) {\n    throw new InvalidArgumentError('cache key or key prefix must not be empty');\n  }\n}\n\nexport function validateSetName(name: string) {\n  if (isEmpty(name)) {\n    throw new InvalidArgumentError('set name must not be empty');\n  }\n}\n\nexport function validateSetSampleLimit(limit: number) {\n  if (limit < 0) {\n    throw new InvalidArgumentError('limit must be non-negative (>= 0)');\n  }\n}\n\nexport function validateSetPopCount(count: number) {\n  if (count < 1) {\n    throw new InvalidArgumentError('count must be positive (> 0)');\n  }\n}\n\nexport function validateSortedSetName(name: string) {\n  if (isEmpty(name)) {\n    throw new InvalidArgumentError('sorted set name must not be empty');\n  }\n}\n\nexport function validateSortedSetRanks(start_rank: number, end_rank?: number) {\n  if (end_rank === undefined) {\n    return;\n  }\n  if (start_rank > 0 && end_rank > 0 && start_rank > end_rank) {\n    throw new InvalidArgumentError('start rank must be less than end rank');\n  }\n  if (start_rank < 0 && end_rank < 0 && start_rank >= end_rank) {\n    throw new InvalidArgumentError(\n      'negative start rank must be less than negative end rank'\n    );\n  }\n}\n\nexport function validateSortedSetScores(minScore?: number, maxScore?: number) {\n  if (minScore === undefined) return;\n  if (maxScore === undefined) return;\n  if (minScore > maxScore) {\n    throw new InvalidArgumentError(\n      'minScore must be less than or equal to maxScore'\n    );\n  }\n}\n\nexport function validateSortedSetOffset(offset: number) {\n  if (offset < 0) {\n    throw new InvalidArgumentError('offset must be non-negative (>= 0)');\n  }\n}\n\nexport function validateSortedSetCount(count: number) {\n  if (count < 1) {\n    throw new InvalidArgumentError('count must be strictly positive (> 0)');\n  }\n}\n\nexport function validateDictionaryName(name: string) {\n  if (isEmpty(name)) {\n    throw new InvalidArgumentError('dictionary name must not be empty');\n  }\n}\n\nexport function validateListName(name: string) {\n  if (isEmpty(name)) {\n    throw new InvalidArgumentError('list name must not be empty');\n  }\n}\n\nexport function validateListSliceStartEnd(\n  startIndex?: number,\n  endIndex?: number\n) {\n  if (startIndex === undefined || endIndex === undefined) return;\n  // can't validate bounds for start and index of either or are negative without list length\n  if (startIndex > 0 || endIndex < 0) return;\n  if (endIndex <= startIndex) {\n    throw new InvalidArgumentError(\n      'endIndex (exclusive) must be larger than startIndex (inclusive)'\n    );\n  }\n}\n\nexport function validateTopicName(name: string) {\n  if (isEmpty(name)) {\n    throw new InvalidArgumentError('topic name must not be empty');\n  }\n}\n\nexport function validateWebhookName(name: string) {\n  if (isEmpty(name)) {\n    throw new InvalidArgumentError('webhook name must not be empty');\n  }\n}\n\nexport function validateIndexName(name: string) {\n  if (isEmpty(name)) {\n    throw new InvalidArgumentError('index name must not be empty');\n  }\n}\n\nexport function validateNumDimensions(numDimensions: number) {\n  if (numDimensions <= 0) {\n    throw new InvalidArgumentError('numDimensions must be greater than zero');\n  }\n}\n\nexport function validateTopK(topK: number) {\n  if (topK <= 0) {\n    throw new InvalidArgumentError('topK must be greater than zero');\n  }\n}\n\nexport function validateTtlMinutes(ttlMinutes: number) {\n  if (ttlMinutes < 0 || !Number.isSafeInteger(ttlMinutes)) {\n    throw new InvalidArgumentError('ttlMinutes must be a positive integer');\n  }\n}\n\n// Currently accepting ttl in seconds, but if someone requests support for millis,\n// the validator will need to check for Number.isSafeInteger(ttl * 1000).\nexport function validateTtlSeconds(ttl: number) {\n  if (ttl < 0 || !Number.isSafeInteger(ttl)) {\n    throw new InvalidArgumentError(\n      `ttl must be a positive integer, received ${ttl}`\n    );\n  }\n}\n\nexport function validateValidForSeconds(validForSeconds: number) {\n  if (validForSeconds < 0) {\n    throw new InvalidArgumentError('validForSeconds must be positive');\n  }\n}\n\nexport function validateTimeout(timeout: number) {\n  if (timeout < 0) {\n    throw new InvalidArgumentError('timeout must be positive');\n  }\n}\n\nexport function validateDisposableTokenExpiry(expiresIn: ExpiresIn) {\n  if (!expiresIn.doesExpire()) {\n    throw new InvalidArgumentError('disposable tokens must have an expiry');\n  }\n  if (expiresIn.seconds() < 0) {\n    throw new InvalidArgumentError('disposable token expiry must be positive');\n  }\n  if (expiresIn.seconds() > 60 * 60) {\n    // 60 seconds * 60 minutes\n    throw new InvalidArgumentError(\n      'disposable tokens must expire within 1 hour'\n    );\n  }\n}\n\nexport function validateDisposableTokenTokenID(tokenId: string) {\n  if (tokenId.length > 64) {\n    throw new InvalidArgumentError(\n      'TokenID must be less than or equal to 64 characters.'\n    );\n  }\n}\n\nfunction isEmpty(str: string): boolean {\n  return !str.trim();\n}\n\nexport function isBase64(str: string): boolean {\n  try {\n    return encodeToBase64(decodeFromBase64(str)) === str;\n  } catch (e) {\n    return false;\n  }\n}\n\nexport function validateLeaderboardName(name: string) {\n  if (isEmpty(name)) {\n    throw new InvalidArgumentError('leaderboard name must not be empty');\n  }\n}\n\nexport function validateLeaderboardRanks(start_rank: number, end_rank: number) {\n  if (start_rank > 0 && end_rank > 0 && start_rank >= end_rank) {\n    throw new InvalidArgumentError('start rank must be less than end rank');\n  }\n  if (start_rank < 0 || end_rank < 0) {\n    throw new InvalidArgumentError('ranks must be positive');\n  }\n}\n\nexport function validateLeaderboardOffset(offset: number) {\n  if (offset < 0) {\n    throw new InvalidArgumentError('offset must be non-negative (>= 0)');\n  }\n}\n\nexport function validateLeaderboardCount(count: number) {\n  if (count < 1) {\n    throw new InvalidArgumentError('count must be strictly positive (> 0)');\n  }\n}\n\nexport function validateLeaderboardNumberOfElements(numElements: number) {\n  if (numElements < 1) {\n    throw new InvalidArgumentError('must provide at least one element');\n  }\n}\n\nexport function validateMaxConcurrentRequests(limit: number) {\n  if (limit < 1) {\n    throw new InvalidArgumentError(\n      'concurrent requests limit must be strictly positive (> 0)'\n    );\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 249, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 253, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk-core/src/internal/utils/auth.ts"],"sourcesContent":["import {InvalidArgumentError} from '../../errors';\nimport jwtDecode from 'jwt-decode';\nimport {isBase64} from './validators';\nimport {decodeFromBase64} from './string';\nimport {PredefinedScope} from '../../auth/tokens/permission-scope';\nimport {BaseEndpointOverride} from '../../auth';\n\nexport interface LegacyClaims {\n  /**\n   * control plane endpoint\n   */\n  cp: string;\n  /**\n   * cache endpoint\n   */\n  c: string;\n}\n\nexport interface Base64DecodedV1Token {\n  api_key: string;\n  endpoint: string;\n}\n\nfunction decodeAuthTokenClaims<T>(authToken: string): T {\n  return jwtDecode<T>(authToken);\n}\n\ninterface TokenAndEndpoints {\n  // If we decode a JWT that doesn't actually have the controlEndpoint/cacheEndpoint claims, then they will come back\n  // as undefined; thus we need the types here to be `string | undefined`.\n  controlEndpoint: string | undefined;\n  cacheEndpoint: string | undefined;\n  tokenEndpoint: string | undefined;\n  storageEndpoint: string | undefined;\n  authToken: string;\n}\n\nexport interface Endpoint {\n  endpoint: string;\n  secureConnection?: boolean;\n}\n\nexport interface AllEndpoints {\n  controlEndpoint: Endpoint;\n  cacheEndpoint: Endpoint;\n  tokenEndpoint: Endpoint;\n  storageEndpoint: Endpoint;\n}\n\nexport function populateAllEndpointsFromBaseEndpoint(\n  endpointOverride: BaseEndpointOverride\n): AllEndpoints {\n  let prefix = '';\n  if (endpointOverride.endpointPrefix) {\n    prefix = `${endpointOverride.endpointPrefix}.`;\n  }\n  return {\n    controlEndpoint: {\n      endpoint: `${prefix}control.${endpointOverride.baseEndpoint}`,\n      secureConnection: endpointOverride.secureConnection,\n    },\n    cacheEndpoint: {\n      endpoint: `${prefix}cache.${endpointOverride.baseEndpoint}`,\n      secureConnection: endpointOverride.secureConnection,\n    },\n    tokenEndpoint: {\n      endpoint: `${prefix}token.${endpointOverride.baseEndpoint}`,\n      secureConnection: endpointOverride.secureConnection,\n    },\n    storageEndpoint: {\n      endpoint: `${prefix}storage.${endpointOverride.baseEndpoint}`,\n      secureConnection: endpointOverride.secureConnection,\n    },\n  };\n}\n\n/**\n * @param {string} token\n * @returns TokenAndEndpoints\n */\nexport const decodeAuthToken = (token?: string): TokenAndEndpoints => {\n  if (!token) {\n    throw new InvalidArgumentError('malformed auth token');\n  }\n\n  try {\n    // v1 api tokens don't have an endpoint as part of their claims. Instead, when the SDK returns tokens, we\n    // give it to them as a base64 encoded string of '{ \"api_key\": \"<the key>\", \"endpoint\": \"prod.momentohq.com\" }'.\n    // Since in the near future, most customers are going to be using these newer tokens, we are first checking to see if\n    // they are base64 encoded, which will tell us that they are our v1 api tokens. If its not, we will fall back to decoding\n    // it as one of our legacy jwts.\n    if (isBase64(token)) {\n      const base64DecodedToken = JSON.parse(\n        decodeFromBase64(token)\n      ) as Base64DecodedV1Token;\n      if (!base64DecodedToken.endpoint || !base64DecodedToken.api_key) {\n        throw new InvalidArgumentError('failed to parse token');\n      }\n      const endpoints = populateAllEndpointsFromBaseEndpoint({\n        baseEndpoint: base64DecodedToken.endpoint,\n      });\n      return {\n        controlEndpoint: endpoints.controlEndpoint.endpoint,\n        cacheEndpoint: endpoints.cacheEndpoint.endpoint,\n        tokenEndpoint: endpoints.tokenEndpoint.endpoint,\n        storageEndpoint: endpoints.storageEndpoint.endpoint,\n        authToken: base64DecodedToken.api_key,\n      };\n    } else {\n      // This decode function uses generics to advertise that we will usually expect to find the LegacyClaims.  However,\n      // if the token is a valid JWT but not actually one of our legacy tokens, the endpoint claims will be undefined,\n      // which is why the return type for this function specifies that the controlEndpoint/cacheEndpoint may be undefined.\n      const decodedLegacyToken = decodeAuthTokenClaims<LegacyClaims>(token);\n      return {\n        controlEndpoint: decodedLegacyToken.cp,\n        cacheEndpoint: decodedLegacyToken.c,\n        tokenEndpoint: decodedLegacyToken.c,\n        storageEndpoint: decodedLegacyToken.c,\n        authToken: token,\n      };\n    }\n  } catch (e) {\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    throw new InvalidArgumentError(`failed to parse token: ${e}`);\n  }\n};\n\nexport class InternalSuperUserPermissions extends PredefinedScope {}\n"],"names":[],"mappings":";;;;;AAAA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AAmBA,SAAS,sBAAyB,SAAiB;IACjD,OAAO,CAAA,GAAA,aAAA,OAAS,EAAI;AACtB;AAwBA,SAAgB,qCACd,gBAAsC;IAEtC,IAAI,SAAS;IACb,IAAI,iBAAiB,cAAc,EAAE;QACnC,SAAS,CAAA,EAAG,iBAAiB,cAAc,CAAA,CAAA,CAAG;;IAEhD,OAAO;QACL,iBAAiB;YACf,UAAU,CAAA,EAAG,OAAM,QAAA,EAAW,iBAAiB,YAAY,CAAA,CAAE;YAC7D,kBAAkB,iBAAiB,gBAAgB;;QAErD,eAAe;YACb,UAAU,CAAA,EAAG,OAAM,MAAA,EAAS,iBAAiB,YAAY,CAAA,CAAE;YAC3D,kBAAkB,iBAAiB,gBAAgB;;QAErD,eAAe;YACb,UAAU,CAAA,EAAG,OAAM,MAAA,EAAS,iBAAiB,YAAY,CAAA,CAAE;YAC3D,kBAAkB,iBAAiB,gBAAgB;;QAErD,iBAAiB;YACf,UAAU,CAAA,EAAG,OAAM,QAAA,EAAW,iBAAiB,YAAY,CAAA,CAAE;YAC7D,kBAAkB,iBAAiB,gBAAgB;;;AAGzD;AAzBA,QAAA,oCAAA,GAAA;AA2BA;;;IAIO,MAAM,kBAAkB,CAAC;IAC9B,IAAI,CAAC,OAAO;QACV,MAAM,IAAI,SAAA,oBAAoB,CAAC;;IAGjC,IAAI;QACF,yGAAyG;QACzG,gHAAgH;QAChH,qHAAqH;QACrH,yHAAyH;QACzH,gCAAgC;QAChC,IAAI,CAAA,GAAA,aAAA,QAAQ,EAAC,QAAQ;YACnB,MAAM,qBAAqB,KAAK,KAAK,CACnC,CAAA,GAAA,SAAA,gBAAgB,EAAC;YAEnB,IAAI,CAAC,mBAAmB,QAAQ,IAAI,CAAC,mBAAmB,OAAO,EAAE;gBAC/D,MAAM,IAAI,SAAA,oBAAoB,CAAC;;YAEjC,MAAM,YAAY,qCAAqC;gBACrD,cAAc,mBAAmB,QAAQ;;YAE3C,OAAO;gBACL,iBAAiB,UAAU,eAAe,CAAC,QAAQ;gBACnD,eAAe,UAAU,aAAa,CAAC,QAAQ;gBAC/C,eAAe,UAAU,aAAa,CAAC,QAAQ;gBAC/C,iBAAiB,UAAU,eAAe,CAAC,QAAQ;gBACnD,WAAW,mBAAmB,OAAO;;eAElC;YACL,kHAAkH;YAClH,gHAAgH;YAChH,oHAAoH;YACpH,MAAM,qBAAqB,sBAAoC;YAC/D,OAAO;gBACL,iBAAiB,mBAAmB,EAAE;gBACtC,eAAe,mBAAmB,CAAC;gBACnC,eAAe,mBAAmB,CAAC;gBACnC,iBAAiB,mBAAmB,CAAC;gBACrC,WAAW;;;MAGf,OAAO,GAAG;QACV,4EAA4E;QAC5E,MAAM,IAAI,SAAA,oBAAoB,CAAC,CAAA,uBAAA,EAA0B,EAAC,CAAE;;AAEhE;AA7Ca,QAAA,eAAe,GAAA;AA+C5B,MAAa,qCAAqC,mBAAA,eAAe;;AAAjE,QAAA,4BAAA,GAAA"}},
    {"offset": {"line": 341, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 345, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk-core/src/internal/utils/collections.ts"],"sourcesContent":["export function range(n: number): Array<number> {\n  return [...Array(n).keys()];\n}\n"],"names":[],"mappings":";;;;;AAAA,SAAgB,MAAM,CAAS;IAC7B,OAAO;WAAI,MAAM,GAAG,IAAI;KAAG;AAC7B;AAFA,QAAA,KAAA,GAAA"}},
    {"offset": {"line": 356, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 360, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk-core/src/internal/utils/display.ts"],"sourcesContent":["// Utility functions related to displaying things to the user.\n\nexport function truncateString(value: string, maxLength = 32) {\n  if (value.length > maxLength) {\n    return value.substring(0, maxLength) + '...';\n  } else {\n    return value;\n  }\n}\n\nconst DISPLAY_SIZE_LIMIT = 5;\n\nfunction truncateStringArrayToSize(\n  stringArray: string[],\n  length: number\n): string[] {\n  if (stringArray.length <= length) {\n    return stringArray;\n  } else {\n    return stringArray.slice(0, length).concat(['...']);\n  }\n}\n\nexport function truncateStringArray(\n  stringArray: string[],\n  length: number = DISPLAY_SIZE_LIMIT\n): string[] {\n  const truncatedStringArray = truncateStringArrayToSize(stringArray, length);\n  return truncatedStringArray.map(s => {\n    return truncateString(s);\n  });\n}\n"],"names":[],"mappings":";AAAA,8DAA8D;;;;;AAE9D,SAAgB,eAAe,KAAa,EAAE,YAAY,EAAE;IAC1D,IAAI,MAAM,MAAM,GAAG,WAAW;QAC5B,OAAO,MAAM,SAAS,CAAC,GAAG,aAAa;WAClC;QACL,OAAO;;AAEX;AANA,QAAA,cAAA,GAAA;AAQA,MAAM,qBAAqB;AAE3B,SAAS,0BACP,WAAqB,EACrB,MAAc;IAEd,IAAI,YAAY,MAAM,IAAI,QAAQ;QAChC,OAAO;WACF;QACL,OAAO,YAAY,KAAK,CAAC,GAAG,QAAQ,MAAM,CAAC;YAAC;SAAM;;AAEtD;AAEA,SAAgB,oBACd,WAAqB,EACrB,SAAiB,kBAAkB;IAEnC,MAAM,uBAAuB,0BAA0B,aAAa;IACpE,OAAO,qBAAqB,GAAG,CAAC,CAAA;QAC9B,OAAO,eAAe;IACxB;AACF;AARA,QAAA,mBAAA,GAAA"}},
    {"offset": {"line": 391, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 395, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk-core/src/internal/utils/object.ts"],"sourcesContent":["export function fromEntries(entries: [string, unknown][]): object {\n  return entries.reduce((acc, [key, value]) => ({...acc, [key]: value}), {});\n}\n"],"names":[],"mappings":";;;;;AAAA,SAAgB,YAAY,OAA4B;IACtD,OAAO,QAAQ,MAAM,CAAC,CAAC,KAAK,CAAC,KAAK,MAAM,GAAK,CAAC;YAAC,GAAG,GAAG;YAAE,CAAC,IAAI,EAAE;QAAK,CAAC,GAAG,CAAA;AACzE;AAFA,QAAA,WAAA,GAAA"}},
    {"offset": {"line": 407, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 411, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk-core/src/internal/utils/sleep.ts"],"sourcesContent":["export const sleep = (ms: number) => new Promise(r => setTimeout(r, ms));\n"],"names":[],"mappings":";;;;;AAAO,MAAM,QAAQ,CAAC,KAAe,IAAI,QAAQ,CAAA,IAAK,WAAW,GAAG;AAAvD,QAAA,KAAK,GAAA"}},
    {"offset": {"line": 418, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 422, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk-core/src/internal/utils/semaphore.ts"],"sourcesContent":["// Source: https://gist.github.com/gregkorossy/e33be1f201cf242197d9c4d0a1fa7335\n\nexport class Semaphore {\n  private counter = 0;\n  private waiting: {\n    resolve: (value?: unknown) => void;\n    err: (reason?: string) => void;\n  }[] = [];\n  private max: number;\n\n  constructor(max: number) {\n    this.max = max;\n  }\n\n  public take(): void {\n    if (this.waiting.length > 0 && this.counter < this.max) {\n      this.counter += 1;\n      const promise = this.waiting.shift();\n      if (promise) {\n        promise.resolve();\n      }\n    }\n  }\n\n  public acquire(): Promise<unknown> {\n    if (this.counter < this.max) {\n      this.counter += 1;\n      return new Promise(resolve => {\n        resolve(undefined);\n      });\n    }\n    return new Promise((resolve, err) => {\n      this.waiting.push({resolve, err});\n    });\n  }\n\n  public release(): void {\n    this.counter -= 1;\n    this.take();\n  }\n\n  public purge(): number {\n    const unresolved = this.waiting.length;\n\n    for (let i = 0; i < unresolved; i += 1) {\n      this.waiting[i].err('Task has been purged.');\n    }\n\n    this.counter = 0;\n    this.waiting = [];\n\n    return unresolved;\n  }\n}\n"],"names":[],"mappings":";AAAA,+EAA+E;;;;;AAE/E,MAAa;IAQX,YAAY,GAAW,CAAA;QAPf,IAAA,CAAA,OAAO,GAAG;QACV,IAAA,CAAA,OAAO,GAGT,EAAE;QAIN,IAAI,CAAC,GAAG,GAAG;IACb;IAEO,OAAI;QACT,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,KAAK,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,GAAG,EAAE;YACtD,IAAI,CAAC,OAAO,IAAI;YAChB,MAAM,UAAU,IAAI,CAAC,OAAO,CAAC,KAAK;YAClC,IAAI,SAAS;gBACX,QAAQ,OAAO;;;IAGrB;IAEO,UAAO;QACZ,IAAI,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,GAAG,EAAE;YAC3B,IAAI,CAAC,OAAO,IAAI;YAChB,OAAO,IAAI,QAAQ,CAAA;gBACjB,QAAQ;YACV;;QAEF,OAAO,IAAI,QAAQ,CAAC,SAAS;YAC3B,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC;gBAAC;gBAAS;YAAG;QACjC;IACF;IAEO,UAAO;QACZ,IAAI,CAAC,OAAO,IAAI;QAChB,IAAI,CAAC,IAAI;IACX;IAEO,QAAK;QACV,MAAM,aAAa,IAAI,CAAC,OAAO,CAAC,MAAM;QAEtC,IAAK,IAAI,IAAI,GAAG,IAAI,YAAY,KAAK,EAAG;YACtC,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,GAAG,CAAC;;QAGtB,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,OAAO,GAAG,EAAE;QAEjB,OAAO;IACT;;AAlDF,QAAA,SAAA,GAAA"}},
    {"offset": {"line": 472, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 476, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk-core/src/internal/utils/index.ts"],"sourcesContent":["export * from './auth';\nexport * from './collections';\nexport * from './display';\nexport * from './object';\nexport * from './sleep';\nexport * from './string';\nexport * from './validators';\nexport * from './semaphore';\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA,2IAAA;AACA,kJAAA;AACA,8IAAA;AACA,6IAAA;AACA,4IAAA;AACA,6IAAA;AACA,iJAAA;AACA,gJAAA"}},
    {"offset": {"line": 507, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 511, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk-core/src/internal/clients/cache/momento-cache.ts"],"sourcesContent":["import {\n  CacheDelete,\n  CacheGet,\n  CacheIncrement,\n  CacheSet,\n  CacheSetIfNotExists,\n  CacheSetIfAbsent,\n  CacheSetIfPresent,\n  CacheSetIfEqual,\n  CacheSetIfNotEqual,\n  CacheSetIfPresentAndNotEqual,\n  CacheSetIfAbsentOrEqual,\n  CacheSetFetch,\n  CacheSetAddElements,\n  CacheSetAddElement,\n  CacheSetContainsElement,\n  CacheSetContainsElements,\n  CacheSetRemoveElements,\n  CacheSetRemoveElement,\n  CacheListFetch,\n  CacheListLength,\n  CacheListPushFront,\n  CacheListPushBack,\n  CacheListConcatenateBack,\n  CacheListConcatenateFront,\n  CacheListPopBack,\n  CacheListPopFront,\n  CacheListRemoveValue,\n  CacheListRetain,\n  CacheDictionarySetField,\n  CacheDictionarySetFields,\n  CacheDictionaryGetField,\n  CacheDictionaryFetch,\n  CacheDictionaryIncrement,\n  CacheDictionaryRemoveField,\n  CacheDictionaryRemoveFields,\n  CacheSortedSetFetch,\n  CacheSortedSetPutElement,\n  CacheSortedSetPutElements,\n  CacheSortedSetGetRank,\n  CacheSortedSetGetScore,\n  CacheSortedSetGetScores,\n  CacheSortedSetIncrementScore,\n  CacheSortedSetRemoveElement,\n  CacheSortedSetLength,\n  CacheSortedSetLengthByScore,\n  CacheItemGetType,\n  CacheItemGetTtl,\n  CacheKeyExists,\n  CacheKeysExist,\n  CacheUpdateTtl,\n  CacheIncreaseTtl,\n  CacheDecreaseTtl,\n  ICacheClient,\n  CacheSortedSetRemoveElements,\n  CacheDictionaryGetFields,\n  CacheDictionaryLength,\n  CacheGetBatch,\n  CacheSetBatch,\n  CacheSetSample,\n  CacheSetPop,\n  CacheSetLength,\n} from '../../../index';\nimport {\n  ScalarCallOptions,\n  ListFetchCallOptions,\n  ListRetainCallOptions,\n  BackTruncatableCallOptions,\n  FrontTruncatableCallOptions,\n  CollectionCallOptions,\n  SortedSetFetchByRankCallOptions,\n  SortedSetFetchByScoreCallOptions,\n  SortedSetLengthByScoreCallOptions,\n  SetBatchItem,\n} from '../../../utils';\nimport {IMomentoCache} from '../../../clients/IMomentoCache';\n\n// Type aliases to differentiate the different methods' optional arguments.\nexport type SetOptions = ScalarCallOptions;\nexport type SetIfNotExistsOptions = ScalarCallOptions;\nexport type SetIfAbsentOptions = ScalarCallOptions;\nexport type SetIfPresentOptions = ScalarCallOptions;\nexport type SetIfEqualOptions = ScalarCallOptions;\nexport type SetIfNotEqualOptions = ScalarCallOptions;\nexport type SetIfPresentAndNotEqualOptions = ScalarCallOptions;\nexport type SetIfAbsentOrEqualOptions = ScalarCallOptions;\nexport type SetBatchOptions = ScalarCallOptions;\nexport type ListConcatenateBackOptions = FrontTruncatableCallOptions;\nexport type ListConcatenateFrontOptions = BackTruncatableCallOptions;\nexport type ListPushBackOptions = FrontTruncatableCallOptions;\nexport type ListPushFrontOptions = BackTruncatableCallOptions;\nexport type SetAddElementOptions = CollectionCallOptions;\nexport type SetAddElementsOptions = CollectionCallOptions;\nexport type DictionarySetFieldOptions = CollectionCallOptions;\nexport type DictionarySetFieldsOptions = CollectionCallOptions;\nexport type DictionaryIncrementOptions = CollectionCallOptions;\nexport type IncrementOptions = ScalarCallOptions;\nexport type SortedSetPutElementOptions = CollectionCallOptions;\nexport type SortedSetPutElementsOptions = CollectionCallOptions;\nexport type SortedSetFetchByRankOptions = SortedSetFetchByRankCallOptions;\nexport type SortedSetFetchByScoreOptions = SortedSetFetchByScoreCallOptions;\nexport type SortedSetIncrementOptions = CollectionCallOptions;\nexport type SortedSetLengthByScoreOptions = SortedSetLengthByScoreCallOptions;\n\nexport class MomentoCache implements IMomentoCache {\n  private readonly cacheClient: ICacheClient;\n  private readonly cacheName: string;\n  constructor(cacheClient: ICacheClient, cacheName: string) {\n    this.cacheClient = cacheClient;\n    this.cacheName = cacheName;\n  }\n\n  get(key: string | Uint8Array): Promise<CacheGet.Response> {\n    return this.cacheClient.get(this.cacheName, key);\n  }\n  set(\n    key: string | Uint8Array,\n    value: string | Uint8Array,\n    options?: SetOptions\n  ): Promise<CacheSet.Response> {\n    return this.cacheClient.set(this.cacheName, key, value, options);\n  }\n  delete(key: string | Uint8Array): Promise<CacheDelete.Response> {\n    return this.cacheClient.delete(this.cacheName, key);\n  }\n  increment(\n    field: string | Uint8Array,\n    amount: number,\n    options?: IncrementOptions\n  ): Promise<CacheIncrement.Response> {\n    return this.cacheClient.increment(this.cacheName, field, amount, options);\n  }\n  setIfNotExists(\n    key: string | Uint8Array,\n    field: string | Uint8Array,\n    options?: SetIfNotExistsOptions\n  ): Promise<CacheSetIfNotExists.Response> {\n    return this.cacheClient.setIfNotExists(this.cacheName, key, field, options);\n  }\n  setIfAbsent(\n    key: string | Uint8Array,\n    field: string | Uint8Array,\n    options?: SetIfAbsentOptions\n  ): Promise<CacheSetIfAbsent.Response> {\n    return this.cacheClient.setIfAbsent(this.cacheName, key, field, options);\n  }\n  setIfPresent(\n    key: string | Uint8Array,\n    value: string | Uint8Array,\n    options?: SetIfPresentOptions\n  ): Promise<CacheSetIfPresent.Response> {\n    return this.cacheClient.setIfPresent(this.cacheName, key, value, options);\n  }\n  setIfEqual(\n    key: string | Uint8Array,\n    value: string | Uint8Array,\n    equal: string | Uint8Array,\n    options?: SetIfEqualOptions\n  ): Promise<CacheSetIfEqual.Response> {\n    return this.cacheClient.setIfEqual(\n      this.cacheName,\n      key,\n      value,\n      equal,\n      options\n    );\n  }\n  setIfNotEqual(\n    key: string | Uint8Array,\n    value: string | Uint8Array,\n    notEqual: string | Uint8Array,\n    options?: SetIfNotEqualOptions\n  ): Promise<CacheSetIfNotEqual.Response> {\n    return this.cacheClient.setIfNotEqual(\n      this.cacheName,\n      key,\n      value,\n      notEqual,\n      options\n    );\n  }\n  setIfPresentAndNotEqual(\n    key: string | Uint8Array,\n    value: string | Uint8Array,\n    notEqual: string | Uint8Array,\n    options?: SetIfPresentAndNotEqualOptions\n  ): Promise<CacheSetIfPresentAndNotEqual.Response> {\n    return this.cacheClient.setIfPresentAndNotEqual(\n      this.cacheName,\n      key,\n      value,\n      notEqual,\n      options\n    );\n  }\n  setIfAbsentOrEqual(\n    key: string | Uint8Array,\n    value: string | Uint8Array,\n    equal: string | Uint8Array,\n    options?: SetIfAbsentOrEqualOptions\n  ): Promise<CacheSetIfAbsentOrEqual.Response> {\n    return this.cacheClient.setIfAbsentOrEqual(\n      this.cacheName,\n      key,\n      value,\n      equal,\n      options\n    );\n  }\n  getBatch(keys: string[] | Uint8Array[]): Promise<CacheGetBatch.Response> {\n    return this.cacheClient.getBatch(this.cacheName, keys);\n  }\n  setBatch(\n    items:\n      | Record<string, string | Uint8Array>\n      | Map<string | Uint8Array, string | Uint8Array>\n      | Array<SetBatchItem>,\n    options?: SetBatchOptions\n  ): Promise<CacheSetBatch.Response> {\n    return this.cacheClient.setBatch(this.cacheName, items, options);\n  }\n  setFetch(setName: string): Promise<CacheSetFetch.Response> {\n    return this.cacheClient.setFetch(this.cacheName, setName);\n  }\n  setAddElement(\n    setName: string,\n    element: string | Uint8Array,\n    options?: SetAddElementOptions\n  ): Promise<CacheSetAddElement.Response> {\n    return this.cacheClient.setAddElement(\n      this.cacheName,\n      setName,\n      element,\n      options\n    );\n  }\n  setAddElements(\n    setName: string,\n    elements: string[] | Uint8Array[],\n    options?: SetAddElementsOptions\n  ): Promise<CacheSetAddElements.Response> {\n    return this.cacheClient.setAddElements(\n      this.cacheName,\n      setName,\n      elements,\n      options\n    );\n  }\n  setContainsElement(\n    setName: string,\n    element: string | Uint8Array\n  ): Promise<CacheSetContainsElement.Response> {\n    return this.cacheClient.setContainsElement(\n      this.cacheName,\n      setName,\n      element\n    );\n  }\n  setContainsElements(\n    setName: string,\n    elements: string[] | Uint8Array[]\n  ): Promise<CacheSetContainsElements.Response> {\n    return this.cacheClient.setContainsElements(\n      this.cacheName,\n      setName,\n      elements\n    );\n  }\n  setRemoveElement(\n    setName: string,\n    element: string | Uint8Array\n  ): Promise<CacheSetRemoveElement.Response> {\n    return this.cacheClient.setRemoveElement(this.cacheName, setName, element);\n  }\n  setRemoveElements(\n    setName: string,\n    elements: string[] | Uint8Array[]\n  ): Promise<CacheSetRemoveElements.Response> {\n    return this.cacheClient.setRemoveElements(\n      this.cacheName,\n      setName,\n      elements\n    );\n  }\n  setSample(setName: string, limit: number): Promise<CacheSetSample.Response> {\n    return this.cacheClient.setSample(this.cacheName, setName, limit);\n  }\n  setPop(setName: string, count: number): Promise<CacheSetPop.Response> {\n    return this.cacheClient.setPop(this.cacheName, setName, count);\n  }\n  setLength(setName: string): Promise<CacheSetLength.Response> {\n    return this.cacheClient.setLength(this.cacheName, setName);\n  }\n  listFetch(\n    listName: string,\n    options?: ListFetchCallOptions\n  ): Promise<CacheListFetch.Response> {\n    return this.cacheClient.listFetch(this.cacheName, listName, options);\n  }\n  listLength(listName: string): Promise<CacheListLength.Response> {\n    return this.cacheClient.listLength(this.cacheName, listName);\n  }\n  listPushFront(\n    listName: string,\n    value: string | Uint8Array,\n    options?: ListPushFrontOptions\n  ): Promise<CacheListPushFront.Response> {\n    return this.cacheClient.listPushFront(\n      this.cacheName,\n      listName,\n      value,\n      options\n    );\n  }\n  listPushBack(\n    listName: string,\n    value: string | Uint8Array,\n    options?: ListPushBackOptions\n  ): Promise<CacheListPushBack.Response> {\n    return this.cacheClient.listPushBack(\n      this.cacheName,\n      listName,\n      value,\n      options\n    );\n  }\n  listConcatenateBack(\n    listName: string,\n    values: string[] | Uint8Array[],\n    options?: ListConcatenateBackOptions\n  ): Promise<CacheListConcatenateBack.Response> {\n    return this.cacheClient.listConcatenateBack(\n      this.cacheName,\n      listName,\n      values,\n      options\n    );\n  }\n  listConcatenateFront(\n    listName: string,\n    values: string[] | Uint8Array[],\n    options?: ListConcatenateFrontOptions\n  ): Promise<CacheListConcatenateFront.Response> {\n    return this.cacheClient.listConcatenateFront(\n      this.cacheName,\n      listName,\n      values,\n      options\n    );\n  }\n  listPopBack(listName: string): Promise<CacheListPopBack.Response> {\n    return this.cacheClient.listPopBack(this.cacheName, listName);\n  }\n  listPopFront(listName: string): Promise<CacheListPopFront.Response> {\n    return this.cacheClient.listPopFront(this.cacheName, listName);\n  }\n  listRemoveValue(\n    listName: string,\n    value: string | Uint8Array\n  ): Promise<CacheListRemoveValue.Response> {\n    return this.cacheClient.listRemoveValue(this.cacheName, listName, value);\n  }\n  listRetain(\n    listName: string,\n    options?: ListRetainCallOptions\n  ): Promise<CacheListRetain.Response> {\n    return this.cacheClient.listRetain(this.cacheName, listName, options);\n  }\n  dictionarySetField(\n    dictionaryName: string,\n    field: string | Uint8Array,\n    value: string | Uint8Array,\n    options?: DictionarySetFieldOptions\n  ): Promise<CacheDictionarySetField.Response> {\n    return this.cacheClient.dictionarySetField(\n      this.cacheName,\n      dictionaryName,\n      field,\n      value,\n      options\n    );\n  }\n  dictionarySetFields(\n    dictionaryName: string,\n    elements:\n      | Map<string | Uint8Array, string | Uint8Array>\n      | Record<string, string | Uint8Array>,\n    options?: DictionarySetFieldsOptions\n  ): Promise<CacheDictionarySetFields.Response> {\n    return this.cacheClient.dictionarySetFields(\n      this.cacheName,\n      dictionaryName,\n      elements,\n      options\n    );\n  }\n  dictionaryGetField(\n    dictionaryName: string,\n    field: string | Uint8Array\n  ): Promise<CacheDictionaryGetField.Response> {\n    return this.cacheClient.dictionaryGetField(\n      this.cacheName,\n      dictionaryName,\n      field\n    );\n  }\n  dictionaryGetFields(\n    dictionaryName: string,\n    fields: string[] | Uint8Array[]\n  ): Promise<CacheDictionaryGetFields.Response> {\n    return this.cacheClient.dictionaryGetFields(\n      this.cacheName,\n      dictionaryName,\n      fields\n    );\n  }\n  dictionaryFetch(\n    dictionaryName: string\n  ): Promise<CacheDictionaryFetch.Response> {\n    return this.cacheClient.dictionaryFetch(this.cacheName, dictionaryName);\n  }\n  dictionaryIncrement(\n    dictionaryName: string,\n    field: string | Uint8Array,\n    amount?: number,\n    options?: DictionaryIncrementOptions\n  ): Promise<CacheDictionaryIncrement.Response> {\n    return this.cacheClient.dictionaryIncrement(\n      this.cacheName,\n      dictionaryName,\n      field,\n      amount,\n      options\n    );\n  }\n  dictionaryRemoveField(\n    dictionaryName: string,\n    field: string | Uint8Array\n  ): Promise<CacheDictionaryRemoveField.Response> {\n    return this.cacheClient.dictionaryRemoveField(\n      this.cacheName,\n      dictionaryName,\n      field\n    );\n  }\n  dictionaryRemoveFields(\n    dictionaryName: string,\n    fields: string[] | Uint8Array[]\n  ): Promise<CacheDictionaryRemoveFields.Response> {\n    return this.cacheClient.dictionaryRemoveFields(\n      this.cacheName,\n      dictionaryName,\n      fields\n    );\n  }\n\n  dictionaryLength(\n    dictionaryName: string\n  ): Promise<CacheDictionaryLength.Response> {\n    return this.cacheClient.dictionaryLength(this.cacheName, dictionaryName);\n  }\n\n  sortedSetFetchByRank(\n    sortedSetName: string,\n    options?: SortedSetFetchByRankOptions\n  ): Promise<CacheSortedSetFetch.Response> {\n    return this.cacheClient.sortedSetFetchByRank(\n      this.cacheName,\n      sortedSetName,\n      options\n    );\n  }\n  sortedSetFetchByScore(\n    sortedSetName: string,\n    options?: SortedSetFetchByScoreOptions\n  ): Promise<CacheSortedSetFetch.Response> {\n    return this.cacheClient.sortedSetFetchByScore(\n      this.cacheName,\n      sortedSetName,\n      options\n    );\n  }\n  sortedSetPutElement(\n    sortedSetName: string,\n    value: string | Uint8Array,\n    score: number,\n    options?: SortedSetPutElementOptions\n  ): Promise<CacheSortedSetPutElement.Response> {\n    return this.cacheClient.sortedSetPutElement(\n      this.cacheName,\n      sortedSetName,\n      value,\n      score,\n      options\n    );\n  }\n  sortedSetPutElements(\n    sortedSetName: string,\n    elements: Map<string | Uint8Array, number> | Record<string, number>,\n    options?: SortedSetPutElementsOptions\n  ): Promise<CacheSortedSetPutElements.Response> {\n    return this.cacheClient.sortedSetPutElements(\n      this.cacheName,\n      sortedSetName,\n      elements,\n      options\n    );\n  }\n  sortedSetGetRank(\n    sortedSetName: string,\n    value: string | Uint8Array\n  ): Promise<CacheSortedSetGetRank.Response> {\n    return this.cacheClient.sortedSetGetRank(\n      this.cacheName,\n      sortedSetName,\n      value\n    );\n  }\n  sortedSetGetScore(\n    sortedSetName: string,\n    value: string | Uint8Array\n  ): Promise<CacheSortedSetGetScore.Response> {\n    return this.cacheClient.sortedSetGetScore(\n      this.cacheName,\n      sortedSetName,\n      value\n    );\n  }\n  sortedSetGetScores(\n    sortedSetName: string,\n    values: string[] | Uint8Array[]\n  ): Promise<CacheSortedSetGetScores.Response> {\n    return this.cacheClient.sortedSetGetScores(\n      this.cacheName,\n      sortedSetName,\n      values\n    );\n  }\n  sortedSetIncrementScore(\n    sortedSetName: string,\n    value: string | Uint8Array,\n    amount?: number,\n    options?: SortedSetIncrementOptions\n  ): Promise<CacheSortedSetIncrementScore.Response> {\n    return this.cacheClient.sortedSetIncrementScore(\n      this.cacheName,\n      sortedSetName,\n      value,\n      amount,\n      options\n    );\n  }\n  sortedSetRemoveElement(\n    sortedSetName: string,\n    value: string | Uint8Array\n  ): Promise<CacheSortedSetRemoveElement.Response> {\n    return this.cacheClient.sortedSetRemoveElement(\n      this.cacheName,\n      sortedSetName,\n      value\n    );\n  }\n  sortedSetRemoveElements(\n    sortedSetName: string,\n    values: string[] | Uint8Array[]\n  ): Promise<CacheSortedSetRemoveElements.Response> {\n    return this.cacheClient.sortedSetRemoveElements(\n      this.cacheName,\n      sortedSetName,\n      values\n    );\n  }\n  sortedSetLength(\n    sortedSetName: string\n  ): Promise<CacheSortedSetLength.Response> {\n    return this.cacheClient.sortedSetLength(this.cacheName, sortedSetName);\n  }\n  sortedSetLengthByScore(\n    sortedSetName: string,\n    options?: SortedSetLengthByScoreOptions\n  ): Promise<CacheSortedSetLengthByScore.Response> {\n    return this.cacheClient.sortedSetLengthByScore(\n      this.cacheName,\n      sortedSetName,\n      options\n    );\n  }\n  itemGetType(key: string | Uint8Array): Promise<CacheItemGetType.Response> {\n    return this.cacheClient.itemGetType(this.cacheName, key);\n  }\n  itemGetTtl(key: string | Uint8Array): Promise<CacheItemGetTtl.Response> {\n    return this.cacheClient.itemGetTtl(this.cacheName, key);\n  }\n  keyExists(key: string | Uint8Array): Promise<CacheKeyExists.Response> {\n    return this.cacheClient.keyExists(this.cacheName, key);\n  }\n  keysExist(keys: string[] | Uint8Array[]): Promise<CacheKeysExist.Response> {\n    return this.cacheClient.keysExist(this.cacheName, keys);\n  }\n  updateTtl(\n    key: string | Uint8Array,\n    ttlMilliseconds: number\n  ): Promise<CacheUpdateTtl.Response> {\n    return this.cacheClient.updateTtl(this.cacheName, key, ttlMilliseconds);\n  }\n  increaseTtl(\n    key: string | Uint8Array,\n    ttlMilliseconds: number\n  ): Promise<CacheIncreaseTtl.Response> {\n    return this.cacheClient.increaseTtl(this.cacheName, key, ttlMilliseconds);\n  }\n  decreaseTtl(\n    key: string | Uint8Array,\n    ttlMilliseconds: number\n  ): Promise<CacheDecreaseTtl.Response> {\n    return this.cacheClient.decreaseTtl(this.cacheName, key, ttlMilliseconds);\n  }\n  close() {\n    this.cacheClient.close();\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 709, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 713, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk-core/src/internal/clients/cache/AbstractCacheClient.ts"],"sourcesContent":["import {\n  CreateCache,\n  DeleteCache,\n  ListCaches,\n  CacheFlush,\n  CacheGet,\n  CacheSet,\n  CacheDelete,\n  CacheIncrement,\n  IncrementOptions,\n  CacheSetIfNotExists,\n  SetIfNotExistsOptions,\n  SetIfAbsentOptions,\n  SetIfPresentOptions,\n  SetIfEqualOptions,\n  SetIfNotEqualOptions,\n  SetIfPresentAndNotEqualOptions,\n  SetIfAbsentOrEqualOptions,\n  CacheSetFetch,\n  CacheSetAddElement,\n  CacheSetAddElements,\n  CacheSetContainsElement,\n  CacheSetContainsElements,\n  CacheSetRemoveElement,\n  CacheSetRemoveElements,\n  CacheListFetch,\n  CacheListLength,\n  CacheListPushFront,\n  CacheListPushBack,\n  CacheListConcatenateBack,\n  CacheListConcatenateFront,\n  CacheListPopBack,\n  CacheListPopFront,\n  CacheListRemoveValue,\n  CacheListRetain,\n  CacheDictionarySetField,\n  CacheDictionarySetFields,\n  CacheDictionaryGetField,\n  CacheDictionaryGetFields,\n  CacheDictionaryIncrement,\n  CacheDictionaryFetch,\n  CacheDictionaryRemoveField,\n  CacheDictionaryRemoveFields,\n  CacheDictionaryLength,\n  CacheSortedSetFetch,\n  CacheSortedSetPutElement,\n  CacheSortedSetPutElements,\n  CacheSortedSetGetRank,\n  CacheSortedSetGetScore,\n  CacheSortedSetGetScores,\n  CacheSortedSetIncrementScore,\n  CacheSortedSetRemoveElement,\n  CacheSortedSetRemoveElements,\n  CacheSortedSetLength,\n  CacheSortedSetLengthByScore,\n  SortedSetOrder,\n  CacheItemGetTtl,\n  CacheItemGetType,\n  CacheKeyExists,\n  CacheKeysExist,\n  CacheUpdateTtl,\n  CacheIncreaseTtl,\n  CacheDecreaseTtl,\n  CacheGetBatch,\n  CacheSetBatch,\n  InvalidArgumentError,\n  CacheSetIfAbsent,\n  CacheSetIfPresent,\n  CacheSetIfEqual,\n  CacheSetIfNotEqual,\n  CacheSetIfPresentAndNotEqual,\n  CacheSetIfAbsentOrEqual,\n  CacheSetSample,\n  CacheSetPop,\n  CacheSetLength,\n} from '../../../index';\nimport {\n  ListFetchCallOptions,\n  ListRetainCallOptions,\n  SetBatchItem,\n} from '../../../utils';\nimport {\n  ICacheClient,\n  SetOptions,\n  SetAddElementOptions,\n  SetAddElementsOptions,\n  ListPushFrontOptions,\n  ListPushBackOptions,\n  ListConcatenateBackOptions,\n  ListConcatenateFrontOptions,\n  DictionarySetFieldOptions,\n  DictionarySetFieldsOptions,\n  DictionaryIncrementOptions,\n  SortedSetFetchByRankOptions,\n  SortedSetPutElementOptions,\n  SortedSetPutElementsOptions,\n  SortedSetFetchByScoreOptions,\n  SortedSetGetRankOptions,\n  SortedSetIncrementOptions,\n  SortedSetLengthByScoreOptions,\n  SetBatchOptions,\n  GetOptions,\n  GetBatchOptions,\n} from '../../../clients/ICacheClient';\nimport {IControlClient} from './IControlClient';\nimport {IDataClient} from './IDataClient';\nimport {IPingClient} from './IPingClient';\nimport {IMomentoCache} from '../../../clients/IMomentoCache';\nimport {MomentoCache} from './momento-cache';\n\nexport abstract class AbstractCacheClient implements ICacheClient {\n  // making these protected until we fully abstract away the nodejs client\n  protected readonly controlClient: IControlClient;\n  protected readonly dataClients: IDataClient[];\n  // TODO: Make pingClient required if and when the nodejs side starts adding\n  //  one as well\n  protected readonly pingClient?: IPingClient;\n  private nextDataClientIndex: number;\n\n  protected constructor(\n    controlClient: IControlClient,\n    dataClients: IDataClient[],\n    pingClient?: IPingClient\n  ) {\n    this.controlClient = controlClient;\n    this.dataClients = dataClients;\n    this.pingClient = pingClient;\n\n    // We round-robin the requests through all of our clients.  Since javascript\n    // is single-threaded, we don't have to worry about thread safety on this\n    // index variable.\n    this.nextDataClientIndex = 0;\n  }\n\n  public cache(cacheName: string): IMomentoCache {\n    return new MomentoCache(this, cacheName);\n  }\n\n  /**\n   * Ping the service to verify it is up and running\n   */\n  public async ping(): Promise<void> {\n    return await this.pingClient?.ping();\n  }\n\n  /**\n   * Creates a cache if it does not exist.\n   *\n   * @param {string} cacheName - The cache to be created.\n   * @returns {Promise<CreateCache.Response>} -\n   * {@link CreateCache.Success} on success.\n   * {@link CreateCache.AlreadyExists} if the cache already exists.\n   * {@link CreateCache.Error} on failure.\n   */\n  public async createCache(cacheName: string): Promise<CreateCache.Response> {\n    return await this.controlClient.createCache(cacheName);\n  }\n\n  /**\n   * Deletes a cache and all items stored in it.\n   *\n   * @param {string} cacheName - The cache to delete.\n   * @returns {Promise<DeleteCache.Response>} -\n   * {@link DeleteCache.Success} on success.\n   * {@link DeleteCache.Error} on failure.\n   */\n  public async deleteCache(cacheName: string): Promise<DeleteCache.Response> {\n    return await this.controlClient.deleteCache(cacheName);\n  }\n\n  /**\n   * Lists all caches.\n   *\n   * @returns {Promise<ListCaches.Response>} -\n   * {@link ListCaches.Success} containing the list on success.\n   * {@link ListCaches.Error} on failure.\n   */\n  public async listCaches(): Promise<ListCaches.Response> {\n    return await this.controlClient.listCaches();\n  }\n\n  /**\n   * Gets the value stored for the given key.\n   *\n   * @param {string} cacheName - The cache to perform the lookup in.\n   * @param {string | Uint8Array} key - The key to look up.\n   * @param {GetOptions} [options]\n   * @param {decompress} [options.decompress=false] - Whether to decompress the value. Overrides the client-wide\n   * automatic decompression setting.\n   * @returns {Promise<CacheGet.Response>} -\n   * {@link CacheGet.Hit} containing the value if one is found.\n   * {@link CacheGet.Miss} if the key does not exist.\n   * {@link CacheGet.Error} on failure.\n   */\n  public async get(\n    cacheName: string,\n    key: string | Uint8Array,\n    options?: GetOptions\n  ): Promise<CacheGet.Response> {\n    return await this.getNextDataClient().get(cacheName, key, options);\n  }\n\n  /**\n   * Associates the given key with the given value. If a value for the key is\n   * already present it is replaced with the new value.\n   *\n   * @param {string} cacheName - The cache to store the value in.\n   * @param {string | Uint8Array} key - The key to set.\n   * @param {string | Uint8Array} value - The value to be stored.\n   * @param {SetOptions} [options]\n   * @param {number} [options.ttl] - The time to live for the item in the cache.\n   * Uses the client's default TTL if this is not supplied.\n   * @param {boolean} [options.compress=false] - Whether to compress the value. Defaults to false.\n   * @returns {Promise<CacheSet.Response>} -\n   * {@link CacheSet.Success} on success.\n   * {@link CacheSet.Error} on failure.\n   */\n  public async set(\n    cacheName: string,\n    key: string | Uint8Array,\n    value: string | Uint8Array,\n    options?: SetOptions\n  ): Promise<CacheSet.Response> {\n    // this typeof check wouldn't be necessary in TS, but it can help catch bugs in JS code at runtime.\n    if (typeof options === 'number') {\n      throw new InvalidArgumentError(\n        'Options must be an object with a ttl property.'\n      );\n    }\n    const client = this.getNextDataClient();\n    return await client.set(cacheName, key, value, options);\n  }\n\n  /**\n   * Removes the given key from the cache. The key can represent a single value\n   * or a collection.\n   *\n   * @param {string} cacheName - The cache to delete from.\n   * @param {string | Uint8Array} key - The key to delete.\n   * @returns {Promise<CacheDelete.Response>} -\n   * {@link CacheDelete.Success} on success.\n   * {@link CacheDelete.Error} on failure.\n   */\n  public async delete(\n    cacheName: string,\n    key: string | Uint8Array\n  ): Promise<CacheDelete.Response> {\n    const client = this.getNextDataClient();\n    return await client.delete(cacheName, key);\n  }\n\n  /**\n   * Gets the value stored for the given keys.\n   *\n   * @param {string} cacheName - The cache to perform the lookup in.\n   * @param {string[] | Uint8Array[]} keys - The list of keys to look up.\n   * @param {GetBatchOptions} [options]\n   * @param {decompress} [options.decompress=false] - Whether to decompress the value. Overrides the client-wide\n   * automatic decompression setting.\n   * @returns {Promise<CacheGetBatch.Response>} -\n   * {@link CacheGetBatch.Success} containing the values if they were found.\n   * {@link CacheGetBatch.Error} on failure.\n   */\n  public async getBatch(\n    cacheName: string,\n    keys: Array<string | Uint8Array>,\n    options?: GetBatchOptions\n  ): Promise<CacheGetBatch.Response> {\n    return await this.getNextDataClient().getBatch(cacheName, keys, options);\n  }\n\n  /**\n   * Associates the given keys with the given values. If a value for the key is\n   * already present it is replaced with the new value.\n   *\n   * @param {string} cacheName - The cache to store the values in.\n   * @param {Record<string, string | Uint8Array | SetBatchItem> | Map<string | Uint8Array, string | Uint8Array | SetBatchItem>} items - The key-value pairs to be stored, with the option to set a TTL per item.\n   * @param {SetBatchOptions} [options]\n   * @param {number} [options.ttl] - The time to live for the items in the cache.\n   * Uses the client's default TTL if this is not supplied.\n   * @param {boolean} [options.compress=false] - Whether to compress the value. Defaults to false.\n   * @returns {Promise<CacheSetBatch.Response>} -\n   * {@link CacheSetBatch.Success} on success.\n   * {@link CacheSetBatch.Error} on failure.\n   */\n  public async setBatch(\n    cacheName: string,\n    items:\n      | Record<string, string | Uint8Array>\n      | Map<string | Uint8Array, string | Uint8Array>\n      | Array<SetBatchItem>,\n    options?: SetBatchOptions\n  ): Promise<CacheSetBatch.Response> {\n    const client = this.getNextDataClient();\n    return await client.setBatch(cacheName, items, options);\n  }\n\n  /**\n   * Adds multiple elements to the back of the given list. Creates the list if\n   * it does not already exist.\n   *\n   * @param {string} cacheName - The cache to store the list in.\n   * @param {string} listName - The list to add to.\n   * @param {string[] | Uint8Array[]} values - The elements to add to the list.\n   * @param {ListConcatenateBackOptions} [options]\n   * @param {number} [options.truncateFrontToSize] - If the list exceeds this\n   * length, remove excess from the front of the list. Must be positive.\n   * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.\n   * Refreshes the list's TTL using the client's default if this is not\n   * supplied.\n   * @returns {Promise<CacheListConcatenateBack.Response>} -\n   * {@link CacheListConcatenateBack.Success} on success.\n   * {@link CacheListConcatenateBack.Error} on failure.\n   */\n  public async listConcatenateBack(\n    cacheName: string,\n    listName: string,\n    values: string[] | Uint8Array[],\n    options?: ListConcatenateBackOptions\n  ): Promise<CacheListConcatenateBack.Response> {\n    const client = this.getNextDataClient();\n    return await client.listConcatenateBack(\n      cacheName,\n      listName,\n      values,\n      options?.truncateFrontToSize,\n      options?.ttl\n    );\n  }\n\n  /**\n   * Adds multiple elements to the front of the given list. Creates the list if\n   * it does not already exist.\n   *\n   * @param {string} cacheName - The cache to store the list in.\n   * @param {string} listName - The list to add to.\n   * @param {string[] | Uint8Array[]} values - The elements to add to the list.\n   * @param {ListConcatenateFrontOptions} [options]\n   * @param {number} [options.truncateBackToSize] - If the list exceeds this\n   * length, remove excess from the back of the list. Must be positive.\n   * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.\n   * Refreshes the list's TTL using the client's default if this is not\n   * supplied.\n   * @returns {Promise<CacheListConcatenateFront.Response>} -\n   * {@link CacheListConcatenateFront.Success} on success.\n   * {@link CacheListConcatenateFront.Error} on failure.\n   */\n  public async listConcatenateFront(\n    cacheName: string,\n    listName: string,\n    values: string[] | Uint8Array[],\n    options?: ListConcatenateFrontOptions\n  ): Promise<CacheListConcatenateFront.Response> {\n    const client = this.getNextDataClient();\n    return await client.listConcatenateFront(\n      cacheName,\n      listName,\n      values,\n      options?.truncateBackToSize,\n      options?.ttl\n    );\n  }\n\n  /**\n   * Fetches all elements of the given list.\n   *\n   * @param {string} cacheName - The cache containing the list.\n   * @param {string} listName - The list to fetch.\n   * @param {ListFetchCallOptions} [options]\n   * @param {number} [options.startIndex] - Start inclusive index for fetch operation.\n   * @param {number} [options.endIndex] - End exclusive index for fetch operation.\n   * @returns {Promise<CacheListFetch.Response>} -\n   * {@link CacheListFetch.Hit} containing the list elements if the list exists.\n   * {@link CacheListFetch.Miss} if the list does not exist.\n   * {@link CacheListFetch.Error} on failure.\n   */\n  public async listFetch(\n    cacheName: string,\n    listName: string,\n    options?: ListFetchCallOptions\n  ): Promise<CacheListFetch.Response> {\n    const client = this.getNextDataClient();\n    return await client.listFetch(\n      cacheName,\n      listName,\n      options?.startIndex,\n      options?.endIndex\n    );\n  }\n\n  /**\n   * Gets the number of elements in the given list.\n   *\n   * @param {string} cacheName - The cache containing the list.\n   * @param {string} listName - The list to get the length of.\n   * @returns {Promise<CacheListLength.Response>} -\n   * {@link CacheListLength.Hit} containing the length if the list exists.\n   * {@link CacheListLength.Miss} if the list does not exist.\n   * {@link CacheListLength.Error} on failure.\n   */\n  public async listLength(\n    cacheName: string,\n    listName: string\n  ): Promise<CacheListLength.Response> {\n    const client = this.getNextDataClient();\n    return await client.listLength(cacheName, listName);\n  }\n\n  /**\n   * Gets and removes the last value from the given list.\n   *\n   * @param {string} cacheName - The cache containing the list.\n   * @param {string} listName - The list to pop.\n   * @returns {Promise<CacheListPopBack.Response>} -\n   * {@link CacheListPopBack.Hit} containing the element if the list exists.\n   * {@link CacheListPopBack.Miss} if the list does not exist.\n   * {@link CacheListPopBack.Error} on failure.\n   */\n  public async listPopBack(\n    cacheName: string,\n    listName: string\n  ): Promise<CacheListPopBack.Response> {\n    const client = this.getNextDataClient();\n    return await client.listPopBack(cacheName, listName);\n  }\n\n  /**\n   * Gets and removes the first value from the given list.\n   *\n   * @param {string} cacheName - The cache containing the list.\n   * @param {string} listName - The list to pop.\n   * @returns {Promise<CacheListPopFront.Response>} -\n   * {@link CacheListPopFront.Hit} containing the element if the list exists.\n   * {@link CacheListPopFront.Miss} if the list does not exist.\n   * {@link CacheListPopFront.Error} on failure.\n   */\n  public async listPopFront(\n    cacheName: string,\n    listName: string\n  ): Promise<CacheListPopFront.Response> {\n    const client = this.getNextDataClient();\n    return await client.listPopFront(cacheName, listName);\n  }\n\n  /**\n   * Adds an element to the back of the given list. Creates the list if\n   * it does not already exist.\n   *\n   * @param {string} cacheName - The cache to store the list in.\n   * @param {string} listName - The list to push to.\n   * @param {string | Uint8Array} value - The value to push.\n   * @param {ListPushBackOptions} [options]\n   * @param {number} [options.truncateFrontToSize] - If the list exceeds this\n   * length, remove excess from the front of the list. Must be positive.\n   * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.\n   * Refreshes the list's TTL using the client's default if this is not\n   * supplied.\n   * @returns {Promise<CacheListPushBack.Response>} -\n   * {@link CacheListPushBack.Success} containing the list's new length on\n   * success.\n   * {@link CacheListPushBack.Error} on failure.\n   */\n  public async listPushBack(\n    cacheName: string,\n    listName: string,\n    value: string | Uint8Array,\n    options?: ListPushBackOptions\n  ): Promise<CacheListPushBack.Response> {\n    const client = this.getNextDataClient();\n    return await client.listPushBack(\n      cacheName,\n      listName,\n      value,\n      options?.truncateFrontToSize,\n      options?.ttl\n    );\n  }\n\n  /**\n   * Adds an element to the front of the given list. Creates the list if\n   * it does not already exist.\n   *\n   * @param {string} cacheName - The cache to store the list in.\n   * @param {string} listName - The list to push to.\n   * @param {string | Uint8Array} value - The value to push.\n   * @param {ListPushFrontOptions} [options]\n   * @param {number} [options.truncateBackToSize] - If the list exceeds this\n   * length, remove excess from the end of the list. Must be positive.\n   * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.\n   * Refreshes the list's TTL using the client's default if this is not\n   * supplied.\n   * @returns {Promise<CacheListPushFront.Response>} -\n   * {@link CacheListPushFront.Success} containing the list's new length on\n   * success.\n   * {@link CacheListPushFront.Error} on failure.\n   */\n  public async listPushFront(\n    cacheName: string,\n    listName: string,\n    value: string | Uint8Array,\n    options?: ListPushFrontOptions\n  ): Promise<CacheListPushFront.Response> {\n    const client = this.getNextDataClient();\n    return await client.listPushFront(\n      cacheName,\n      listName,\n      value,\n      options?.truncateBackToSize,\n      options?.ttl\n    );\n  }\n\n  /**\n   * Removes all elements from the given list equal to the given value.\n   *\n   * @param {string} cacheName - The cache containing the list.\n   * @param {string} listName - The list to remove from.\n   * @param {string | Uint8Array} value - The value to remove.\n   * @returns {Promise<CacheListRemoveValue.Response>} -\n   * {@link CacheListRemoveValue.Success} on success. Removing an element that\n   * does not occur in the list or removing from a non-existent list counts as a\n   * success.\n   * {@link CacheListRemoveValue.Error} on failure.\n   */\n  public async listRemoveValue(\n    cacheName: string,\n    listName: string,\n    value: string | Uint8Array\n  ): Promise<CacheListRemoveValue.Response> {\n    const client = this.getNextDataClient();\n    return await client.listRemoveValue(cacheName, listName, value);\n  }\n\n  /**\n   * Retains slice of elements of a given list, deletes the rest of the list\n   * that isn't being retained. Returns a Success or Error.\n   *\n   * @param {string} cacheName - The cache containing the list.\n   * @param {string} listName - The list to retain a slice of.\n   * @param {ListRetainCallOptions} [options]\n   * @param {number} [options.startIndex] - Start inclusive index for fetch\n   * operation. Defaults to start of array if not given, 0.\n   * @param {number} [options.endIndex] - End exclusive index for fetch\n   * operation. Defaults to end of array if not given.\n   * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.\n   * Refreshes the list's TTL using the client's default if this is not\n   * supplied.\n   * @returns {Promise<CacheListRetain.Response>} -\n   * {@link CacheListRetain.Success} on success.\n   * {@link CacheListRetain.Error} on failure.\n   */\n  public async listRetain(\n    cacheName: string,\n    listName: string,\n    options?: ListRetainCallOptions\n  ): Promise<CacheListRetain.Response> {\n    const client = this.getNextDataClient();\n    return await client.listRetain(\n      cacheName,\n      listName,\n      options?.startIndex,\n      options?.endIndex,\n      options?.ttl\n    );\n  }\n\n  /**\n   * Fetches all elements of the given set\n   *\n   * @param {string} cacheName - The cache containing the set.\n   * @param {string} setName - The set to fetch.\n   * @returns {Promise<CacheSetFetch.Response>} -\n   * {@link CacheSetFetch.Hit} containing the set elements if the set exists.\n   * {@link CacheSetFetch.Miss} if the set does not exist.\n   * {@link CacheSetFetch.Error} on failure.\n   */\n  public async setFetch(\n    cacheName: string,\n    setName: string\n  ): Promise<CacheSetFetch.Response> {\n    const client = this.getNextDataClient();\n    return await client.setFetch(cacheName, setName);\n  }\n\n  /**\n   * Adds an element to the given set. Creates the set if it does not already\n   * exist.\n   *\n   * @remarks\n   * After this operation the set will contain the union of the element passed\n   * in and the original elements of the set.\n   *\n   * @param {string} cacheName - The cache to store the set in.\n   * @param {string} setName - The set to add to.\n   * @param {string | Uint8Array} element - The element to add.\n   * @param {SetAddElementOptions} options\n   * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.\n   * Refreshes the set's TTL using the client's default if this is not supplied.\n   * @returns {Promise<CacheSetAddElement.Response>} -\n   * {@link CacheSetAddElement.Success} on success.\n   * {@link CacheSetAddElement.Error} on failure.\n   */\n  public async setAddElement(\n    cacheName: string,\n    setName: string,\n    element: string | Uint8Array,\n    options?: SetAddElementOptions\n  ): Promise<CacheSetAddElement.Response> {\n    return (\n      await this.setAddElements(\n        cacheName,\n        setName,\n        [element] as string[] | Uint8Array[],\n        options\n      )\n    ).toSingularResponse();\n  }\n\n  /**\n   * Adds multiple elements to the given set. Creates the set if it does not\n   * already exist.\n   *\n   * @remarks\n   * After this operation, the set will contain the union of the elements passed\n   * in and the original elements of the set.\n   *\n   * @param {string} cacheName - The cache to store the set in.\n   * @param {string} setName - The set to add to.\n   * @param {string[] | Uint8Array[]} elements - The elements to add.\n   * @param {SetAddElementsOptions} options\n   * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.\n   * Refreshes the set's TTL using the client's default if this is not supplied.\n   * @returns {Promise<CacheSetAddElements.Response>} -\n   * {@link CacheSetAddElements.Success} on success.\n   * {@link CacheSetAddElements.Error} on failure.\n   */\n  public async setAddElements(\n    cacheName: string,\n    setName: string,\n    elements: string[] | Uint8Array[],\n    options?: SetAddElementsOptions\n  ): Promise<CacheSetAddElements.Response> {\n    const client = this.getNextDataClient();\n    return await client.setAddElements(\n      cacheName,\n      setName,\n      elements,\n      options?.ttl\n    );\n  }\n\n  /**\n   * Tests if the given set contains the given element.\n   * @param cacheName - The cache containing the set.\n   * @param setName - The set to check.\n   * @param element - The element to check for.\n   * @returns {Promise<CacheSetContainsElement.Response>} -\n   * {@link CacheSetContainsElement.Hit} if the set exists and contains the element.\n   * {@link CacheSetContainsElement.Miss} if the set does not contain the element.\n   * {@link CacheSetContainsElement.Error} on failure.\n   */\n  public async setContainsElement(\n    cacheName: string,\n    setName: string,\n    element: string | Uint8Array\n  ): Promise<CacheSetContainsElement.Response> {\n    const client = this.getNextDataClient();\n    return await client.setContainsElement(cacheName, setName, element);\n  }\n\n  /**\n   * Tests if the given set contains the given elements.\n   * @param cacheName - The cache containing the set.\n   * @param setName - The set to check.\n   * @param elements - The elements to check for.\n   * @returns {Promise<CacheSetContainsElements.Response>} -\n   * {@link CacheSetContainsElements.Hit} containing the elements to their presence in the cache.\n   * {@link CacheSetContainsElements.Miss} if the set does not contain the elements.\n   * {@link CacheSetContainsElements.Error} on failure.\n   */\n  public async setContainsElements(\n    cacheName: string,\n    setName: string,\n    elements: string[] | Uint8Array[]\n  ): Promise<CacheSetContainsElements.Response> {\n    const client = this.getNextDataClient();\n    return await client.setContainsElements(cacheName, setName, elements);\n  }\n\n  /**\n   * Removes an element from the given set.\n   *\n   * @param {string} cacheName - The cache containing the set.\n   * @param {string} setName - The set to remove from.\n   * @param {string | Uint8Array} element - The element to remove.\n   * @returns {Promise<CacheSetRemoveElement.Response>} -\n   * {@link CacheSetRemoveElement.Success} on success. Removing an element that\n   * does not occur in the set or removing from a non-existent set counts as a\n   * success.\n   * {@link CacheSetRemoveElement.Error} on failure.\n   */\n  public async setRemoveElement(\n    cacheName: string,\n    setName: string,\n    element: string | Uint8Array\n  ): Promise<CacheSetRemoveElement.Response> {\n    return (\n      await this.setRemoveElements(cacheName, setName, [element] as\n        | string[]\n        | Uint8Array[])\n    ).toSingularResponse();\n  }\n\n  /**\n   * Removes multiple elements from the given set.\n   *\n   * @param {string} cacheName - The cache containing the set.\n   * @param {string} setName - The set to remove from.\n   * @param {string[] | Uint8Array[]} elements - The elements to remove.\n   * @returns {Promise<CacheSetRemoveElements.Response>} -\n   * {@link CacheSetRemoveElements.Success} on success. Removing elements that\n   * do not occur in the set or removing from a non-existent set counts as a\n   * success.\n   * {@link CacheSetRemoveElements.Error} on failure.\n   */\n  public async setRemoveElements(\n    cacheName: string,\n    setName: string,\n    elements: string[] | Uint8Array[]\n  ): Promise<CacheSetRemoveElements.Response> {\n    const client = this.getNextDataClient();\n    return await client.setRemoveElements(cacheName, setName, elements);\n  }\n\n  /**\n   * Fetch a random sample of elements from the set.\n   * Returns a different random sample for each call.\n   *\n   * @param {string} cacheName - The cache containing the set.\n   * @param {string} setName - The set to remove from.\n   * @param {number} limit - The maximum number of elements to return.\n   * If the set contains fewer than 'limit' elements, the entire set will be returned.\n   * @returns {Promise<CacheSetSample.Response>} -\n   * {@link CacheSetSample.Hit} containing the set elements if the set exists.\n   * {@link CacheSetSample.Miss} if the set does not exist.\n   * {@link CacheSetSample.Error} on failure.\n   */\n  public async setSample(\n    cacheName: string,\n    setName: string,\n    limit: number\n  ): Promise<CacheSetSample.Response> {\n    const client = this.getNextDataClient();\n    return await client.setSample(cacheName, setName, limit);\n  }\n\n  /**\n   * Pops a random sample of elements from the set.\n   *\n   * @param {string} cacheName - The cache containing the set.\n   * @param {string} setName - The set to remove from.\n   * @param {number} count - The maximum number of elements to return.\n   * If the set contains fewer than 'limit' elements, the entire set will be returned.\n   * @returns {Promise<CacheSetPop.Response>} -\n   * {@link CacheSetPop.Hit} containing the set elements if the set exists.\n   * {@link CacheSetPop.Miss} if the set does not exist.\n   * {@link CacheSetPop.Error} on failure.\n   */\n  public async setPop(\n    cacheName: string,\n    setName: string,\n    count: number\n  ): Promise<CacheSetPop.Response> {\n    const client = this.getNextDataClient();\n    return await client.setPop(cacheName, setName, count);\n  }\n\n  /**\n   * Get the number of elements in the set.\n   *\n   * @param {string} cacheName - The cache containing the set.\n   * @param {string} setName - The set to remove from.\n   * @returns {Promise<CacheSetLength.Response>} -\n   * {@link CacheSetLength.Hit} containing the set elements if the set exists.\n   * {@link CacheSetLength.Miss} if the set does not exist.\n   * {@link CacheSetLength.Error} on failure.\n   */\n  public async setLength(\n    cacheName: string,\n    setName: string\n  ): Promise<CacheSetLength.Response> {\n    const client = this.getNextDataClient();\n    return await client.setLength(cacheName, setName);\n  }\n\n  /**\n   * Associates the given key with the given value if key is not already present in the cache.\n   *\n   * @deprecated Use setIfAbsent instead.\n   * @param {string} cacheName - The cache to store the value in.\n   * @param {string | Uint8Array} key - The key to set.\n   * @param {string | Uint8Array} field - The value to be stored.\n   * @param {SetIfNotExistsOptions} [options]\n   * @param {number} [options.ttl] - The time to live for the item in the cache.\n   * Uses the client's default TTL if this is not supplied.\n   * @returns {Promise<CacheSetIfNotExists.Response>} -\n   * {@link CacheSetIfNotExists.Stored} on storing the new value.\n   * {@link CacheSetIfNotExists.NotStored} on not storing the new value.\n   * {@link CacheSetIfNotExists.Error} on failure.\n   */\n  public async setIfNotExists(\n    cacheName: string,\n    key: string | Uint8Array,\n    field: string | Uint8Array,\n    options?: SetIfNotExistsOptions\n  ): Promise<CacheSetIfNotExists.Response> {\n    const client = this.getNextDataClient();\n    return await client.setIfNotExists(cacheName, key, field, options?.ttl);\n  }\n\n  /**\n   * Associates the given key with the given value if key is not already present in the cache.\n   *\n   * @param {string} cacheName - The cache to store the value in.\n   * @param {string | Uint8Array} key - The key to set.\n   * @param {string | Uint8Array} field - The value to be stored.\n   * @param {SetIfAbsentOptions} [options]\n   * @param {number} [options.ttl] - The time to live for the item in the cache.\n   * Uses the client's default TTL if this is not supplied.\n   * @param {boolean} [options.compress=false] - Whether to compress the value. Defaults to false.\n   * @returns {Promise<CacheSetIfAbsent.Response>} -\n   * {@link CacheSetIfAbsent.Stored} on storing the new value.\n   * {@link CacheSetIfAbsent.NotStored} on not storing the new value.\n   * {@link CacheSetIfAbsent.Error} on failure.\n   */\n  public async setIfAbsent(\n    cacheName: string,\n    key: string | Uint8Array,\n    field: string | Uint8Array,\n    options?: SetIfAbsentOptions\n  ): Promise<CacheSetIfAbsent.Response> {\n    const client = this.getNextDataClient();\n    return await client.setIfAbsent(cacheName, key, field, options);\n  }\n\n  /**\n   * Associates the given key with the given value if the key is present in the cache.\n   *\n   * @param {string} cacheName - The cache to store the value in.\n   * @param {string | Uint8Array} key - The key to set.\n   * @param {string | Uint8Array} field - The value to be stored.\n   * @param {SetIfPresentOptions} [options]\n   * @param {number} [options.ttl] - The time to live for the item in the cache.\n   * Uses the client's default TTL if this is not supplied.\n   * @returns {Promise<CacheSetIfPresent.Response>} -\n   * {@link CacheSetIfPresent.Stored} on storing the new value.\n   * {@link CacheSetIfPresent.NotStored} on not storing the new value.\n   * {@link CacheSetIfPresent.Error} on failure.\n   */\n  public async setIfPresent(\n    cacheName: string,\n    key: string | Uint8Array,\n    field: string | Uint8Array,\n    options?: SetIfPresentOptions\n  ): Promise<CacheSetIfPresent.Response> {\n    const client = this.getNextDataClient();\n    return await client.setIfPresent(cacheName, key, field, options?.ttl);\n  }\n\n  /**\n   * Associates the given key with the given value if the key is present in the cache\n   * and its value is equal to the supplied `equal` value.\n   *\n   * @param {string} cacheName - The cache to store the value in.\n   * @param {string | Uint8Array} key - The key to set.\n   * @param {string | Uint8Array} field - The value to be stored.\n   * @param {string | Uint8Array} equal - The value to compare to the cached value.\n   * @param {SetIfEqualOptions} [options]\n   * @param {number} [options.ttl] - The time to live for the item in the cache.\n   * Uses the client's default TTL if this is not supplied.\n   * @returns {Promise<CacheSetIfEqual.Response>} -\n   * {@link CacheSetIfEqual.Stored} on storing the new value.\n   * {@link CacheSetIfEqual.NotStored} on not storing the new value.\n   * {@link CacheSetIfEqual.Error} on failure.\n   */\n  public async setIfEqual(\n    cacheName: string,\n    key: string | Uint8Array,\n    field: string | Uint8Array,\n    equal: string | Uint8Array,\n    options?: SetIfEqualOptions\n  ): Promise<CacheSetIfEqual.Response> {\n    const client = this.getNextDataClient();\n    return await client.setIfEqual(cacheName, key, field, equal, options?.ttl);\n  }\n\n  /**\n   * Associates the given key with the given value if the key does not exist in the cache or\n   * if the value for the key is not equal to the supplied `notEqual` parameter.\n   *\n   * @param {string} cacheName - The cache to store the value in.\n   * @param {string | Uint8Array} key - The key to set.\n   * @param {string | Uint8Array} field - The value to be stored.\n   * @param {string | Uint8Array} notEqual - The value to compare to the cached value.\n   * @param {SetIfNotEqualOptions} [options]\n   * @param {number} [options.ttl] - The time to live for the item in the cache.\n   * Uses the client's default TTL if this is not supplied.\n   * @returns {Promise<CacheSetIfNotEqual.Response>} -\n   * {@link CacheSetIfNotEqual.Stored} on storing the new value.\n   * {@link CacheSetIfNotEqual.NotStored} on not storing the new value.\n   * {@link CacheSetIfNotEqual.Error} on failure.\n   */\n  public async setIfNotEqual(\n    cacheName: string,\n    key: string | Uint8Array,\n    field: string | Uint8Array,\n    notEqual: string | Uint8Array,\n    options?: SetIfNotEqualOptions\n  ): Promise<CacheSetIfNotEqual.Response> {\n    const client = this.getNextDataClient();\n    return await client.setIfNotEqual(\n      cacheName,\n      key,\n      field,\n      notEqual,\n      options?.ttl\n    );\n  }\n\n  /**\n   * Associates the given key with the given value if key is present in the cache\n   * and its value is not equal to the supplied `notEqual` value.\n   *\n   * @param {string} cacheName - The cache to store the value in.\n   * @param {string | Uint8Array} key - The key to set.\n   * @param {string | Uint8Array} field - The value to be stored.\n   * @param {string | Uint8Array} notEqual - The value to compare to the cached value.\n   * @param {SetIfAbsentOptions} [options]\n   * @param {number} [options.ttl] - The time to live for the item in the cache.\n   * Uses the client's default TTL if this is not supplied.\n   * @returns {Promise<CacheSetIfPresentAndNotEqual.Response>} -\n   * {@link CacheSetIfPresentAndNotEqual.Stored} on storing the new value.\n   * {@link CacheSetIfPresentAndNotEqual.NotStored} on not storing the new value.\n   * {@link CacheSetIfPresentAndNotEqual.Error} on failure.\n   */\n  public async setIfPresentAndNotEqual(\n    cacheName: string,\n    key: string | Uint8Array,\n    field: string | Uint8Array,\n    notEqual: string | Uint8Array,\n    options?: SetIfPresentAndNotEqualOptions\n  ): Promise<CacheSetIfPresentAndNotEqual.Response> {\n    const client = this.getNextDataClient();\n    return await client.setIfPresentAndNotEqual(\n      cacheName,\n      key,\n      field,\n      notEqual,\n      options?.ttl\n    );\n  }\n\n  /**\n   * Associates the given key with the given value if key is absent or if the key is\n   * present and its value is equal to the given value.\n   *\n   * @param {string} cacheName - The cache to store the value in.\n   * @param {string | Uint8Array} key - The key to set.\n   * @param {string | Uint8Array} field - The value to be stored.\n   * @param {string | Uint8Array} equal - The value to compare to the cached value.\n   * @param {SetIfAbsentOrEqualOptions} [options]\n   * @param {number} [options.ttl] - The time to live for the item in the cache.\n   * Uses the client's default TTL if this is not supplied.\n   * @returns {Promise<CacheSetIfAbsentOrEqual.Response>} -\n   * {@link CacheSetIfAbsentOrEqual.Stored} on storing the new value.\n   * {@link CacheSetIfAbsentOrEqual.NotStored} on not storing the new value.\n   * {@link CacheSetIfAbsentOrEqual.Error} on failure.\n   */\n  public async setIfAbsentOrEqual(\n    cacheName: string,\n    key: string | Uint8Array,\n    field: string | Uint8Array,\n    equal: string | Uint8Array,\n    options?: SetIfAbsentOrEqualOptions\n  ): Promise<CacheSetIfAbsentOrEqual.Response> {\n    const client = this.getNextDataClient();\n    return await client.setIfAbsentOrEqual(\n      cacheName,\n      key,\n      field,\n      equal,\n      options?.ttl\n    );\n  }\n\n  /**\n   * Flushes / clears all the items of the given cache\n   *\n   * @param {string} cacheName - The cache to be flushed.\n   * @returns {Promise<CacheFlush.Response>} -\n   * {@link CacheFlush.Success} on success.\n   * {@link CacheFlush.Error} on failure.\n   */\n  public async flushCache(cacheName: string): Promise<CacheFlush.Response> {\n    return await this.controlClient.flushCache(cacheName);\n  }\n\n  /**\n   * Fetches all elements of the given dictionary.\n   *\n   * @param {string} cacheName - The cache to perform the lookup in.\n   * @param {string} dictionaryName - The dictionary to fetch.\n   * @returns {Promise<CacheDictionaryFetch.Response>} -\n   * {@link CacheDictionaryFetch.Hit} containing the dictionary elements if the\n   * dictionary exists.\n   * {@link CacheDictionaryFetch.Miss} if the dictionary does not exist.\n   * {@link CacheDictionaryFetch.Error} on failure.\n   */\n  public async dictionaryFetch(\n    cacheName: string,\n    dictionaryName: string\n  ): Promise<CacheDictionaryFetch.Response> {\n    const client = this.getNextDataClient();\n    return await client.dictionaryFetch(cacheName, dictionaryName);\n  }\n\n  /**\n   * Adds an integer quantity to a field value.\n   *\n   * @remarks\n   * Incrementing the value of a missing field sets the value to amount.\n   *\n   * @param {string} cacheName - The cache containing the field.\n   * @param {string | Uint8Array} field - The field to increment.\n   * @param {number} amount - The quantity to add to the value. May be positive,\n   * negative, or zero. Defaults to 1.\n   * @param {IncrementOptions} options\n   * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.\n   * @returns {Promise<CacheIncrement>} -\n   * {@link CacheIncrement.Success} containing the incremented value\n   * on success.\n   * {@link CacheIncrement.Error} on failure. Incrementing a value\n   * that was not set using this method or is not the string representation of\n   * an integer results in a failure with a FailedPreconditionException error.\n   */\n  public async increment(\n    cacheName: string,\n    field: string | Uint8Array,\n    amount = 1,\n    options?: IncrementOptions\n  ): Promise<CacheIncrement.Response> {\n    const client = this.getNextDataClient();\n    return await client.increment(cacheName, field, amount, options?.ttl);\n  }\n\n  /**\n   * Adds an element to the given dictionary. Creates the dictionary if it does\n   * not already exist.\n   *\n   * @param {string} cacheName - The cache to store the dictionary in.\n   * @param {string} dictionaryName - The dictionary to add to.\n   * @param {string | Uint8Array} field - The field to set.\n   * @param {string | Uint8Array} value - The value to store.\n   * @param {DictionarySetFieldOptions} options\n   * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.\n   * Refreshes the dictionary's TTL using the client's default if this is not\n   * supplied.\n   * @returns {Promise<CacheDictionarySetField.Response>} -\n   * {@link CacheDictionarySetField.Success} on success.\n   * {@link CacheDictionarySetField.Error} on failure.\n   */\n  public async dictionarySetField(\n    cacheName: string,\n    dictionaryName: string,\n    field: string | Uint8Array,\n    value: string | Uint8Array,\n    options?: DictionarySetFieldOptions\n  ): Promise<CacheDictionarySetField.Response> {\n    const client = this.getNextDataClient();\n    return await client.dictionarySetField(\n      cacheName,\n      dictionaryName,\n      field,\n      value,\n      options?.ttl\n    );\n  }\n\n  /**\n   * Adds multiple elements to the given dictionary. Creates the dictionary if\n   * it does not already exist.\n   *\n   * @param {string} cacheName - The cache to store the dictionary in.\n   * @param {string} dictionaryName - The dictionary to add to.\n   * @param {Map<string | Uint8Array, string | Uint8Array>} elements - The\n   * elements to set.\n   * @param {DictionarySetFieldsOptions} options\n   * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.\n   * Refreshes the dictionary's TTL using the client's default if this is not\n   * supplied.\n   * @returns {Promise<CacheDictionarySetFields.Response>} -\n   * {@link CacheDictionarySetFields.Success} on success.\n   * {@link CacheDictionarySetFields.Error} on failure.\n   */\n  public async dictionarySetFields(\n    cacheName: string,\n    dictionaryName: string,\n    elements:\n      | Map<string | Uint8Array, string | Uint8Array>\n      | Record<string, string | Uint8Array>\n      | Array<[string, string | Uint8Array]>,\n    options?: DictionarySetFieldsOptions\n  ): Promise<CacheDictionarySetFields.Response> {\n    const client = this.getNextDataClient();\n    return await client.dictionarySetFields(\n      cacheName,\n      dictionaryName,\n      elements,\n      options?.ttl\n    );\n  }\n\n  /**\n   * Gets the value stored for the given dictionary and field.\n   *\n   * @param {string} cacheName - The cache containing the dictionary.\n   * @param {string} dictionaryName - The dictionary to look up.\n   * @param {string | Uint8Array} field - The field to look up.\n   * @returns {Promise<CacheDictionaryGetField.Response>} -\n   * {@link CacheDictionaryGetField.Hit} containing the dictionary element if\n   * one is found.\n   * {@link CacheDictionaryGetField.Miss} if the dictionary does not exist.\n   * {@link CacheDictionaryGetField.Error} on failure.\n   */\n  public async dictionaryGetField(\n    cacheName: string,\n    dictionaryName: string,\n    field: string | Uint8Array\n  ): Promise<CacheDictionaryGetField.Response> {\n    const client = this.getNextDataClient();\n    return await client.dictionaryGetField(cacheName, dictionaryName, field);\n  }\n\n  /**\n   * Gets multiple values from the given dictionary.\n   *\n   * @param {string} cacheName - The cache containing the dictionary.\n   * @param {string} dictionaryName - The dictionary to look up.\n   * @param {string[] | Uint8Array[]} fields - The fields to look up.\n   * @returns {Promise<CacheDictionaryGetFields.Response>} -\n   * {@link CacheDictionaryGetFields.Hit} containing the dictionary elements if\n   * the dictionary exists.\n   * {@link CacheDictionaryGetFields.Miss} if the dictionary does not exist.\n   * {@link CacheDictionaryGetFields.Error} on failure.\n   */\n  public async dictionaryGetFields(\n    cacheName: string,\n    dictionaryName: string,\n    fields: string[] | Uint8Array[]\n  ): Promise<CacheDictionaryGetFields.Response> {\n    const client = this.getNextDataClient();\n    return await client.dictionaryGetFields(cacheName, dictionaryName, fields);\n  }\n\n  /**\n   * Removes an element from the given dictionary.\n   *\n   * @remarks\n   * Performs a no-op if the dictionary or field does not exist.\n   *\n   * @param {string} cacheName - The cache containing the dictionary.\n   * @param {string} dictionaryName - The dictionary to remove from.\n   * @param {string | Uint8Array} field - The field to remove.\n   * @returns {Promise<CacheDictionaryRemoveField.Response>} -\n   * {@link CacheDictionaryRemoveField.Success} on success.\n   * {@link CacheDictionaryRemoveField.Error} on failure.\n   */\n  public async dictionaryRemoveField(\n    cacheName: string,\n    dictionaryName: string,\n    field: string | Uint8Array\n  ): Promise<CacheDictionaryRemoveField.Response> {\n    const client = this.getNextDataClient();\n    return await client.dictionaryRemoveField(cacheName, dictionaryName, field);\n  }\n\n  /**\n   * Removes multiple fields from the given dictionary.\n   *\n   * @remarks\n   * Performs a no-op if the dictionary or fields do not exist.\n   *\n   * @param {string} cacheName - The cache containing the dictionary.\n   * @param {string} dictionaryName - The dictionary to remove from.\n   * @param {string[] | Uint8Array[]} fields - The fields to remove.\n   * @returns {Promise<CacheDictionaryRemoveFields.Response>} -\n   * {@link CacheDictionaryRemoveFields.Success} on success.\n   * {@link CacheDictionaryRemoveFields.Error} on failure.\n   */\n  public async dictionaryRemoveFields(\n    cacheName: string,\n    dictionaryName: string,\n    fields: string[] | Uint8Array[]\n  ): Promise<CacheDictionaryRemoveFields.Response> {\n    const client = this.getNextDataClient();\n    return await client.dictionaryRemoveFields(\n      cacheName,\n      dictionaryName,\n      fields\n    );\n  }\n\n  /**\n   * Adds an integer quantity to a dictionary value.\n   *\n   * @remarks\n   * Incrementing the value of a missing field sets the value to amount.\n   *\n   * @param {string} cacheName - The cache containing the dictionary.\n   * @param {string} dictionaryName - The dictionary to set.\n   * @param {string | Uint8Array} field - The field to increment.\n   * @param {number} amount - The quantity to add to the value. May be positive,\n   * negative, or zero. Defaults to 1.\n   * @param {DictionaryIncrementOptions} options\n   * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.\n   * Refreshes the dictionary's TTL using the client's default if this is not\n   * supplied.\n   * @returns {Promise<CacheDictionaryIncrement.Response>} -\n   * {@link CacheDictionaryIncrement.Success} containing the incremented value\n   * on success.\n   * {@link CacheDictionaryIncrement.Error} on failure. Incrementing a value\n   * that was not set using this method or is not the string representation of\n   * an integer results in a failure with a FailedPreconditionException error.\n   */\n  public async dictionaryIncrement(\n    cacheName: string,\n    dictionaryName: string,\n    field: string | Uint8Array,\n    amount = 1,\n    options?: DictionaryIncrementOptions\n  ): Promise<CacheDictionaryIncrement.Response> {\n    const client = this.getNextDataClient();\n    return await client.dictionaryIncrement(\n      cacheName,\n      dictionaryName,\n      field,\n      amount,\n      options?.ttl\n    );\n  }\n\n  /**\n   * Gets the number of elements in the given dictionary.\n   *\n   * @param {string} cacheName - The cache containing the dictionary.\n   * @param {string} dictionaryName - The dictionary to get the length of.\n   * @returns {Promise<CacheDictionaryLength.Response>} -\n   * {@link CacheDictionaryLength.Hit} containing the length if the dictionary exists.\n   * {@link CacheDictionaryLength.Miss} if the dictionary does not exist.\n   * {@link CacheDictionaryLength.Error} on failure.\n   */\n  public async dictionaryLength(\n    cacheName: string,\n    dictionaryName: string\n  ): Promise<CacheDictionaryLength.Response> {\n    const client = this.getNextDataClient();\n    return await client.dictionaryLength(cacheName, dictionaryName);\n  }\n\n  /**\n   * Adds an element to the given sorted set. If the element already exists, its\n   * score is updated. Creates the sorted set if it does not exist.\n   *\n   * @param {string} cacheName - The cache containing the sorted set.\n   * @param {string} sortedSetName - The sorted set to add to.\n   * @param {string | Uint8Array} value - The value to add.\n   * @param {number} score - The score to assign to the value.\n   * @param {SortedSetPutElementOptions} options\n   * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.\n   * Refreshes the sorted set's TTL using the client's default if this is not\n   * supplied.\n   * @returns {Promise<CacheSortedSetPutElement.Response>} -\n   * {@link CacheSortedSetPutElement.Success} on success.\n   * {@link CacheSortedSetPutElement.Error} on failure.\n   * @returns\n   */\n  public async sortedSetPutElement(\n    cacheName: string,\n    sortedSetName: string,\n    value: string | Uint8Array,\n    score: number,\n    options?: SortedSetPutElementOptions\n  ): Promise<CacheSortedSetPutElement.Response> {\n    const client = this.getNextDataClient();\n    return await client.sortedSetPutElement(\n      cacheName,\n      sortedSetName,\n      value,\n      score,\n      options?.ttl\n    );\n  }\n\n  /**\n   * Adds elements to the given sorted set. For any values that already exist, it\n   * the score is updated. Creates the sorted set if it does not exist.\n   *\n   * @param {string} cacheName - The cache containing the sorted set.\n   * @param {string} sortedSetName - The sorted set to add to.\n   * @param {Map<string | Uint8Array, number>| Record<string, number>} elements - The value->score pairs to add to the sorted set.\n   * @param {SortedSetPutElementOptions} options\n   * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.\n   * Refreshes the sorted set's TTL using the client's default if this is not\n   * supplied.\n   * @returns {Promise<CacheSortedSetPutElements.Response>} -\n   * {@link CacheSortedSetPutElements.Success} on success.\n   * {@link CacheSortedSetPutElements.Error} on failure.\n   * @returns\n   */\n  public async sortedSetPutElements(\n    cacheName: string,\n    sortedSetName: string,\n    elements:\n      | Map<string | Uint8Array, number>\n      | Record<string, number>\n      | Array<[string, number]>,\n    options?: SortedSetPutElementsOptions\n  ): Promise<CacheSortedSetPutElements.Response> {\n    const client = this.getNextDataClient();\n    return await client.sortedSetPutElements(\n      cacheName,\n      sortedSetName,\n      elements,\n      options?.ttl\n    );\n  }\n\n  /**\n   * Fetch the elements in the given sorted set by index (rank).\n   *\n   * @param {string} cacheName - The cache containing the sorted set.\n   * @param {string} sortedSetName - The sorted set to fetch from.\n   * @param {SortedSetFetchByRankOptions} options\n   * @param {number} [options.startRank] - The rank of the first element to\n   * fetch. Defaults to 0. This rank is inclusive, ie the element at this rank\n   * will be fetched.\n   * @param {number} [options.endRank] - The rank of the last element to fetch.\n   * This rank is exclusive, ie the element at this rank will not be fetched.\n   * Defaults to null, which fetches up until and including the last element.\n   * @param {SortedSetOrder} [options.order] - The order to fetch the elements in.\n   * Defaults to ascending.\n   * @returns {Promise<CacheSortedSetFetch.Response>}\n   * {@link CacheSortedSetFetch.Hit} containing the requested elements when found.\n   * {@link CacheSortedSetFetch.Miss} when the sorted set does not exist.\n   * {@link CacheSortedSetFetch.Error} on failure.\n   */\n  public async sortedSetFetchByRank(\n    cacheName: string,\n    sortedSetName: string,\n    options?: SortedSetFetchByRankOptions\n  ): Promise<CacheSortedSetFetch.Response> {\n    const client = this.getNextDataClient();\n    return await client.sortedSetFetchByRank(\n      cacheName,\n      sortedSetName,\n      options?.order ?? SortedSetOrder.Ascending,\n      options?.startRank ?? 0,\n      options?.endRank\n    );\n  }\n\n  /**\n   * Fetch the elements in the given sorted set by score.\n   *\n   * @param {string} cacheName - The cache containing the sorted set.\n   * @param {string} sortedSetName - The sorted set to fetch from.\n   * @param {SortedSetFetchByScoreOptions} options\n   * @param {number} [options.minScore] - The minimum score (inclusive) of the\n   * elements to fetch. Defaults to negative infinity.\n   * @param {number} [options.maxScore] - The maximum score (inclusive) of the\n   * elements to fetch. Defaults to positive infinity.\n   * @param {SortedSetOrder} [options.order] - The order to fetch the elements in.\n   * Defaults to ascending.\n   * @param {number} [options.offset] - The number of elements to skip before\n   * returning the first element. Defaults to 0. Note: this is not the rank of\n   * the first element to return, but the number of elements of the result set\n   * to skip before returning the first element.\n   * @param {number} [options.count] - The maximum number of elements to return.\n   * Defaults to undefined, which returns all elements.\n   * @returns {Promise<CacheSortedSetFetch.Response>} -\n   * {@link CacheSortedSetFetch.Hit} containing the requested elements when found.\n   * {@link CacheSortedSetFetch.Miss} when the sorted set does not exist.\n   * {@link CacheSortedSetFetch.Error} on failure.\n   */\n  public async sortedSetFetchByScore(\n    cacheName: string,\n    sortedSetName: string,\n    options?: SortedSetFetchByScoreOptions\n  ): Promise<CacheSortedSetFetch.Response> {\n    const client = this.getNextDataClient();\n    return await client.sortedSetFetchByScore(\n      cacheName,\n      sortedSetName,\n      options?.order ?? SortedSetOrder.Ascending,\n      options?.minScore,\n      options?.maxScore,\n      options?.offset,\n      options?.count\n    );\n  }\n\n  /**\n   * Look up the rank of an element in the sorted set, by the value of the element.\n   *\n   * @param {string} cacheName - The cache containing the sorted set.\n   * @param {string} sortedSetName - The sorted set to fetch from.\n   * @param {string | Uint8Array} value - The value of the element whose rank we are retrieving.\n   * @param {SortedSetGetRankOptions} options\n   * @param {SortedSetOrder} [options.order] - The order in which sorted set will be sorted to determine the rank.\n   * Defaults to ascending.\n   * @returns {Promise<CacheSortedSetGetRank.Response>}\n   * {@link CacheSortedSetGetRank.Hit} containing the rank of the requested elements when found.\n   * {@link CacheSortedSetGetRank.Miss} when the element does not exist.\n   * {@link CacheSortedSetGetRank.Error} on failure.\n   */\n  public async sortedSetGetRank(\n    cacheName: string,\n    sortedSetName: string,\n    value: string | Uint8Array,\n    options?: SortedSetGetRankOptions\n  ): Promise<CacheSortedSetGetRank.Response> {\n    const client = this.getNextDataClient();\n    return await client.sortedSetGetRank(\n      cacheName,\n      sortedSetName,\n      value,\n      options?.order\n    );\n  }\n\n  /**\n   * Look up the score of an element in the sorted set, by the value of the element.\n   *\n   * @param {string} cacheName - The cache containing the sorted set.\n   * @param {string} sortedSetName - The sorted set to fetch from.\n   * @param {string | Uint8Array} value - The value of the element whose score we are retrieving.\n   * @returns {Promise<CacheSortedSetGetScore.Response>}\n   * {@link CacheSortedSetGetScore.Hit} containing the score of the requested element when found.\n   * {@link CacheSortedSetGetScore.Miss} when the element or collection does not exist.\n   * {@link CacheSortedSetGetScore.Error} on failure.\n   */\n  public async sortedSetGetScore(\n    cacheName: string,\n    sortedSetName: string,\n    value: string | Uint8Array\n  ): Promise<CacheSortedSetGetScore.Response> {\n    const client = this.getNextDataClient();\n    return await client.sortedSetGetScore(cacheName, sortedSetName, value);\n  }\n\n  /**\n   * Look up the scores of multiple elements in the sorted set, by the value of the elements.\n   *\n   * @param {string} cacheName - The cache containing the sorted set.\n   * @param {string} sortedSetName - The sorted set to fetch from.\n   * @param {string[] | Uint8Array[]} values - The values of the elements whose scores we are retrieving.\n   * @returns {Promise<CacheSortedSetGetScores.Response>}\n   * {@link CacheSortedSetGetScores.Hit} containing the scores of the requested elements when found.\n   * {@link CacheSortedSetGetScores.Miss} when the element or collection does not exist.\n   * {@link CacheSortedSetGetScores.Error} on failure.\n   */\n  public async sortedSetGetScores(\n    cacheName: string,\n    sortedSetName: string,\n    values: string[] | Uint8Array[]\n  ): Promise<CacheSortedSetGetScores.Response> {\n    const client = this.getNextDataClient();\n    return await client.sortedSetGetScores(cacheName, sortedSetName, values);\n  }\n\n  /**\n   * Increment the score of an element in the sorted set.\n   *\n   * @param {string} cacheName - The cache containing the sorted set.\n   * @param {string} sortedSetName - The sorted set to fetch from.\n   * @param {string | Uint8Array} value - The value of the element whose score we are incrementing.\n   * @param {number} amount - The quantity to add to the score. May be positive,\n   * negative, or zero. Defaults to 1.\n   * @param {SortedSetIncrementOptions} options\n   * @param {CollectionTtl} [options.ttl] - How the TTL should be managed.\n   * Refreshes the sorted set's TTL using the client's default if this is not\n   * supplied.\n   * @returns {Promise<CacheSortedSetIncrementScore.Response>} -\n   * {@link CacheSortedSetIncrementScore.Success} containing the incremented score\n   * on success.\n   * {@link CacheSortedSetIncrementScore.Error} on failure. Incrementing a score\n   * that was not set using this method or is not the string representation of\n   * an integer results in a failure with a FailedPreconditionException error.\n   */\n  public async sortedSetIncrementScore(\n    cacheName: string,\n    sortedSetName: string,\n    value: string | Uint8Array,\n    amount?: number,\n    options?: SortedSetIncrementOptions\n  ): Promise<CacheSortedSetIncrementScore.Response> {\n    const client = this.getNextDataClient();\n    return await client.sortedSetIncrementScore(\n      cacheName,\n      sortedSetName,\n      value,\n      amount || 1,\n      options?.ttl\n    );\n  }\n\n  /**\n   * Remove an element from the sorted set\n   * @param {string} cacheName - The cache containing the sorted set.\n   * @param {string} sortedSetName - The sorted set to remove from.\n   * @param {string | Uint8Array} value - The value of the element to remove from the set.\n   * @returns {Promise<CacheSortedSetRemoveElement.Response>}\n   * {@link CacheSortedSetRemoveElement.Success} if the element was successfully removed\n   * {@link CacheSortedSetIncrementScore.Error} on failure\n   */\n  public async sortedSetRemoveElement(\n    cacheName: string,\n    sortedSetName: string,\n    value: string | Uint8Array\n  ): Promise<CacheSortedSetRemoveElement.Response> {\n    const client = this.getNextDataClient();\n    return await client.sortedSetRemoveElement(cacheName, sortedSetName, value);\n  }\n\n  /**\n   * Remove multiple elements from the sorted set\n   * @param {string} cacheName - The cache containing the sorted set.\n   * @param {string} sortedSetName - The sorted set to remove from.\n   * @param {string | Uint8Array} values - The values of the elements to remove from the set.\n   * @returns {Promise<CacheSortedSetRemoveElement.Response>}\n   * {@link CacheSortedSetRemoveElement.Success} if the elements were successfully removed\n   * {@link CacheSortedSetIncrementScore.Error} on failure\n   */\n  public async sortedSetRemoveElements(\n    cacheName: string,\n    sortedSetName: string,\n    values: string[] | Uint8Array[]\n  ): Promise<CacheSortedSetRemoveElements.Response> {\n    const client = this.getNextDataClient();\n    return await client.sortedSetRemoveElements(\n      cacheName,\n      sortedSetName,\n      values\n    );\n  }\n\n  /**\n   * Fetch length (number of items) of sorted set\n   * @param {string} cacheName - The cache containing the sorted set.\n   * @param {string} sortedSetName - The sorted set name.\n   * @returns {Promise<CacheSortedSetLength.Response>}\n   * {@link CacheSortedSetLength.Hit} containing the length if the sorted set exists.\n   * {@link CacheSortedSetLength.Miss} if the sorted set does not exist.\n   * {@link CacheSortedSetLength.Error} on failure.\n   */\n  public async sortedSetLength(\n    cacheName: string,\n    sortedSetName: string\n  ): Promise<CacheSortedSetLength.Response> {\n    const client = this.getNextDataClient();\n    return await client.sortedSetLength(cacheName, sortedSetName);\n  }\n\n  /**\n   * Fetch length (number of items) of sorted set within the provided score range\n   * @param {string} cacheName - The cache containing the sorted set.\n   * @param {string} sortedSetName - The sorted set name.\n   * @param {SortedSetLengthByScoreOptions} options - Optional parameter for specifying the score range to search in.\n   * @param {number} [options.minScore] - The lower bound on the score range to search in.\n   * @param {number} [options.maxScore] - The upper bound on the score range to search in.\n   * @returns {Promise<CacheSortedSetLengthByScore.Response>}\n   * {@link CacheSortedSetLengthByScore.Hit} containing the length if the sorted set exists.\n   * {@link CacheSortedSetLengthByScore.Miss} if the sorted set does not exist.\n   * {@link CacheSortedSetLengthByScore.Error} on failure.\n   */\n  public async sortedSetLengthByScore(\n    cacheName: string,\n    sortedSetName: string,\n    options?: SortedSetLengthByScoreOptions\n  ): Promise<CacheSortedSetLengthByScore.Response> {\n    const client = this.getNextDataClient();\n    return await client.sortedSetLengthByScore(\n      cacheName,\n      sortedSetName,\n      options?.minScore,\n      options?.maxScore\n    );\n  }\n\n  /**\n   * Return the type of the key in the cache\n   * @param {string} cacheName - The cache containing the key.\n   * @param {string} key - The key for which type is requested.\n   * @returns {Promise<CacheItemGetType.Response>}\n   * {@link CacheItemGetType.Hit} containing type of key when found.\n   * {@link CacheItemGetType.Miss} when the key does not exist.\n   * {@link CacheItemGetType.Error} on failure.\n   */\n  public async itemGetType(\n    cacheName: string,\n    key: string | Uint8Array\n  ): Promise<CacheItemGetType.Response> {\n    const client = this.getNextDataClient();\n    return await client.itemGetType(cacheName, key);\n  }\n\n  /**\n   * Return the remaining ttl of the key in the cache in milliseconds.\n   * @param {string} cacheName - The cache containing the key.\n   * @param {string} key - The key for which the ttl remaining is requested.\n   * @returns {Promise<CacheItemGetTtl.Response>}\n   * {@link CacheItemGetTtl.Hit} containing ttl remaining of key when found.\n   * {@link CacheItemGetTtl.Miss} when the key does not exist.\n   * {@link CacheItemGetTtl.Error} on failure.\n   */\n  public async itemGetTtl(\n    cacheName: string,\n    key: string | Uint8Array\n  ): Promise<CacheItemGetTtl.Response> {\n    const client = this.getNextDataClient();\n    return await client.itemGetTtl(cacheName, key);\n  }\n\n  /**\n   * Check if the provided key exists in the cache\n   * @param {string} cacheName - The cache to look in.\n   * @param {string | Uint8Array} key - The key to look up.\n   * @returns {Promise<CacheKeyExists.Response>}\n   * {@link CacheKeyExists.Success} returns boolean indicating whether the key was found.\n   * {@link CacheKeyExists.Error} on failure.\n   */\n  public async keyExists(\n    cacheName: string,\n    key: string | Uint8Array\n  ): Promise<CacheKeyExists.Response> {\n    const client = this.getNextDataClient();\n    return await client.keyExists(cacheName, key);\n  }\n\n  /**\n   * Check if the provided keys exist in the cache\n   * @param {string} cacheName - The cache to look in.\n   * @param {string[] | Uint8Array[]} keys - The keys to look up.\n   * @returns {Promise<CacheKeysExist.Response>}\n   * {@link CacheKeysExist.Success} returns list of booleans indicating whether each key was found.\n   * {@link CacheKeysExist.Error} on failure.\n   */\n  public async keysExist(\n    cacheName: string,\n    keys: string[] | Uint8Array[]\n  ): Promise<CacheKeysExist.Response> {\n    const client = this.getNextDataClient();\n    return await client.keysExist(cacheName, keys);\n  }\n\n  /**\n   * Update the ttl of the key in the cache in milliseconds.\n   * @param {string} cacheName - The cache containing the key.\n   * @param {string} key - The key for which the ttl remaining is requested.\n   * @param {number} ttlMilliseconds - The ttl in milliseconds that should overwrite the current ttl.\n   * @returns {Promise<CacheUpdateTtl.Response>}\n   * {@link CacheUpdateTtl.Set} when the ttl was successfully overwritten.\n   * {@link CacheUpdateTtl.Miss} when the key does not exist.\n   * {@link CacheUpdateTtl.Error} on failure.\n   */\n  public async updateTtl(\n    cacheName: string,\n    key: string | Uint8Array,\n    ttlMilliseconds: number\n  ): Promise<CacheUpdateTtl.Response> {\n    const client = this.getNextDataClient();\n    return await client.updateTtl(cacheName, key, ttlMilliseconds);\n  }\n\n  /**\n   * Increase the ttl of the key in the cache in milliseconds.\n   * @param {string} cacheName - The cache containing the key.\n   * @param {string} key - The key for which the ttl remaining is requested.\n   * @param {number} ttlMilliseconds - The ttl in milliseconds that should\n   * overwrite the current ttl. Should be greater than the current ttl.\n   * @returns {Promise<CacheIncreaseTtl.Response>}\n   * {@link CacheIncreaseTtl.Set} when the ttl was successfully increased.\n   * {@link CacheIncreaseTtl.Miss} when the key does not exist.\n   * {@link CacheIncreaseTtl.Error} on failure.\n   */\n  public async increaseTtl(\n    cacheName: string,\n    key: string | Uint8Array,\n    ttlMilliseconds: number\n  ): Promise<CacheIncreaseTtl.Response> {\n    const client = this.getNextDataClient();\n    return await client.increaseTtl(cacheName, key, ttlMilliseconds);\n  }\n\n  /**\n   * Decrease the ttl of the key in the cache in milliseconds.\n   * @param {string} cacheName - The cache containing the key.\n   * @param {string} key - The key for which the ttl remaining is requested.\n   * @param {number} ttlMilliseconds - The ttl in milliseconds that should\n   * overwrite the current ttl. Should be less than the current ttl.\n   * @returns {Promise<CacheDecreaseTtl.Response>}\n   * {@link CacheDecreaseTtl.Set} when the ttl was successfully decreased.\n   * {@link CacheDecreaseTtl.Miss} when the key does not exist.\n   * {@link CacheDecreaseTtl.Error} on failure.\n   */\n  public async decreaseTtl(\n    cacheName: string,\n    key: string | Uint8Array,\n    ttlMilliseconds: number\n  ): Promise<CacheDecreaseTtl.Response> {\n    const client = this.getNextDataClient();\n    return await client.decreaseTtl(cacheName, key, ttlMilliseconds);\n  }\n\n  private getNextDataClient(): IDataClient {\n    const client = this.dataClients[this.nextDataClientIndex];\n    this.nextDataClientIndex =\n      (this.nextDataClientIndex + 1) % this.dataClients.length;\n    return client;\n  }\n\n  abstract close(): void;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1794, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1798, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk-core/src/internal/clients/pubsub/AbstractTopicClient.ts"],"sourcesContent":["import {ITopicClient} from '../../../clients/ITopicClient';\nimport {\n  MomentoLogger,\n  SubscribeCallOptions,\n  TopicPublish,\n  TopicSubscribe,\n  ListWebhooks,\n  PutWebhook,\n  DeleteWebhook,\n  GetWebhookSecret,\n  PostUrlWebhookDestination,\n  RotateWebhookSecret,\n} from '../../../index';\nimport {IPubsubClient} from './IPubsubClient';\nimport {IWebhookClient} from './IWebhookClient';\nimport {PutWebhookCallOptions} from '../../../utils/webhook-call-options';\n\nexport abstract class AbstractTopicClient implements ITopicClient {\n  protected readonly logger: MomentoLogger;\n  protected readonly pubsubClients: IPubsubClient[];\n  protected readonly webhookClient: IWebhookClient;\n  private nextPubsubClientIndex = 0;\n\n  protected constructor(\n    logger: MomentoLogger,\n    pubsubClients: IPubsubClient[],\n    webhookClient: IWebhookClient\n  ) {\n    this.logger = logger;\n    this.pubsubClients = pubsubClients;\n    this.webhookClient = webhookClient;\n  }\n\n  /**\n   * Publishes a value to a topic.\n   *\n   * @param {string} cacheName - The name of the cache to containing the topic to publish to.\n   * @param {string} topicName - The name of the topic to publish to.\n   * @param {string | Uint8Array} value - The value to publish.\n   * @returns {Promise<TopicPublish.Response>} -\n   * {@link TopicPublish.Success} on success.\n   * {@link TopicPublish.Error} on failure.\n   */\n  public async publish(\n    cacheName: string,\n    topicName: string,\n    value: string | Uint8Array\n  ): Promise<TopicPublish.Response> {\n    return await this.getNextPubsubClient().publish(\n      cacheName,\n      topicName,\n      value\n    );\n  }\n\n  /**\n   * Subscribes to a topic.\n   *\n   * @param {string} cacheName - The name of the cache to containing the topic to subscribe to.\n   * @param {string} topicName - The name of the topic to subscribe to.\n   * @param {SubscribeCallOptions} options - The options for the subscription. Defaults to no-op handlers.\n   * @param {function} options.onItem - The callback to invoke when data is received. Defaults to no-op.\n   * @param {function} options.onError - The callback to invoke when an error is received. Defaults to no-op.\n   * @returns {Promise<TopicSubscribe.Response>} -\n   * {@link TopicSubscribe.Subscription} on success.\n   * {@link TopicSubscribe.Error} on failure.\n   */\n  public async subscribe(\n    cacheName: string,\n    topicName: string,\n    options: SubscribeCallOptions\n  ): Promise<TopicSubscribe.Response> {\n    return await this.getNextPubsubClient().subscribe(\n      cacheName,\n      topicName,\n      options\n    );\n  }\n\n  /**\n   * Deletes a webhook\n   *\n   * @param {string} cacheName - The name of the cache associated with the webhook\n   * @param {string} webhookName - The name of the webhook\n   * @returns {Promise<DeleteWebhook.Response>} -\n   * {@link DeleteWebhook.Success} on success.\n   * {@link DeleteWebhook.Error} on failure.\n   */\n  public async deleteWebhook(\n    cacheName: string,\n    webhookName: string\n  ): Promise<DeleteWebhook.Response> {\n    return await this.webhookClient.deleteWebhook({cacheName, webhookName});\n  }\n\n  /**\n   * Lists webhooks associated with a cache\n   *\n   * @param {string} cacheName - The cache to list webhooks associated with it\n   * @returns {Promise<ListWebhooks.Response>} -\n   * {@link ListWebhooks.Success} on success.\n   * {@link ListWebhooks.Error} on failure.\n   */\n  public async listWebhooks(cacheName: string): Promise<ListWebhooks.Response> {\n    return await this.webhookClient.listWebhooks(cacheName);\n  }\n\n  /**\n   * Creates a new webhook, or updates an existing one\n   *\n   * @param {string} cacheName - The name of the cache to associate the webhook with\n   * @param {string} webhookName - The name of the webhook\n   * @param {PutWebhookCallOptions} options - The options for the webhook\n   * @param {string} topicName - The name of the topic for the webhook to listen to\n   * @param {WebhookDestination | string} webhookDestination - The url to associate the webhook with\n   * @returns {Promise<PutWebhook.Response>} -\n   * {@link PutWebhook.Success} on success.\n   * {@link PutWebhook.Error} on failure.\n   */\n  public async putWebhook(\n    cacheName: string,\n    webhookName: string,\n    options: PutWebhookCallOptions\n  ): Promise<PutWebhook.Response> {\n    let _dest = options.destination;\n    if (typeof _dest === 'string') {\n      _dest = new PostUrlWebhookDestination(_dest);\n    }\n    return await this.webhookClient.putWebhook({\n      topicName: options.topicName,\n      id: {\n        cacheName,\n        webhookName,\n      },\n      destination: _dest,\n    });\n  }\n\n  /**\n   * Gets the signing secret for a webhook\n   *\n   * @param {string} cacheName - The name of the cache associated with the webhook\n   * @param {string} webhookName - The name of the webhook\n   * @returns {Promise<GetWebhookSecret.Response>} -\n   * {@link GetWebhookSecret.Success} on success.\n   * {@link GetWebhookSecret.Error} on failure.\n   */\n  public async getWebhookSecret(\n    cacheName: string,\n    webhookName: string\n  ): Promise<GetWebhookSecret.Response> {\n    return await this.webhookClient.getWebhookSecret({cacheName, webhookName});\n  }\n\n  /**\n   * Rotates the signing secret for a webhook\n   *\n   * @param {string} cacheName - The name of the cache associated with the webhook\n   * @param {string} webhookName - The name of the webhook\n   * @returns {Promise<RotateWebhookSecret.Response>} -\n   * {@link RotateWebhookSecret.Success} on success.\n   * {@link RotateWebhookSecret.Error} on failure.\n   */\n  public async rotateWebhookSecret(\n    cacheName: string,\n    webhookName: string\n  ): Promise<RotateWebhookSecret.Response> {\n    return await this.webhookClient.rotateWebhookSecret({\n      cacheName,\n      webhookName,\n    });\n  }\n\n  protected getNextPubsubClient(): IPubsubClient {\n    const client = this.pubsubClients[this.nextPubsubClientIndex];\n    this.nextPubsubClientIndex =\n      (this.nextPubsubClientIndex + 1) % this.pubsubClients.length;\n    return client;\n  }\n}\n"],"names":[],"mappings":";;;;;AACA,MAAA;AAgBA,MAAsB;IAMpB,YACE,MAAqB,EACrB,aAA8B,EAC9B,aAA6B,CAAA;QALvB,IAAA,CAAA,qBAAqB,GAAG;QAO9B,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,aAAa,GAAG;QACrB,IAAI,CAAC,aAAa,GAAG;IACvB;IAEA;;;;;;;;;QAUO,MAAM,QACX,SAAiB,EACjB,SAAiB,EACjB,KAA0B,EAAA;QAE1B,OAAO,MAAM,IAAI,CAAC,mBAAmB,GAAG,OAAO,CAC7C,WACA,WACA;IAEJ;IAEA;;;;;;;;;;;QAYO,MAAM,UACX,SAAiB,EACjB,SAAiB,EACjB,OAA6B,EAAA;QAE7B,OAAO,MAAM,IAAI,CAAC,mBAAmB,GAAG,SAAS,CAC/C,WACA,WACA;IAEJ;IAEA;;;;;;;;QASO,MAAM,cACX,SAAiB,EACjB,WAAmB,EAAA;QAEnB,OAAO,MAAM,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC;YAAC;YAAW;QAAW;IACvE;IAEA;;;;;;;QAQO,MAAM,aAAa,SAAiB,EAAA;QACzC,OAAO,MAAM,IAAI,CAAC,aAAa,CAAC,YAAY,CAAC;IAC/C;IAEA;;;;;;;;;;;QAYO,MAAM,WACX,SAAiB,EACjB,WAAmB,EACnB,OAA8B,EAAA;QAE9B,IAAI,QAAQ,QAAQ,WAAW;QAC/B,IAAI,OAAO,UAAU,UAAU;YAC7B,QAAQ,IAAI,QAAA,yBAAyB,CAAC;;QAExC,OAAO,MAAM,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC;YACzC,WAAW,QAAQ,SAAS;YAC5B,IAAI;gBACF;gBACA;;YAEF,aAAa;;IAEjB;IAEA;;;;;;;;QASO,MAAM,iBACX,SAAiB,EACjB,WAAmB,EAAA;QAEnB,OAAO,MAAM,IAAI,CAAC,aAAa,CAAC,gBAAgB,CAAC;YAAC;YAAW;QAAW;IAC1E;IAEA;;;;;;;;QASO,MAAM,oBACX,SAAiB,EACjB,WAAmB,EAAA;QAEnB,OAAO,MAAM,IAAI,CAAC,aAAa,CAAC,mBAAmB,CAAC;YAClD;YACA;;IAEJ;IAEU,sBAAmB;QAC3B,MAAM,SAAS,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,qBAAqB,CAAC;QAC7D,IAAI,CAAC,qBAAqB,GACxB,CAAC,IAAI,CAAC,qBAAqB,GAAG,CAAC,IAAI,IAAI,CAAC,aAAa,CAAC,MAAM;QAC9D,OAAO;IACT;;AAjKF,QAAA,mBAAA,GAAA"}},
    {"offset": {"line": 1921, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1925, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk-core/src/internal/subscription-state.ts"],"sourcesContent":["/**\n * Encapsulates a topic subscription stream state.\n */\nexport class SubscriptionState {\n  private _unsubscribeFn: () => void;\n  public lastTopicSequenceNumber?: number;\n  private _isSubscribed: boolean;\n  constructor() {\n    this._unsubscribeFn = () => {\n      return;\n    };\n    this._isSubscribed = false;\n  }\n\n  public get resumeAtTopicSequenceNumber(): number {\n    return (this.lastTopicSequenceNumber ?? -1) + 1;\n  }\n\n  public setSubscribed(): void {\n    this._isSubscribed = true;\n  }\n\n  public setUnsubscribed(): void {\n    this._isSubscribed = false;\n  }\n\n  public get isSubscribed(): boolean {\n    return this._isSubscribed;\n  }\n\n  public set unsubscribeFn(unsubscribeFn: () => void) {\n    this._unsubscribeFn = unsubscribeFn;\n  }\n\n  public unsubscribe(): void {\n    if (this.isSubscribed) {\n      this._unsubscribeFn();\n      this.setUnsubscribed();\n    }\n  }\n\n  public toString(): string {\n    return JSON.stringify(\n      {\n        lastTopicSequenceNumber: this.lastTopicSequenceNumber,\n        isSubscribed: this._isSubscribed,\n      },\n      null,\n      2\n    );\n  }\n}\n"],"names":[],"mappings":";;;;;AAAA;;IAGA,MAAa;IAIX,aAAA;QACE,IAAI,CAAC,cAAc,GAAG;YACpB;QACF;QACA,IAAI,CAAC,aAAa,GAAG;IACvB;IAEA,IAAW,8BAA2B;;QACpC,OAAO,CAAC,CAAA,KAAA,IAAI,CAAC,uBAAuB,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,CAAC,CAAC,IAAI;IAChD;IAEO,gBAAa;QAClB,IAAI,CAAC,aAAa,GAAG;IACvB;IAEO,kBAAe;QACpB,IAAI,CAAC,aAAa,GAAG;IACvB;IAEA,IAAW,eAAY;QACrB,OAAO,IAAI,CAAC,aAAa;IAC3B;IAEA,IAAW,cAAc,aAAyB,EAAA;QAChD,IAAI,CAAC,cAAc,GAAG;IACxB;IAEO,cAAW;QAChB,IAAI,IAAI,CAAC,YAAY,EAAE;YACrB,IAAI,CAAC,cAAc;YACnB,IAAI,CAAC,eAAe;;IAExB;IAEO,WAAQ;QACb,OAAO,KAAK,SAAS,CACnB;YACE,yBAAyB,IAAI,CAAC,uBAAuB;YACrD,cAAc,IAAI,CAAC,aAAa;WAElC,MACA;IAEJ;;AA/CF,QAAA,iBAAA,GAAA"}},
    {"offset": {"line": 1969, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1973, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk-core/src/internal/clients/pubsub/AbstractPubsubClient.ts"],"sourcesContent":["import {\n  sleep,\n  truncateString,\n  validateCacheName,\n  validateTopicName,\n} from '../../utils';\nimport {MomentoErrorCode} from '../../../errors';\nimport {\n  TopicPublish,\n  TopicItem,\n  MomentoLogger,\n  TopicSubscribe,\n  SubscribeCallOptions,\n  MomentoLoggerFactory,\n  TopicDiscontinuity,\n  TopicHeartbeat,\n} from '../../../index';\nimport {SubscriptionState} from '../../subscription-state';\nimport {IPubsubClient} from './IPubsubClient';\nimport {ICacheServiceErrorMapper} from '../../../errors/ICacheServiceErrorMapper';\n\n/**\n * Encapsulates parameters for the `sendSubscribe` method.\n */\nexport interface SendSubscribeOptions {\n  cacheName: string;\n  topicName: string;\n  onItem: (item: TopicItem) => void;\n  onError: (\n    error: TopicSubscribe.Error,\n    subscription: TopicSubscribe.Subscription\n  ) => void;\n  onDiscontinuity: (discontinuity: TopicDiscontinuity) => void;\n  onHeartbeat: (heartbeat: TopicHeartbeat) => void;\n  subscriptionState: SubscriptionState;\n  subscription: TopicSubscribe.Subscription;\n\n  /**\n   * Whether the stream was restarted due to an error. If so, we skip the end stream handler\n   * logic as the error handler will have restarted the stream.\n   */\n  restartedDueToError: boolean;\n  /**\n   * If the first message is an error, we return an error immediately and do not subscribe.\n   */\n  firstMessage: boolean;\n}\n\n/**\n * Encapsulates parameters for the subscribe callback prepare methods.\n */\nexport interface PrepareSubscribeCallbackOptions extends SendSubscribeOptions {\n  /**\n   * The promise resolve function.\n   */\n  resolve: (\n    value: TopicSubscribe.Response | PromiseLike<TopicSubscribe.Subscription>\n  ) => void;\n}\n\nexport abstract class AbstractPubsubClient<TGrpcError>\n  implements IPubsubClient\n{\n  private readonly loggerFactory: MomentoLoggerFactory;\n  private readonly logger: MomentoLogger;\n  private readonly cacheServiceErrorMapper: ICacheServiceErrorMapper<TGrpcError>;\n\n  protected constructor(\n    loggerFactory: MomentoLoggerFactory,\n    logger: MomentoLogger,\n    cacheServiceErrorMapper: ICacheServiceErrorMapper<TGrpcError>\n  ) {\n    this.loggerFactory = loggerFactory;\n    this.logger = logger;\n    this.cacheServiceErrorMapper = cacheServiceErrorMapper;\n  }\n\n  protected getLogger(): MomentoLogger {\n    return this.logger;\n  }\n\n  protected getCacheServiceErrorMapper(): ICacheServiceErrorMapper<TGrpcError> {\n    return this.cacheServiceErrorMapper;\n  }\n\n  public async publish(\n    cacheName: string,\n    topicName: string,\n    value: string | Uint8Array\n  ): Promise<TopicPublish.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateTopicName(topicName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new TopicPublish.Error(err)\n      );\n      // )  new TopicPublish.Error(normalizeSdkError(err as Error));\n    }\n    this.logger.trace(\n      'Issuing publish request; topic: %s, message length: %s',\n      truncateString(topicName),\n      value.length\n    );\n\n    return await this.sendPublish(cacheName, topicName, value);\n  }\n\n  protected abstract sendPublish(\n    cacheName: string,\n    topicName: string,\n    value: string | Uint8Array\n  ): Promise<TopicPublish.Response>;\n\n  public async subscribe(\n    cacheName: string,\n    topicName: string,\n    options: SubscribeCallOptions\n  ): Promise<TopicSubscribe.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateTopicName(topicName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new TopicSubscribe.Error(err)\n      );\n    }\n    this.logger.trace(\n      'Issuing subscribe request; topic: %s',\n      truncateString(topicName)\n    );\n\n    const onItem =\n      options.onItem ??\n      (() => {\n        return;\n      });\n    const onError =\n      options.onError ??\n      (() => {\n        return;\n      });\n    const onDiscontinuity =\n      options.onDiscontinuity ??\n      (() => {\n        return;\n      });\n    const onHeartbeat =\n      options.onHeartbeat ??\n      (() => {\n        return;\n      });\n\n    const subscriptionState = new SubscriptionState();\n    const subscription = new TopicSubscribe.Subscription(\n      this.loggerFactory,\n      subscriptionState\n    );\n    return await this.sendSubscribe({\n      cacheName: cacheName,\n      topicName: topicName,\n      onItem: onItem,\n      onError: onError,\n      onDiscontinuity: onDiscontinuity,\n      onHeartbeat: onHeartbeat,\n      subscriptionState: subscriptionState,\n      subscription: subscription,\n      restartedDueToError: false,\n      firstMessage: true,\n    });\n  }\n\n  protected abstract sendSubscribe(\n    options: SendSubscribeOptions\n  ): Promise<TopicSubscribe.Response>;\n\n  protected prepareEndCallback(\n    options: PrepareSubscribeCallbackOptions\n  ): () => void {\n    return () => {\n      // We want to restart on stream end, except if:\n      // 1. The stream was cancelled by the caller.\n      // 2. The stream was restarted following an error.\n      if (options.restartedDueToError) {\n        this.logger.trace(\n          'Stream ended after error but was restarted on topic: %s',\n          options.topicName\n        );\n        return;\n      } else if (!options.subscriptionState.isSubscribed) {\n        this.logger.trace(\n          'Stream ended after unsubscribe on topic: %s',\n          options.topicName\n        );\n        return;\n      }\n\n      this.logger.trace(\n        'Stream ended on topic: %s; restarting.',\n        options.topicName\n      );\n\n      // When restarting the stream we do not do anything with the promises,\n      // because we should have already returned the subscription object to the user.\n      this.sendSubscribe(options)\n        .then(() => {\n          return;\n        })\n        .catch(() => {\n          return;\n        });\n    };\n  }\n\n  protected handleSubscribeError(\n    options: PrepareSubscribeCallbackOptions,\n    momentoError: TopicSubscribe.Error,\n    shouldReconnectSubscription: boolean\n  ): void {\n    this.logger.trace('Handling subscribe error');\n    // When the first message is an error, an irrecoverable error has happened,\n    // eg the cache does not exist. The user should not receive a subscription\n    // object but an error.\n    if (options.firstMessage) {\n      this.logger.trace(\n        'First message on subscription was an error; topic: %s, error: %s',\n        truncateString(options.topicName),\n        momentoError.toString()\n      );\n\n      options.resolve(momentoError);\n      options.subscription.unsubscribe();\n      return;\n    }\n\n    this.logger.trace(\n      'Subscribe error was not the first message on the stream.'\n    );\n\n    // Another special case is when the cache is not found.\n    // This happens here if the user deletes the cache in the middle of\n    // a subscription.\n    if (momentoError.errorCode() === MomentoErrorCode.CACHE_NOT_FOUND_ERROR) {\n      this.logger.trace(\n        'Stream ended due to cache not found error on topic: %s',\n        options.topicName\n      );\n      options.subscription.unsubscribe();\n      options.onError(momentoError, options.subscription);\n      return;\n    }\n\n    this.logger.trace(\n      'Checking to see if we should attempt to reconnect subscription.'\n    );\n\n    // For several types of errors having to with network interruptions, we wish to\n    // transparently restart the stream instead of propagating an error.\n    if (shouldReconnectSubscription) {\n      options.restartedDueToError = true;\n      const reconnectDelayMillis = 500;\n      this.logger.trace(\n        'Error occurred on subscription, possibly a network interruption. Will attempt to restart stream in %s ms.',\n        reconnectDelayMillis\n      );\n      sleep(reconnectDelayMillis)\n        .then(() => {\n          // When restarting the stream we do not do anything with the promises,\n          // because we should have already returned the subscription object to the user.\n          this.sendSubscribe(options)\n            .then(() => {\n              return;\n            })\n            .catch(e => {\n              this.logger.trace(\n                'Error when calling sendSubscribe to reconnect: %s',\n                e\n              );\n              return;\n            });\n          return;\n        })\n        .catch(e => {\n          this.logger.trace(\n            'Error when sleeping prior to sendSubscribe to reconnect: %s',\n            e\n          );\n          return;\n        });\n      return;\n    }\n\n    this.logger.trace('Subscribe error was not a re-connectable error.');\n\n    this.logger.trace(\n      'Subscribe error was not one of the known error types; calling error handler.'\n    );\n    options.onError(momentoError, options.subscription);\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2113, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2117, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk-core/src/internal/clients/cache/IControlClient.ts"],"sourcesContent":["import {CacheFlush, CreateCache, DeleteCache, ListCaches} from '../../../index';\n\nexport interface IControlClient {\n  createCache(cacheName: string): Promise<CreateCache.Response>;\n  deleteCache(cacheName: string): Promise<DeleteCache.Response>;\n  listCaches(): Promise<ListCaches.Response>;\n  flushCache(cacheName: string): Promise<CacheFlush.Response>;\n  close(): void;\n}\n"],"names":[],"mappings":""}},
    {"offset": {"line": 2121, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2125, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk-core/src/internal/clients/cache/IDataClient.ts"],"sourcesContent":["import {\n  CacheDelete,\n  CacheGet,\n  CacheIncrement,\n  CacheSet,\n  CacheSetIfNotExists,\n  CacheSetFetch,\n  CacheSetAddElements,\n  CacheSetContainsElement,\n  CacheSetContainsElements,\n  CacheSetRemoveElements,\n  CacheListFetch,\n  CacheListLength,\n  CacheListPushFront,\n  CacheListPushBack,\n  CacheListConcatenateBack,\n  CacheListConcatenateFront,\n  CacheListPopBack,\n  CacheListPopFront,\n  CacheListRemoveValue,\n  CacheListRetain,\n  CacheDictionarySetField,\n  CacheDictionarySetFields,\n  CacheDictionaryGetField,\n  CacheDictionaryFetch,\n  CacheDictionaryIncrement,\n  CacheDictionaryRemoveField,\n  CacheDictionaryRemoveFields,\n  CacheSortedSetFetch,\n  CacheSortedSetPutElement,\n  CacheSortedSetPutElements,\n  CacheSortedSetGetRank,\n  CacheSortedSetGetScore,\n  CacheSortedSetGetScores,\n  CacheSortedSetIncrementScore,\n  CacheSortedSetRemoveElement,\n  CacheSortedSetLength,\n  CacheSortedSetLengthByScore,\n  CollectionTtl,\n  SortedSetOrder,\n  CacheItemGetType,\n  CacheItemGetTtl,\n  CacheKeyExists,\n  CacheKeysExist,\n  CacheUpdateTtl,\n  CacheIncreaseTtl,\n  CacheDecreaseTtl,\n  CacheDictionaryLength,\n  CacheDictionaryGetFields,\n  CacheSetBatch,\n  CacheGetBatch,\n  CacheSetIfAbsent,\n  CacheSetIfPresent,\n  CacheSetIfEqual,\n  CacheSetIfNotEqual,\n  CacheSetIfPresentAndNotEqual,\n  CacheSetIfAbsentOrEqual,\n  CacheSetSample,\n  CacheSortedSetRemoveElements,\n  CacheSetPop,\n  CacheSetLength,\n} from '../../../index';\nimport {\n  GetBatchCallOptions,\n  GetCallOptions,\n  SetBatchCallOptions,\n  SetBatchItem,\n  SetCallOptions,\n  SetIfAbsentCallOptions,\n} from '../../../utils';\n\nexport interface IDataClient {\n  get(\n    cacheName: string,\n    key: string | Uint8Array,\n    options?: GetCallOptions\n  ): Promise<CacheGet.Response>;\n  set(\n    cacheName: string,\n    key: string | Uint8Array,\n    value: string | Uint8Array,\n    options?: SetCallOptions\n  ): Promise<CacheSet.Response>;\n  delete(\n    cacheName: string,\n    key: string | Uint8Array\n  ): Promise<CacheDelete.Response>;\n  increment(\n    cacheName: string,\n    field: string | Uint8Array,\n    amount: number,\n    ttl?: number\n  ): Promise<CacheIncrement.Response>;\n  setIfNotExists(\n    cacheName: string,\n    key: string | Uint8Array,\n    field: string | Uint8Array,\n    ttl?: number\n  ): Promise<CacheSetIfNotExists.Response>;\n  setIfAbsent(\n    cacheName: string,\n    key: string | Uint8Array,\n    field: string | Uint8Array,\n    options?: SetIfAbsentCallOptions\n  ): Promise<CacheSetIfAbsent.Response>;\n  setIfPresent(\n    cacheName: string,\n    key: string | Uint8Array,\n    field: string | Uint8Array,\n    ttl?: number\n  ): Promise<CacheSetIfPresent.Response>;\n  setIfEqual(\n    cacheName: string,\n    key: string | Uint8Array,\n    field: string | Uint8Array,\n    equal: string | Uint8Array,\n    ttl?: number\n  ): Promise<CacheSetIfEqual.Response>;\n  setIfNotEqual(\n    cacheName: string,\n    key: string | Uint8Array,\n    field: string | Uint8Array,\n    notEqual: string | Uint8Array,\n    ttl?: number\n  ): Promise<CacheSetIfNotEqual.Response>;\n  setIfPresentAndNotEqual(\n    cacheName: string,\n    key: string | Uint8Array,\n    field: string | Uint8Array,\n    notEqual: string | Uint8Array,\n    ttl?: number\n  ): Promise<CacheSetIfPresentAndNotEqual.Response>;\n  setIfAbsentOrEqual(\n    cacheName: string,\n    key: string | Uint8Array,\n    field: string | Uint8Array,\n    equal: string | Uint8Array,\n    ttl?: number\n  ): Promise<CacheSetIfAbsentOrEqual.Response>;\n  getBatch(\n    cacheName: string,\n    keys: Array<string | Uint8Array>,\n    options?: GetBatchCallOptions\n  ): Promise<CacheGetBatch.Response>;\n  setBatch(\n    cacheName: string,\n    items:\n      | Record<string, string | Uint8Array>\n      | Map<string | Uint8Array, string | Uint8Array>\n      | Array<SetBatchItem>,\n    options?: SetBatchCallOptions\n  ): Promise<CacheSetBatch.Response>;\n  setFetch(cacheName: string, setName: string): Promise<CacheSetFetch.Response>;\n  setAddElements(\n    cacheName: string,\n    setName: string,\n    elements: string[] | Uint8Array[],\n    ttl?: CollectionTtl\n  ): Promise<CacheSetAddElements.Response>;\n  setContainsElement(\n    cacheName: string,\n    setName: string,\n    element: string | Uint8Array\n  ): Promise<CacheSetContainsElement.Response>;\n  setContainsElements(\n    cacheName: string,\n    setName: string,\n    elements: string[] | Uint8Array[]\n  ): Promise<CacheSetContainsElements.Response>;\n  setRemoveElements(\n    cacheName: string,\n    setName: string,\n    elements: string[] | Uint8Array[]\n  ): Promise<CacheSetRemoveElements.Response>;\n  setSample(\n    cacheName: string,\n    setName: string,\n    limit: number\n  ): Promise<CacheSetSample.Response>;\n  setPop(\n    cacheName: string,\n    setName: string,\n    count: number\n  ): Promise<CacheSetPop.Response>;\n  setLength(\n    cacheName: string,\n    setName: string\n  ): Promise<CacheSetLength.Response>;\n  listFetch(\n    cacheName: string,\n    listName: string,\n    startIndex?: number,\n    endIndex?: number\n  ): Promise<CacheListFetch.Response>;\n  listLength(\n    cacheName: string,\n    listName: string\n  ): Promise<CacheListLength.Response>;\n  listPushFront(\n    cacheName: string,\n    listName: string,\n    value: string | Uint8Array,\n    truncateBackToSize?: number,\n    ttl?: CollectionTtl\n  ): Promise<CacheListPushFront.Response>;\n  listPushBack(\n    cacheName: string,\n    listName: string,\n    value: string | Uint8Array,\n    truncateFrontToSize?: number,\n    ttl?: CollectionTtl\n  ): Promise<CacheListPushBack.Response>;\n  listConcatenateBack(\n    cacheName: string,\n    listName: string,\n    values: string[] | Uint8Array[],\n    truncateFrontToSize?: number,\n    ttl?: CollectionTtl\n  ): Promise<CacheListConcatenateBack.Response>;\n  listConcatenateFront(\n    cacheName: string,\n    listName: string,\n    values: string[] | Uint8Array[],\n    truncateBackToSize?: number,\n    ttl?: CollectionTtl\n  ): Promise<CacheListConcatenateFront.Response>;\n  listPopBack(\n    cacheName: string,\n    listName: string\n  ): Promise<CacheListPopBack.Response>;\n  listPopFront(\n    cacheName: string,\n    listName: string\n  ): Promise<CacheListPopFront.Response>;\n  listRemoveValue(\n    cacheName: string,\n    listName: string,\n    value: string | Uint8Array\n  ): Promise<CacheListRemoveValue.Response>;\n  listRetain(\n    cacheName: string,\n    listName: string,\n    startIndex?: number,\n    endIndex?: number,\n    ttl?: CollectionTtl\n  ): Promise<CacheListRetain.Response>;\n  dictionarySetField(\n    cacheName: string,\n    dictionaryName: string,\n    field: string | Uint8Array,\n    value: string | Uint8Array,\n    ttl?: CollectionTtl\n  ): Promise<CacheDictionarySetField.Response>;\n  dictionarySetFields(\n    cacheName: string,\n    dictionaryName: string,\n    elements:\n      | Map<string | Uint8Array, string | Uint8Array>\n      | Record<string, string | Uint8Array>\n      | Array<[string, string | Uint8Array]>,\n    ttl?: CollectionTtl\n  ): Promise<CacheDictionarySetFields.Response>;\n  dictionaryGetField(\n    cacheName: string,\n    dictionaryName: string,\n    field: string | Uint8Array\n  ): Promise<CacheDictionaryGetField.Response>;\n  dictionaryGetFields(\n    cacheName: string,\n    dictionaryName: string,\n    fields: string[] | Uint8Array[]\n  ): Promise<CacheDictionaryGetFields.Response>;\n  dictionaryFetch(\n    cacheName: string,\n    dictionaryName: string\n  ): Promise<CacheDictionaryFetch.Response>;\n  dictionaryIncrement(\n    cacheName: string,\n    dictionaryName: string,\n    field: string | Uint8Array,\n    amount?: number,\n    ttl?: CollectionTtl\n  ): Promise<CacheDictionaryIncrement.Response>;\n  dictionaryRemoveField(\n    cacheName: string,\n    dictionaryName: string,\n    field: string | Uint8Array\n  ): Promise<CacheDictionaryRemoveField.Response>;\n  dictionaryRemoveFields(\n    cacheName: string,\n    dictionaryName: string,\n    fields: string[] | Uint8Array[]\n  ): Promise<CacheDictionaryRemoveFields.Response>;\n  dictionaryLength(\n    cacheName: string,\n    dictionaryName: string\n  ): Promise<CacheDictionaryLength.Response>;\n  sortedSetFetchByRank(\n    cacheName: string,\n    sortedSetName: string,\n    order?: SortedSetOrder,\n    startRank?: number,\n    endRank?: number\n  ): Promise<CacheSortedSetFetch.Response>;\n  sortedSetFetchByScore(\n    cacheName: string,\n    sortedSetName: string,\n    order?: SortedSetOrder,\n    minScore?: number,\n    maxScore?: number,\n    offset?: number,\n    count?: number\n  ): Promise<CacheSortedSetFetch.Response>;\n  sortedSetPutElement(\n    cacheName: string,\n    sortedSetName: string,\n    value: string | Uint8Array,\n    score: number,\n    ttl?: CollectionTtl\n  ): Promise<CacheSortedSetPutElement.Response>;\n  sortedSetPutElements(\n    cacheName: string,\n    sortedSetName: string,\n    elements:\n      | Map<string | Uint8Array, number>\n      | Record<string, number>\n      | Array<[string, number]>,\n    ttl?: CollectionTtl\n  ): Promise<CacheSortedSetPutElements.Response>;\n  sortedSetGetRank(\n    cacheName: string,\n    sortedSetName: string,\n    value: string | Uint8Array,\n    order?: SortedSetOrder\n  ): Promise<CacheSortedSetGetRank.Response>;\n  sortedSetGetScore(\n    cacheName: string,\n    sortedSetName: string,\n    value: string | Uint8Array\n  ): Promise<CacheSortedSetGetScore.Response>;\n  sortedSetGetScores(\n    cacheName: string,\n    sortedSetName: string,\n    values: string[] | Uint8Array[]\n  ): Promise<CacheSortedSetGetScores.Response>;\n  sortedSetIncrementScore(\n    cacheName: string,\n    sortedSetName: string,\n    value: string | Uint8Array,\n    amount?: number,\n    ttl?: CollectionTtl\n  ): Promise<CacheSortedSetIncrementScore.Response>;\n  sortedSetRemoveElement(\n    cacheName: string,\n    sortedSetName: string,\n    value: string | Uint8Array\n  ): Promise<CacheSortedSetRemoveElement.Response>;\n  sortedSetRemoveElements(\n    cacheName: string,\n    sortedSetName: string,\n    values: string[] | Uint8Array[]\n  ): Promise<CacheSortedSetRemoveElements.Response>;\n  sortedSetLength(\n    cacheName: string,\n    sortedSetName: string\n  ): Promise<CacheSortedSetLength.Response>;\n  sortedSetLengthByScore(\n    cacheName: string,\n    sortedSetName: string,\n    minScore?: number,\n    maxScore?: number\n  ): Promise<CacheSortedSetLengthByScore.Response>;\n  itemGetType(\n    cacheName: string,\n    key: string | Uint8Array\n  ): Promise<CacheItemGetType.Response>;\n  itemGetTtl(\n    cacheName: string,\n    key: string | Uint8Array\n  ): Promise<CacheItemGetTtl.Response>;\n  keyExists(\n    cacheName: string,\n    key: string | Uint8Array\n  ): Promise<CacheKeyExists.Response>;\n  keysExist(\n    cacheName: string,\n    keys: string[] | Uint8Array[]\n  ): Promise<CacheKeysExist.Response>;\n  updateTtl(\n    cacheName: string,\n    key: string | Uint8Array,\n    ttlMilliseconds: number\n  ): Promise<CacheUpdateTtl.Response>;\n  increaseTtl(\n    cacheName: string,\n    key: string | Uint8Array,\n    ttlMilliseconds: number\n  ): Promise<CacheIncreaseTtl.Response>;\n  decreaseTtl(\n    cacheName: string,\n    key: string | Uint8Array,\n    ttlMilliseconds: number\n  ): Promise<CacheDecreaseTtl.Response>;\n  close(): void;\n}\n"],"names":[],"mappings":""}},
    {"offset": {"line": 2129, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2133, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk-core/src/internal/clients/cache/IPingClient.ts"],"sourcesContent":["export interface IPingClient {\n  ping(): Promise<void>;\n}\n"],"names":[],"mappings":""}},
    {"offset": {"line": 2137, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2141, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk-core/src/internal/clients/cache/index.ts"],"sourcesContent":["export * from './AbstractCacheClient';\nexport * from '../../../clients/ICacheClient';\nexport * from './IControlClient';\nexport * from './IDataClient';\nexport * from './IPingClient';\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA,kKAAA;AACA,4IAAA;AACA,6JAAA;AACA,0JAAA;AACA,0JAAA"}},
    {"offset": {"line": 2169, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2173, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk-core/src/internal/clients/auth/AbstractAuthClient.ts"],"sourcesContent":["import {\n  GenerateApiKey,\n  ExpiresIn,\n  RefreshApiKey,\n  GenerateDisposableToken,\n  DisposableTokenScope,\n} from '../../../index';\nimport {IAuthClient} from '../../../clients/IAuthClient';\nimport {PermissionScope} from '../../../auth/tokens/permission-scope';\nimport {DisposableTokenProps} from '../../../auth/tokens/disposable-token-scope';\n\nexport interface BaseAuthClientProps {\n  createAuthClient: () => IAuthClient;\n}\nexport abstract class AbstractAuthClient implements IAuthClient {\n  // making these protected until we fully abstract away the nodejs client\n  protected readonly authClient: IAuthClient;\n\n  protected constructor(props: BaseAuthClientProps) {\n    this.authClient = props.createAuthClient();\n  }\n\n  /**\n   * Generates a new API key, along with a refresh token to refresh the API key before expiry.\n   *\n   * @param {PermissionScope} scope - controls the permissions that the new key will have\n   * @param {string} expiresIn - How long the API key should be valid for in epoch timestamp.\n   * @returns {Promise<GenerateApiKey.Response>} -\n   * {@link GenerateApiKey.Success} containing the API key, refresh token, origin and epoch timestamp when token expires.\n   * If the API key never expires, then no refresh token will be returned and expires at timestamp will be infinite.\n   * {@link GenerateApiKey.Error} on failure.\n   */\n  public async generateApiKey(\n    scope: PermissionScope,\n    expiresIn: ExpiresIn\n  ): Promise<GenerateApiKey.Response> {\n    return await this.authClient.generateApiKey(scope, expiresIn);\n  }\n\n  /**\n   * @deprecated please use `generateApiKey` instead\n   */\n  public async generateAuthToken(\n    scope: PermissionScope,\n    expiresIn: ExpiresIn\n  ): Promise<GenerateApiKey.Response> {\n    return await this.generateApiKey(scope, expiresIn);\n  }\n\n  /**\n   * Refreshes an API key.  Returns a new API key and refresh token, that will be able to be refreshed again in the future.\n   * The new API key will be valid for the same length of time as the original key, starting from the time of refresh.\n   * The original api key will still work until its expired.\n   *\n   * @param {string} refreshToken - Refresh token used to refresh the API key.\n   * @returns {Promise<RefreshApiKey.Response>} -\n   * {@link RefreshApiKey.Success} containing the new API key, refresh token, origin and epoch timestamp when the API key expires.\n   * {@link RefreshApiKey.Error} on failure.\n   */\n  public async refreshApiKey(\n    refreshToken: string\n  ): Promise<RefreshApiKey.Response> {\n    return await this.authClient.refreshApiKey(refreshToken);\n  }\n\n  /**\n   * @deprecated please use `refreshApiKey` instead\n   */\n  public async refreshAuthToken(\n    refreshToken: string\n  ): Promise<RefreshApiKey.Response> {\n    return await this.refreshApiKey(refreshToken);\n  }\n\n  /**\n   * Generates a new disposable, fine-grained access token.\n   *\n   * @param {DisposableTokenScope} scope - controls the permissions that the new token will have\n   * @param {string} expiresIn - How long the token is valid for in epoch timestamp.\n   * @param {DisposableTokenProps} disposableTokenProps - Additional properties for the API\n   * @returns {Promise<GenerateDisposableToken.Response>} -\n   * {@link GenerateDisposableToken.Success} containing the api token, origin and epoch timestamp when token expires.\n   * {@link GenerateDisposableToken.Error} on failure.\n   */\n  public async generateDisposableToken(\n    scope: DisposableTokenScope,\n    expiresIn: ExpiresIn,\n    disposableTokenProps?: DisposableTokenProps\n  ): Promise<GenerateDisposableToken.Response> {\n    return await this.authClient.generateDisposableToken(\n      scope,\n      expiresIn,\n      disposableTokenProps\n    );\n  }\n}\n"],"names":[],"mappings":";;;;;AAcA,MAAsB;IAIpB,YAAsB,KAA0B,CAAA;QAC9C,IAAI,CAAC,UAAU,GAAG,MAAM,gBAAgB;IAC1C;IAEA;;;;;;;;;QAUO,MAAM,eACX,KAAsB,EACtB,SAAoB,EAAA;QAEpB,OAAO,MAAM,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,OAAO;IACrD;IAEA;;QAGO,MAAM,kBACX,KAAsB,EACtB,SAAoB,EAAA;QAEpB,OAAO,MAAM,IAAI,CAAC,cAAc,CAAC,OAAO;IAC1C;IAEA;;;;;;;;;QAUO,MAAM,cACX,YAAoB,EAAA;QAEpB,OAAO,MAAM,IAAI,CAAC,UAAU,CAAC,aAAa,CAAC;IAC7C;IAEA;;QAGO,MAAM,iBACX,YAAoB,EAAA;QAEpB,OAAO,MAAM,IAAI,CAAC,aAAa,CAAC;IAClC;IAEA;;;;;;;;;QAUO,MAAM,wBACX,KAA2B,EAC3B,SAAoB,EACpB,oBAA2C,EAAA;QAE3C,OAAO,MAAM,IAAI,CAAC,UAAU,CAAC,uBAAuB,CAClD,OACA,WACA;IAEJ;;AAhFF,QAAA,kBAAA,GAAA"}},
    {"offset": {"line": 2230, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2234, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk-core/src/internal/clients/auth/index.ts"],"sourcesContent":["export * from './AbstractAuthClient';\nexport * from '../../../clients/IAuthClient';\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA,gKAAA;AACA,2IAAA"}},
    {"offset": {"line": 2259, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2263, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk-core/src/internal/clients/pubsub/IPubsubClient.ts"],"sourcesContent":["import {\n  TopicPublish,\n  TopicSubscribe,\n  SubscribeCallOptions,\n} from '../../../index';\n\nexport interface IPubsubClient {\n  publish(\n    cacheName: string,\n    topicName: string,\n    value: string | Uint8Array\n  ): Promise<TopicPublish.Response>;\n  subscribe(\n    cacheName: string,\n    topicName: string,\n    options: SubscribeCallOptions\n  ): Promise<TopicSubscribe.Response>;\n}\n"],"names":[],"mappings":""}},
    {"offset": {"line": 2267, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2271, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk-core/src/internal/clients/pubsub/index.ts"],"sourcesContent":["export * from '../../../clients/ITopicClient';\nexport * from './IPubsubClient';\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA,4IAAA;AACA,6JAAA"}},
    {"offset": {"line": 2296, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2300, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk-core/src/internal/clients/leaderboard/AbstractLeaderboard.ts"],"sourcesContent":["import {\n  ILeaderboard,\n  LeaderboardFetchByRankCallOptions,\n  LeaderboardFetchByScoreCallOptions,\n  LeaderboardGetRankCallOptions,\n} from '../../../clients/ILeaderboard';\nimport {\n  LeaderboardDelete,\n  LeaderboardFetch,\n  LeaderboardLength,\n  LeaderboardRemoveElements,\n  LeaderboardUpsert,\n} from '../../../messages/responses/leaderboard';\nimport {ILeaderboardDataClient} from './ILeaderboardDataClient';\n\nexport abstract class AbstractLeaderboard implements ILeaderboard {\n  protected readonly cacheName: string;\n  protected readonly leaderboardName: string;\n  protected readonly dataClient: ILeaderboardDataClient;\n\n  protected constructor(\n    cacheName: string,\n    leaderboardName: string,\n    dataClient: ILeaderboardDataClient\n  ) {\n    this.cacheName = cacheName;\n    this.leaderboardName = leaderboardName;\n    this.dataClient = dataClient;\n  }\n\n  /**\n   * Updates elements in a leaderboard or inserts elements if they do not already exist.\n   * The leaderboard is also created if it does not already exist.\n   * Note: can upsert a maximum of 8192 elements at a time.\n   *\n   * @param {Map<number, number>} elements - The ID->score pairs to add to the leaderboard.\n   * @returns {Promise<LeaderboardUpsert.Response>} -\n   * {@link LeaderboardUpsert.Success} on success.\n   * {@link LeaderboardUpsert.Error} on failure.\n   */\n  public async upsert(\n    elements: Record<number, number> | Map<number, number>\n  ): Promise<LeaderboardUpsert.Response> {\n    return await this.dataClient.upsert(\n      this.cacheName,\n      this.leaderboardName,\n      elements\n    );\n  }\n\n  /**\n   * Fetch the elements in the given leaderboard by score.\n   * Note: can fetch a maximum of 8192 elements at a time.\n   *\n   * @param {LeaderboardFetchByScoreCallOptions} options\n   * @param {number} [options.minScore] - The minimum score (inclusive) of the\n   * elements to fetch. Defaults to negative infinity.\n   * @param {number} [options.maxScore] - The maximum score (exclusive) of the\n   * elements to fetch. Defaults to positive infinity.\n   * @param {LeaderboardOrder} [options.order] - The order to fetch the elements in.\n   * Defaults to ascending, meaning 0 is the lowest-scoring rank.\n   * @param {number} [options.offset] - The number of elements to skip before\n   * returning the first element. Defaults to 0. Note: this is not the score of\n   * the first element to return, but the number of elements of the result set\n   * to skip before returning the first element.\n   * @param {number} [options.count] - The maximum number of elements to return.\n   * Defaults to 8192, which is the maximum that can be fetched at a time.\n   * @returns {Promise<LeaderboardFetch.Response>} -\n   * {@link LeaderboardFetch.Success} containing the requested elements.\n   * {@link LeaderboardFetch.Error} on failure.\n   */\n  public async fetchByScore(\n    options?: LeaderboardFetchByScoreCallOptions\n  ): Promise<LeaderboardFetch.Response> {\n    return await this.dataClient.fetchByScore(\n      this.cacheName,\n      this.leaderboardName,\n      options?.minScore,\n      options?.maxScore,\n      options?.order,\n      options?.offset,\n      options?.count\n    );\n  }\n\n  /**\n   * Fetch the elements in the given leaderboard by index (rank).\n   * Note: can fetch a maximum of 8192 elements at a time and rank\n   * is 0-based (index begins at 0).\n   *\n   * @param {number} [startRank] - The rank of the first element to\n   * fetch. This rank is inclusive, ie the element at this rank\n   * will be fetched. Ranks can be used to manually paginate through the leaderboard\n   * in batches of 8192 elements (e.g. request 0-8192, then 8192-16384, etc).\n   * @param {number} [endRank] - The rank of the last element to fetch.\n   * This rank is exclusive, ie the element at this rank will not be fetched.\n   * Ranks can be used to manually paginate through the leaderboard\n   * in batches of 8192 elements (e.g. request 0-8192, then 8192-16384, etc).\n   * @param {LeaderboardFetchByRankOptions} options\n   * @param {LeaderboardOrder} [options.order] - The order to fetch the elements in.\n   * Defaults to ascending, meaning 0 is the lowest-scoring rank.\n   * @returns {Promise<LeaderboardFetch.Response>} -\n   * {@link LeaderboardFetch.Success} containing the requested elements.\n   * {@link LeaderboardFetch.Error} on failure.\n   */\n  public async fetchByRank(\n    startRank: number,\n    endRank: number,\n    options?: LeaderboardFetchByRankCallOptions\n  ): Promise<LeaderboardFetch.Response> {\n    return await this.dataClient.fetchByRank(\n      this.cacheName,\n      this.leaderboardName,\n      startRank,\n      endRank,\n      options?.order\n    );\n  }\n\n  /**\n   * Look up the rank of an element in the leaderboard given the element id.\n   * Note: rank is 0-based (index begins at 0).\n   *\n   * @param {number} ids - The ids of the elements whose rank we are retrieving.\n   * @param {LeaderboardGetRankCallOptions} options\n   * @param {LeaderboardOrder} [options.order] - The order to fetch the elements in.\n   * Defaults to ascending, meaning 0 is the lowest-scoring rank.\n   * @returns {Promise<LeaderboardFetch.Response>}\n   * {@link LeaderboardFetch.Success} containing the requested elements.\n   * {@link LeaderboardFetch.Error} on failure.\n   */\n  public async getRank(\n    ids: Array<number>,\n    options?: LeaderboardGetRankCallOptions\n  ): Promise<LeaderboardFetch.Response> {\n    return await this.dataClient.getRank(\n      this.cacheName,\n      this.leaderboardName,\n      ids,\n      options?.order\n    );\n  }\n\n  /**\n   * Fetch length (number of items) of leaderboard\n   *\n   * @returns {Promise<LeaderboardLength.Response>}\n   * {@link LeaderboardLength.Success} containing the length if the leaderboard exists.\n   * {@link LeaderboardLength.Error} on failure.\n   */\n  public async length(): Promise<LeaderboardLength.Response> {\n    return await this.dataClient.length(this.cacheName, this.leaderboardName);\n  }\n\n  /**\n   * Remove multiple elements from the given leaderboard\n   * Note: can remove a maximum of 8192 elements at a time.\n   *\n   * @param {Array<number>} ids - The IDs of the elements to remove from the leaderboard.\n   * @returns {Promise<LeaderboardRemoveElements.Response>}\n   * {@link LeaderboardRemoveElements.Success} if the elements were successfully removed.\n   * {@link LeaderboardRemoveElements.Error} on failure.\n   */\n  public async removeElements(\n    ids: Array<number>\n  ): Promise<LeaderboardRemoveElements.Response> {\n    return await this.dataClient.removeElements(\n      this.cacheName,\n      this.leaderboardName,\n      ids\n    );\n  }\n\n  /**\n   * Delete the given leaderboard\n   *\n   * @returns {Promise<LeaderboardDelete.Response>}\n   * {@link LeaderboardDelete.Success} on success.\n   * {@link LeaderboardDelete.Error} on failure.\n   */\n  public async delete(): Promise<LeaderboardDelete.Response> {\n    return await this.dataClient.delete(this.cacheName, this.leaderboardName);\n  }\n}\n"],"names":[],"mappings":";;;;;AAeA,MAAsB;IAKpB,YACE,SAAiB,EACjB,eAAuB,EACvB,UAAkC,CAAA;QAElC,IAAI,CAAC,SAAS,GAAG;QACjB,IAAI,CAAC,eAAe,GAAG;QACvB,IAAI,CAAC,UAAU,GAAG;IACpB;IAEA;;;;;;;;;QAUO,MAAM,OACX,QAAsD,EAAA;QAEtD,OAAO,MAAM,IAAI,CAAC,UAAU,CAAC,MAAM,CACjC,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,eAAe,EACpB;IAEJ;IAEA;;;;;;;;;;;;;;;;;;;;QAqBO,MAAM,aACX,OAA4C,EAAA;QAE5C,OAAO,MAAM,IAAI,CAAC,UAAU,CAAC,YAAY,CACvC,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,eAAe,EACpB,YAAO,QAAP,YAAO,KAAA,IAAA,KAAA,IAAP,QAAS,QAAQ,EACjB,YAAO,QAAP,YAAO,KAAA,IAAA,KAAA,IAAP,QAAS,QAAQ,EACjB,YAAO,QAAP,YAAO,KAAA,IAAA,KAAA,IAAP,QAAS,KAAK,EACd,YAAO,QAAP,YAAO,KAAA,IAAA,KAAA,IAAP,QAAS,MAAM,EACf,YAAO,QAAP,YAAO,KAAA,IAAA,KAAA,IAAP,QAAS,KAAK;IAElB;IAEA;;;;;;;;;;;;;;;;;;;QAoBO,MAAM,YACX,SAAiB,EACjB,OAAe,EACf,OAA2C,EAAA;QAE3C,OAAO,MAAM,IAAI,CAAC,UAAU,CAAC,WAAW,CACtC,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,eAAe,EACpB,WACA,SACA,YAAO,QAAP,YAAO,KAAA,IAAA,KAAA,IAAP,QAAS,KAAK;IAElB;IAEA;;;;;;;;;;;QAYO,MAAM,QACX,GAAkB,EAClB,OAAuC,EAAA;QAEvC,OAAO,MAAM,IAAI,CAAC,UAAU,CAAC,OAAO,CAClC,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,eAAe,EACpB,KACA,YAAO,QAAP,YAAO,KAAA,IAAA,KAAA,IAAP,QAAS,KAAK;IAElB;IAEA;;;;;;QAOO,MAAM,SAAM;QACjB,OAAO,MAAM,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,eAAe;IAC1E;IAEA;;;;;;;;QASO,MAAM,eACX,GAAkB,EAAA;QAElB,OAAO,MAAM,IAAI,CAAC,UAAU,CAAC,cAAc,CACzC,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,eAAe,EACpB;IAEJ;IAEA;;;;;;QAOO,MAAM,SAAM;QACjB,OAAO,MAAM,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,eAAe;IAC1E;;AAvKF,QAAA,mBAAA,GAAA"}},
    {"offset": {"line": 2413, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2417, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk-core/src/internal/clients/leaderboard/index.ts"],"sourcesContent":["export * from '../../../clients/ILeaderboard';\nexport * from '../../../clients/ILeaderboardClient';\nexport * from './AbstractLeaderboard';\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA,4IAAA;AACA,kJAAA;AACA,wKAAA"}},
    {"offset": {"line": 2443, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2447, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk-core/src/internal/clients/storage/AbstractStorageClient.ts"],"sourcesContent":["import {\n  CreateStore,\n  DeleteStore,\n  ListStores,\n  StorageGet,\n  StoragePut,\n  StorageDelete,\n} from '../../../index';\nimport {IStorageDataClient} from './IStorageDataClient';\nimport {IStorageClient} from '../../../clients/IStorageClient';\nimport {IStorageControlClient} from './IStorageControlClient';\n\nexport abstract class AbstractStorageClient implements IStorageClient {\n  protected readonly dataClients: IStorageDataClient[];\n  protected readonly controlClient: IStorageControlClient;\n  private nextDataClientIndex: number;\n\n  protected constructor(\n    dataClients: IStorageDataClient[],\n    controlClient: IStorageControlClient\n  ) {\n    this.dataClients = dataClients;\n    this.controlClient = controlClient;\n\n    // We round-robin the requests through all of our clients.  Since javascript\n    // is single-threaded, we don't have to worry about thread safety on this\n    // index variable.\n    this.nextDataClientIndex = 0;\n  }\n\n  createStore(storeName: string): Promise<CreateStore.Response> {\n    return this.controlClient.createStore(storeName);\n  }\n\n  listStores(): Promise<ListStores.Response> {\n    return this.controlClient.listStores();\n  }\n\n  deleteStore(storeName: string): Promise<DeleteStore.Response> {\n    return this.controlClient.deleteStore(storeName);\n  }\n\n  get(storeName: string, key: string): Promise<StorageGet.Response> {\n    return this.getNextDataClient().get(storeName, key);\n  }\n\n  putInt(\n    storeName: string,\n    key: string,\n    value: number\n  ): Promise<StoragePut.Response> {\n    return this.getNextDataClient().putInt(storeName, key, value);\n  }\n\n  putDouble(\n    storeName: string,\n    key: string,\n    value: number\n  ): Promise<StoragePut.Response> {\n    return this.getNextDataClient().putDouble(storeName, key, value);\n  }\n\n  putString(\n    storeName: string,\n    key: string,\n    value: string\n  ): Promise<StoragePut.Response> {\n    return this.getNextDataClient().putString(storeName, key, value);\n  }\n\n  putBytes(\n    storeName: string,\n    key: string,\n    value: Uint8Array\n  ): Promise<StoragePut.Response> {\n    return this.getNextDataClient().putBytes(storeName, key, value);\n  }\n\n  delete(storeName: string, key: string): Promise<StorageDelete.Response> {\n    return this.getNextDataClient().delete(storeName, key);\n  }\n\n  private getNextDataClient(): IStorageDataClient {\n    const client = this.dataClients[this.nextDataClientIndex];\n    this.nextDataClientIndex =\n      (this.nextDataClientIndex + 1) % this.dataClients.length;\n    return client;\n  }\n\n  abstract close(): void;\n}\n"],"names":[],"mappings":";;;;;AAYA,MAAsB;IAKpB,YACE,WAAiC,EACjC,aAAoC,CAAA;QAEpC,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,aAAa,GAAG;QAErB,4EAA4E;QAC5E,yEAAyE;QACzE,kBAAkB;QAClB,IAAI,CAAC,mBAAmB,GAAG;IAC7B;IAEA,YAAY,SAAiB,EAAA;QAC3B,OAAO,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC;IACxC;IAEA,aAAU;QACR,OAAO,IAAI,CAAC,aAAa,CAAC,UAAU;IACtC;IAEA,YAAY,SAAiB,EAAA;QAC3B,OAAO,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC;IACxC;IAEA,IAAI,SAAiB,EAAE,GAAW,EAAA;QAChC,OAAO,IAAI,CAAC,iBAAiB,GAAG,GAAG,CAAC,WAAW;IACjD;IAEA,OACE,SAAiB,EACjB,GAAW,EACX,KAAa,EAAA;QAEb,OAAO,IAAI,CAAC,iBAAiB,GAAG,MAAM,CAAC,WAAW,KAAK;IACzD;IAEA,UACE,SAAiB,EACjB,GAAW,EACX,KAAa,EAAA;QAEb,OAAO,IAAI,CAAC,iBAAiB,GAAG,SAAS,CAAC,WAAW,KAAK;IAC5D;IAEA,UACE,SAAiB,EACjB,GAAW,EACX,KAAa,EAAA;QAEb,OAAO,IAAI,CAAC,iBAAiB,GAAG,SAAS,CAAC,WAAW,KAAK;IAC5D;IAEA,SACE,SAAiB,EACjB,GAAW,EACX,KAAiB,EAAA;QAEjB,OAAO,IAAI,CAAC,iBAAiB,GAAG,QAAQ,CAAC,WAAW,KAAK;IAC3D;IAEA,OAAO,SAAiB,EAAE,GAAW,EAAA;QACnC,OAAO,IAAI,CAAC,iBAAiB,GAAG,MAAM,CAAC,WAAW;IACpD;IAEQ,oBAAiB;QACvB,MAAM,SAAS,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,mBAAmB,CAAC;QACzD,IAAI,CAAC,mBAAmB,GACtB,CAAC,IAAI,CAAC,mBAAmB,GAAG,CAAC,IAAI,IAAI,CAAC,WAAW,CAAC,MAAM;QAC1D,OAAO;IACT;;AA3EF,QAAA,qBAAA,GAAA"}},
    {"offset": {"line": 2495, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2499, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk-core/src/internal/clients/storage/IStorageControlClient.ts"],"sourcesContent":["import {CreateStore, DeleteStore, ListStores} from '../../../index';\n\nexport interface IStorageControlClient {\n  createStore(storeName: string): Promise<CreateStore.Response>;\n  deleteStore(storeName: string): Promise<DeleteStore.Response>;\n  listStores(): Promise<ListStores.Response>;\n  close(): void;\n}\n"],"names":[],"mappings":""}},
    {"offset": {"line": 2503, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2507, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk-core/src/internal/clients/storage/IStorageDataClient.ts"],"sourcesContent":["import {StorageGet, StoragePut, StorageDelete} from '../../../index';\n\nexport interface IStorageDataClient {\n  get(storeName: string, key: string): Promise<StorageGet.Response>;\n  putInt(\n    storeName: string,\n    key: string,\n    value: number\n  ): Promise<StoragePut.Response>;\n  putDouble(\n    storeName: string,\n    key: string,\n    value: number\n  ): Promise<StoragePut.Response>;\n  putString(\n    storeName: string,\n    key: string,\n    value: string\n  ): Promise<StoragePut.Response>;\n  putBytes(\n    storeName: string,\n    key: string,\n    value: Uint8Array\n  ): Promise<StoragePut.Response>;\n  delete(storeName: string, key: string): Promise<StorageDelete.Response>;\n  close(): void;\n}\n"],"names":[],"mappings":""}},
    {"offset": {"line": 2511, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2515, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk-core/src/internal/clients/storage/index.ts"],"sourcesContent":["export * from './AbstractStorageClient';\nexport * from './IStorageControlClient';\nexport * from './IStorageDataClient';\nexport * from '../../../clients/IStorageClient';\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA,sKAAA;AACA,sKAAA;AACA,mKAAA;AACA,8IAAA"}},
    {"offset": {"line": 2542, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2546, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk-core/src/internal/clients/index.ts"],"sourcesContent":["export * from './cache';\nexport * from './auth';\nexport * from './pubsub';\nexport * from './leaderboard';\nexport * from './storage';\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA,oJAAA;AACA,mJAAA;AACA,qJAAA;AACA,0JAAA;AACA,sJAAA"}},
    {"offset": {"line": 2574, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}