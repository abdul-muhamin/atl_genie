{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk/src/internal/grpc/headers-interceptor.ts"],"sourcesContent":["import {InterceptingCall, Interceptor} from '@grpc/grpc-js';\n\nexport class Header {\n  public readonly onceOnlyHeaders: string[] = ['agent', 'runtime-version'];\n  public readonly name: string;\n  public readonly value: string;\n\n  /**\n   * @param {string} name\n   * @param {string} value\n   */\n  constructor(name: string, value: string) {\n    this.name = name;\n    this.value = value;\n  }\n}\n\nexport class HeaderInterceptor {\n  public static createHeadersInterceptor(headers: Header[]): Interceptor {\n    const headersToAddOnce = headers.filter(header =>\n      header.onceOnlyHeaders.includes(header.name)\n    );\n    const headersToAddEveryTime = headers.filter(\n      header => !header.onceOnlyHeaders.includes(header.name)\n    );\n    let areOnlyOnceHeadersSent = false;\n    return (options, nextCall) => {\n      return new InterceptingCall(nextCall(options), {\n        start: (metadata, listener, next) => {\n          headersToAddEveryTime.forEach(h => {\n            metadata.set(h.name, h.value);\n          });\n          if (!areOnlyOnceHeadersSent) {\n            areOnlyOnceHeadersSent = true;\n            headersToAddOnce.forEach(h => metadata.add(h.name, h.value));\n          }\n          next(metadata, {});\n        },\n      });\n    };\n  }\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA;AAEA,MAAa;IAKX;;;QAIA,YAAY,IAAY,EAAE,KAAa,CAAA;QARvB,IAAA,CAAA,eAAe,GAAa;YAAC;YAAS;SAAkB;QAStE,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,KAAK,GAAG;IACf;;AAZF,QAAA,MAAA,GAAA;AAeA,MAAa;IACJ,OAAO,yBAAyB,OAAiB,EAAA;QACtD,MAAM,mBAAmB,QAAQ,MAAM,CAAC,CAAA,SACtC,OAAO,eAAe,CAAC,QAAQ,CAAC,OAAO,IAAI;QAE7C,MAAM,wBAAwB,QAAQ,MAAM,CAC1C,CAAA,SAAU,CAAC,OAAO,eAAe,CAAC,QAAQ,CAAC,OAAO,IAAI;QAExD,IAAI,yBAAyB;QAC7B,OAAO,CAAC,SAAS;YACf,OAAO,IAAI,UAAA,gBAAgB,CAAC,SAAS,UAAU;gBAC7C,OAAO,CAAC,UAAU,UAAU;oBAC1B,sBAAsB,OAAO,CAAC,CAAA;wBAC5B,SAAS,GAAG,CAAC,EAAE,IAAI,EAAE,EAAE,KAAK;oBAC9B;oBACA,IAAI,CAAC,wBAAwB;wBAC3B,yBAAyB;wBACzB,iBAAiB,OAAO,CAAC,CAAA,IAAK,SAAS,GAAG,CAAC,EAAE,IAAI,EAAE,EAAE,KAAK;;oBAE5D,KAAK,UAAU,CAAA;gBACjB;;QAEJ;IACF;;AAvBF,QAAA,iBAAA,GAAA"}},
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 50, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk/src/internal/grpc/idle-grpc-client-wrapper.ts"],"sourcesContent":["import {CloseableGrpcClient, GrpcClientWrapper} from './grpc-client-wrapper';\nimport {MomentoLogger, MomentoLoggerFactory} from '@gomomento/sdk-core';\n\nexport interface IdleGrpcClientWrapperProps<T extends CloseableGrpcClient> {\n  clientFactoryFn: () => T;\n  loggerFactory: MomentoLoggerFactory;\n  maxIdleMillis: number;\n  maxClientAgeMillis?: number;\n}\n\n/**\n * This wrapper allows us to ensure that a grpc client is not re-used if it has been idle\n * for longer than a specified period of time.  This is important in some environments,\n * such as AWS Lambda, where the runtime may be paused indefinitely between invocations.\n * In such cases we have observed that while the runtime is suspended, the connection\n * may have been closed by the server. (e.g., AWS NLB has an idle timeout of 350s:\n * https://docs.aws.amazon.com/elasticloadbalancing/latest/network/network-load-balancers.html#connection-idle-timeout )\n * When the runtime resumes, it does not recognize that the connection has been closed,\n * and it may continue to attempt to send bytes to it, resulting in client-side timeouts\n * (DEADLINE_EXCEEDED).  Forcefully refreshing the client if it has been idle for too\n * long will prevent this.\n *\n * NOTE: We can't rely on keepalive pings in this scenario, because the lambda runtime\n * may be suspended in such a way that background tasks such as the keepalive pings\n * will not be able to execute.\n */\nexport class IdleGrpcClientWrapper<T extends CloseableGrpcClient>\n  implements GrpcClientWrapper<T>\n{\n  private readonly logger: MomentoLogger;\n\n  private client: T;\n  private readonly clientFactoryFn: () => T;\n\n  private readonly maxIdleMillis: number;\n  private lastAccessTime: number;\n  private clientCreatedTime: number;\n  private readonly maxClientAgeMillis?: number;\n\n  constructor(props: IdleGrpcClientWrapperProps<T>) {\n    this.logger = props.loggerFactory.getLogger(this);\n    this.clientFactoryFn = props.clientFactoryFn;\n    this.client = this.clientFactoryFn();\n    this.maxIdleMillis = props.maxIdleMillis;\n    this.lastAccessTime = Date.now();\n    this.maxClientAgeMillis = props.maxClientAgeMillis;\n    this.clientCreatedTime = Date.now();\n  }\n\n  getClient(): T {\n    this.logger.trace(\n      `Checking to see if client has been idle for more than ${this.maxIdleMillis} ms`\n    );\n    if (Date.now() - this.lastAccessTime > this.maxIdleMillis) {\n      this.logger.info(\n        `Client has been idle for more than ${this.maxIdleMillis} ms; reconnecting.`\n      );\n      this.client.close();\n      this.client = this.clientFactoryFn();\n    }\n\n    if (this.maxClientAgeMillis !== undefined) {\n      this.logger.trace(\n        `Checking to see if client was created more than ${this.maxClientAgeMillis} ms`\n      );\n      if (Date.now() - this.clientCreatedTime > this.maxClientAgeMillis) {\n        this.logger.info(\n          `Client was created more than ${this.maxClientAgeMillis} millis ago; recreating as asked.`\n        );\n        this.client.close();\n        this.client = this.clientFactoryFn();\n        this.clientCreatedTime = Date.now();\n      }\n    }\n\n    this.lastAccessTime = Date.now();\n    return this.client;\n  }\n}\n"],"names":[],"mappings":";;;;;AAUA;;;;;;;;;;;;;;;IAgBA,MAAa;IAaX,YAAY,KAAoC,CAAA;QAC9C,IAAI,CAAC,MAAM,GAAG,MAAM,aAAa,CAAC,SAAS,CAAC,IAAI;QAChD,IAAI,CAAC,eAAe,GAAG,MAAM,eAAe;QAC5C,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,eAAe;QAClC,IAAI,CAAC,aAAa,GAAG,MAAM,aAAa;QACxC,IAAI,CAAC,cAAc,GAAG,KAAK,GAAG;QAC9B,IAAI,CAAC,kBAAkB,GAAG,MAAM,kBAAkB;QAClD,IAAI,CAAC,iBAAiB,GAAG,KAAK,GAAG;IACnC;IAEA,YAAS;QACP,IAAI,CAAC,MAAM,CAAC,KAAK,CACf,CAAA,sDAAA,EAAyD,IAAI,CAAC,aAAa,CAAA,GAAA,CAAK;QAElF,IAAI,KAAK,GAAG,KAAK,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,aAAa,EAAE;YACzD,IAAI,CAAC,MAAM,CAAC,IAAI,CACd,CAAA,mCAAA,EAAsC,IAAI,CAAC,aAAa,CAAA,kBAAA,CAAoB;YAE9E,IAAI,CAAC,MAAM,CAAC,KAAK;YACjB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,eAAe;;QAGpC,IAAI,IAAI,CAAC,kBAAkB,KAAK,WAAW;YACzC,IAAI,CAAC,MAAM,CAAC,KAAK,CACf,CAAA,gDAAA,EAAmD,IAAI,CAAC,kBAAkB,CAAA,GAAA,CAAK;YAEjF,IAAI,KAAK,GAAG,KAAK,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,kBAAkB,EAAE;gBACjE,IAAI,CAAC,MAAM,CAAC,IAAI,CACd,CAAA,6BAAA,EAAgC,IAAI,CAAC,kBAAkB,CAAA,iCAAA,CAAmC;gBAE5F,IAAI,CAAC,MAAM,CAAC,KAAK;gBACjB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,eAAe;gBAClC,IAAI,CAAC,iBAAiB,GAAG,KAAK,GAAG;;;QAIrC,IAAI,CAAC,cAAc,GAAG,KAAK,GAAG;QAC9B,OAAO,IAAI,CAAC,MAAM;IACpB;;AAnDF,QAAA,qBAAA,GAAA"}},
    {"offset": {"line": 101, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 105, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk/src/internal/grpc/retry-interceptor.ts"],"sourcesContent":["// This is temporary work around defining our own interceptor to power re-try's\n// Longer term with this proposal re-try's should be added to grpc core, and we\n// can leverage by defining a retry policy.\n// https://github.com/grpc/proposal/blob/master/A6-client-retries.md#grpc-retry-design\n// For now we use re-try interceptor inspired by example here in interceptor proposal for nodejs grpc core\n// https://github.com/grpc/proposal/blob/master/L5-node-client-interceptors.md#advanced-examples\n// Main difference is that we maintain a allow list of retryable status codes vs trying all.\nimport {\n  InterceptingCall,\n  Interceptor,\n  Listener,\n  Metadata,\n  StatusObject,\n} from '@grpc/grpc-js';\nimport {RetryStrategy} from '../../config/retry/retry-strategy';\nimport {Status} from '@grpc/grpc-js/build/src/constants';\nimport {MomentoLoggerFactory} from '../../';\nimport {NoRetryStrategy} from '../../config/retry/no-retry-strategy';\n\nexport interface RetryInterceptorProps {\n  clientName: string;\n  loggerFactory: MomentoLoggerFactory;\n  overallRequestTimeoutMs: number;\n  retryStrategy?: RetryStrategy;\n}\n\nexport class RetryInterceptor {\n  // TODO: We need to send retry count information to the server so that we\n  // will have some visibility into how often this is happening to customers:\n  // https://github.com/momentohq/client-sdk-nodejs/issues/80\n  public static createRetryInterceptor(\n    props: RetryInterceptorProps\n  ): Interceptor {\n    const logger = props.loggerFactory.getLogger(RetryInterceptor.name);\n\n    const retryStrategy: RetryStrategy =\n      props.retryStrategy ??\n      new NoRetryStrategy({loggerFactory: props.loggerFactory});\n\n    const overallRequestTimeoutMs = props.overallRequestTimeoutMs;\n    const deadlineOffset =\n      retryStrategy.responseDataReceivedTimeoutMillis ??\n      props.overallRequestTimeoutMs;\n\n    logger.trace(\n      `Creating RetryInterceptor (for ${\n        props.clientName\n      }); overall request timeout offset: ${overallRequestTimeoutMs} ms; retry strategy responseDataRecievedTimeoutMillis: ${String(\n        retryStrategy?.responseDataReceivedTimeoutMillis\n      )}; deadline offset: ${deadlineOffset} ms`\n    );\n\n    return (options, nextCall) => {\n      logger.trace(\n        `Entering RetryInterceptor (for ${\n          props.clientName\n        }); overall request timeout offset: ${overallRequestTimeoutMs} ms; deadline offset: ${String(\n          deadlineOffset\n        )}`\n      );\n      const overallDeadline = calculateDeadline(overallRequestTimeoutMs);\n\n      logger.trace(\n        `Setting initial deadline (for ${props.clientName}) based on offset: ${deadlineOffset} ms`\n      );\n      let nextDeadline = calculateDeadline(deadlineOffset);\n\n      options.deadline = nextDeadline;\n\n      let savedMetadata: Metadata;\n      let savedSendMessage: unknown;\n      let savedReceiveMessage: unknown;\n      let savedMessageNext: (arg0: unknown) => void;\n      return new InterceptingCall(nextCall(options), {\n        start: function (metadata, listener, next) {\n          savedMetadata = metadata;\n          const newListener: Listener = {\n            onReceiveMessage: function (\n              message: unknown,\n              next: (arg0: unknown) => void\n            ) {\n              savedReceiveMessage = message;\n              savedMessageNext = next;\n            },\n            onReceiveStatus: function (\n              status: StatusObject,\n              // NOTE: we have to use `any` here because that is what is used in the grpc-js type definitions\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              next: (arg0: any) => void\n            ) {\n              let attempts = 0;\n              const retry = function (message: unknown, metadata: Metadata) {\n                logger.debug(\n                  `Retrying request: path: ${\n                    options.method_definition.path\n                  }; deadline was: ${String(\n                    (options.deadline as Date | undefined)?.toISOString()\n                  )}, overall deadline is: ${overallDeadline.toISOString()}`\n                );\n                if (new Date(Date.now()) >= overallDeadline) {\n                  logger.debug(\n                    `Request not eligible for retry: path: ${\n                      options.method_definition.path\n                    }; overall deadline exceeded: ${overallDeadline.toISOString()}`\n                  );\n                  savedMessageNext(savedReceiveMessage);\n                  next(status);\n                  return;\n                }\n                nextDeadline = calculateDeadline(deadlineOffset);\n                logger.debug(\n                  `Setting next deadline (via offset of ${deadlineOffset} ms) to: ${nextDeadline.toISOString()}`\n                );\n                options.deadline = nextDeadline;\n\n                const newCall = nextCall(options);\n                newCall.start(metadata, {\n                  onReceiveMessage: function (message) {\n                    savedReceiveMessage = message;\n                  },\n                  onReceiveStatus: function (status) {\n                    const whenToRetry =\n                      retryStrategy.determineWhenToRetryRequest({\n                        grpcStatus: status,\n                        grpcRequest: options.method_definition,\n                        attemptNumber: attempts,\n                        requestMetadata: metadata,\n                      });\n\n                    if (whenToRetry === null) {\n                      logger.debug(\n                        `Request not eligible for retry: path: ${options.method_definition.path}; retryable status code: ${status.code}; number of attempts (${attempts}).`\n                      );\n                      savedMessageNext(savedReceiveMessage);\n                      next(status);\n                    } else {\n                      attempts++;\n                      logger.debug(\n                        `Request eligible for retry: path: ${options.method_definition.path}; response status code: ${status.code}; number of attempts (${attempts}); will retry in ${whenToRetry}ms`\n                      );\n                      setTimeout(() => retry(message, metadata), whenToRetry);\n                    }\n                  },\n                });\n                newCall.sendMessage(savedSendMessage);\n                newCall.halfClose();\n              };\n\n              if (status.code === Status.OK) {\n                savedMessageNext(savedReceiveMessage);\n                next(status);\n              } else {\n                const whenToRetry = retryStrategy.determineWhenToRetryRequest({\n                  grpcStatus: status,\n                  grpcRequest: options.method_definition,\n                  attemptNumber: attempts,\n                  requestMetadata: metadata,\n                });\n                if (whenToRetry === null) {\n                  logger.debug(\n                    `Request not eligible for retry: path: ${options.method_definition.path}; response status code: ${status.code}.`\n                  );\n                  savedMessageNext(savedReceiveMessage);\n                  next(status);\n                } else {\n                  attempts++;\n                  logger.debug(\n                    `Request eligible for retry: path: ${options.method_definition.path}; response status code: ${status.code}; number of attempts (${attempts}); will retry in ${whenToRetry}ms`\n                  );\n                  setTimeout(\n                    () => retry(savedSendMessage, savedMetadata),\n                    whenToRetry\n                  );\n                }\n              }\n            },\n          };\n          next(metadata, newListener);\n        },\n        sendMessage: function (message, next) {\n          savedSendMessage = message;\n          next(message);\n        },\n      });\n    };\n  }\n}\n\nfunction calculateDeadline(offsetMillis: number): Date {\n  const deadline = new Date(Date.now());\n  deadline.setMilliseconds(deadline.getMilliseconds() + offsetMillis);\n  return deadline;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 231, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 235, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk/src/internal/cache-control-client.ts"],"sourcesContent":["import {control} from '@gomomento/generated-types';\nimport grpcControl = control.control_client;\nimport {Header, HeaderInterceptor} from './grpc/headers-interceptor';\nimport {CacheServiceErrorMapper} from '../errors/cache-service-error-mapper';\nimport {ChannelCredentials, Interceptor} from '@grpc/grpc-js';\nimport {\n  CreateCache,\n  DeleteCache,\n  ListCaches,\n  CacheFlush,\n  CredentialProvider,\n  MomentoLogger,\n  CacheInfo,\n  MomentoErrorCode,\n} from '..';\nimport {version} from '../../package.json';\nimport {IdleGrpcClientWrapper} from './grpc/idle-grpc-client-wrapper';\nimport {GrpcClientWrapper} from './grpc/grpc-client-wrapper';\nimport {Configuration} from '../config/configuration';\nimport {validateCacheName} from '@gomomento/sdk-core/dist/src/internal/utils';\nimport {\n  CacheLimits,\n  TopicLimits,\n} from '@gomomento/sdk-core/dist/src/messages/cache-info';\nimport {RetryInterceptor} from './grpc/retry-interceptor';\n\nexport interface ControlClientProps {\n  configuration: Configuration;\n  credentialProvider: CredentialProvider;\n}\n\nexport class CacheControlClient {\n  private readonly clientWrapper: GrpcClientWrapper<grpcControl.ScsControlClient>;\n  private readonly interceptors: Interceptor[];\n  private static readonly REQUEST_TIMEOUT_MS: number = 60 * 1000;\n  private readonly logger: MomentoLogger;\n  private readonly cacheServiceErrorMapper: CacheServiceErrorMapper;\n\n  /**\n   * @param {ControlClientProps} props\n   */\n  constructor(props: ControlClientProps) {\n    this.logger = props.configuration.getLoggerFactory().getLogger(this);\n    this.cacheServiceErrorMapper = new CacheServiceErrorMapper(\n      props.configuration.getThrowOnErrors()\n    );\n    const headers = [\n      new Header('Authorization', props.credentialProvider.getAuthToken()),\n      new Header('agent', `nodejs:cache:${version}`),\n      new Header('runtime-version', `nodejs:${process.versions.node}`),\n    ];\n    this.interceptors = [\n      HeaderInterceptor.createHeadersInterceptor(headers),\n      RetryInterceptor.createRetryInterceptor({\n        clientName: 'CacheControlClient',\n        loggerFactory: props.configuration.getLoggerFactory(),\n        overallRequestTimeoutMs: CacheControlClient.REQUEST_TIMEOUT_MS,\n      }),\n    ];\n    this.logger.debug(\n      `Creating control client using endpoint: '${props.credentialProvider.getControlEndpoint()}`\n    );\n    this.clientWrapper = new IdleGrpcClientWrapper({\n      clientFactoryFn: () =>\n        new grpcControl.ScsControlClient(\n          props.credentialProvider.getControlEndpoint(),\n          props.credentialProvider.isControlEndpointSecure()\n            ? ChannelCredentials.createSsl()\n            : ChannelCredentials.createInsecure()\n        ),\n      loggerFactory: props.configuration.getLoggerFactory(),\n      maxIdleMillis: props.configuration\n        .getTransportStrategy()\n        .getMaxIdleMillis(),\n    });\n  }\n  close() {\n    this.logger.debug('Closing cache control client');\n    this.clientWrapper.getClient().close();\n  }\n\n  public async createCache(name: string): Promise<CreateCache.Response> {\n    try {\n      validateCacheName(name);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CreateCache.Error(err)\n      );\n    }\n    this.logger.debug(`Creating cache: ${name}`);\n    const request = new grpcControl._CreateCacheRequest({\n      cache_name: name,\n    });\n    return await new Promise<CreateCache.Response>((resolve, reject) => {\n      this.clientWrapper\n        .getClient()\n        .CreateCache(\n          request,\n          {interceptors: this.interceptors},\n          (err, _resp) => {\n            if (err) {\n              const sdkError = this.cacheServiceErrorMapper.convertError(err);\n              if (\n                sdkError.errorCode() ===\n                MomentoErrorCode.CACHE_ALREADY_EXISTS_ERROR\n              ) {\n                resolve(new CreateCache.AlreadyExists());\n              } else {\n                this.cacheServiceErrorMapper.resolveOrRejectError({\n                  err: err,\n                  errorResponseFactoryFn: e => new CreateCache.Error(e),\n                  resolveFn: resolve,\n                  rejectFn: reject,\n                });\n              }\n            } else {\n              resolve(new CreateCache.Success());\n            }\n          }\n        );\n    });\n  }\n\n  public async deleteCache(name: string): Promise<DeleteCache.Response> {\n    try {\n      validateCacheName(name);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new DeleteCache.Error(err)\n      );\n    }\n    const request = new grpcControl._DeleteCacheRequest({\n      cache_name: name,\n    });\n    this.logger.debug(`Deleting cache: ${name}`);\n    return await new Promise<DeleteCache.Response>((resolve, reject) => {\n      this.clientWrapper\n        .getClient()\n        .DeleteCache(\n          request,\n          {interceptors: this.interceptors},\n          (err, _resp) => {\n            if (err) {\n              this.cacheServiceErrorMapper.resolveOrRejectError({\n                err: err,\n                errorResponseFactoryFn: e => new DeleteCache.Error(e),\n                resolveFn: resolve,\n                rejectFn: reject,\n              });\n            } else {\n              resolve(new DeleteCache.Success());\n            }\n          }\n        );\n    });\n  }\n\n  public async flushCache(cacheName: string): Promise<CacheFlush.Response> {\n    try {\n      validateCacheName(cacheName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheFlush.Error(err)\n      );\n    }\n    this.logger.debug(`Flushing cache: ${cacheName}`);\n    return await this.sendFlushCache(cacheName);\n  }\n\n  private async sendFlushCache(\n    cacheName: string\n  ): Promise<CacheFlush.Response> {\n    const request = new grpcControl._FlushCacheRequest({\n      cache_name: cacheName,\n    });\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().FlushCache(\n        request,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp) {\n            resolve(new CacheFlush.Success());\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheFlush.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async listCaches(): Promise<ListCaches.Response> {\n    const request = new grpcControl._ListCachesRequest();\n    request.next_token = '';\n    this.logger.debug(\"Issuing 'listCaches' request\");\n    return await new Promise<ListCaches.Response>((resolve, reject) => {\n      this.clientWrapper\n        .getClient()\n        .ListCaches(request, {interceptors: this.interceptors}, (err, resp) => {\n          if (err || !resp) {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new ListCaches.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          } else {\n            const caches = resp.cache.map(cache => {\n              const cacheName = cache.cache_name;\n              const topicLimits: TopicLimits = {\n                maxPublishMessageSizeKb:\n                  cache.topic_limits?.max_publish_message_size_kb || 0,\n                maxSubscriptionCount:\n                  cache.topic_limits?.max_subscription_count || 0,\n                maxPublishRate: cache.topic_limits?.max_publish_rate || 0,\n              };\n              const cacheLimits: CacheLimits = {\n                maxTtlSeconds: cache.cache_limits?.max_ttl_seconds || 0,\n                maxItemSizeKb: cache.cache_limits?.max_item_size_kb || 0,\n                maxThroughputKbps: cache.cache_limits?.max_throughput_kbps || 0,\n                maxTrafficRate: cache.cache_limits?.max_traffic_rate || 0,\n              };\n              return new CacheInfo(cacheName, topicLimits, cacheLimits);\n            });\n            resolve(new ListCaches.Success(caches));\n          }\n        });\n    });\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 409, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 413, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk/src/internal/grpc/middlewares-interceptor.ts"],"sourcesContent":["import {\n  InterceptingCall,\n  Interceptor,\n  InterceptorOptions,\n  Listener,\n  Metadata,\n  Requester,\n  StatusObject,\n} from '@grpc/grpc-js';\nimport {NextCall} from '@grpc/grpc-js/build/src/client-interceptors';\nimport {\n  Middleware,\n  MiddlewareMessage,\n  MiddlewareMetadata,\n  MiddlewareRequestHandler,\n  MiddlewareRequestHandlerContext,\n  MiddlewareStatus,\n} from '../../config/middleware/middleware';\nimport {Message} from 'google-protobuf';\nimport {MomentoLoggerFactory} from '../../';\nimport {cache_client} from '@gomomento/generated-types/dist/cacheclient';\nimport {Status} from '@grpc/grpc-js/build/src/constants';\nimport {ConnectivityState} from '@grpc/grpc-js/build/src/connectivity-state';\n\nexport function middlewaresInterceptor(\n  loggerFactory: MomentoLoggerFactory,\n  middlewares: Middleware[],\n  middlewareRequestContext: MiddlewareRequestHandlerContext,\n  grpcClient: cache_client.ScsClient | null = null\n): Interceptor {\n  const logger = loggerFactory.getLogger('grpc-interceptor');\n\n  return (options: InterceptorOptions, nextCall: NextCall) => {\n    const middlewareRequestHandlers = middlewares.map(m =>\n      m.onNewRequest(middlewareRequestContext)\n    );\n    // create a copy of the handlers and reverse it, because for the response life cycle actions we should call\n    // the middlewares in the opposite order.\n    const reversedMiddlewareRequestHandlers = [\n      ...middlewareRequestHandlers,\n    ].reverse();\n\n    const requester: Requester = {\n      start: function (\n        metadata: Metadata,\n        listener: Listener,\n        next: (metadata: Metadata, listener: Listener) => void\n      ): void {\n        const newListener: Listener = {\n          onReceiveMetadata: function (\n            metadata: Metadata,\n            next: (metadata: Metadata) => void\n          ): void {\n            applyMiddlewareHandlers(\n              'onResponseMetadata',\n              reversedMiddlewareRequestHandlers,\n              (h: MiddlewareRequestHandler) => (m: MiddlewareMetadata) =>\n                h.onResponseMetadata(m),\n              new MiddlewareMetadata(metadata),\n              (metadata: MiddlewareMetadata) => next(metadata._grpcMetadata)\n            );\n          },\n          onReceiveMessage: function (\n            // unfortunately grpc uses `any` in their type defs for these\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            message: any,\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            next: (message: any) => void\n          ): void {\n            applyMiddlewareHandlers(\n              'onResponseBody',\n              reversedMiddlewareRequestHandlers,\n              (h: MiddlewareRequestHandler) =>\n                (request: MiddlewareMessage | null) =>\n                  h.onResponseBody(request),\n              new MiddlewareMessage(message as Message),\n              (msg: MiddlewareMessage | null) => next(msg?._grpcMessage)\n            );\n          },\n          onReceiveStatus: function (\n            status: StatusObject,\n            next: (status: StatusObject) => void\n          ): void {\n            if (status.code === Status.DEADLINE_EXCEEDED) {\n              // getConnectivityState(true) will return state of connection and\n              // also try to connect if it's idle, false will just get the status\n              const connectionStatus =\n                grpcClient?.getChannel()?.getConnectivityState(false) ?? null;\n              logger.warn(\n                `Deadline Exceeded! Received status: ${status.code} ${\n                  status.details\n                } and grpc connection status: ${\n                  connectionStatus\n                    ? ConnectivityState[connectionStatus]\n                    : 'unable to get connection status'\n                }`\n              );\n            }\n            applyMiddlewareHandlers(\n              'onResponseStatus',\n              reversedMiddlewareRequestHandlers,\n              (h: MiddlewareRequestHandler) => (s: MiddlewareStatus) =>\n                h.onResponseStatus(s),\n              new MiddlewareStatus(status),\n              (s: MiddlewareStatus) => next(s._grpcStatus)\n            );\n          },\n        };\n\n        applyMiddlewareHandlers(\n          'onRequestMetadata',\n          middlewareRequestHandlers,\n          (h: MiddlewareRequestHandler) => (m: MiddlewareMetadata) =>\n            h.onRequestMetadata(m),\n          new MiddlewareMetadata(metadata),\n          (m: MiddlewareMetadata) => next(m._grpcMetadata, newListener)\n        );\n      },\n      // unfortunately grpc uses `any` in their type defs for these\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      sendMessage: function (message: any, next: (message: any) => void): void {\n        applyMiddlewareHandlers(\n          'onRequestBody',\n          middlewareRequestHandlers,\n          (h: MiddlewareRequestHandler) => (request: MiddlewareMessage) =>\n            h.onRequestBody(request),\n          new MiddlewareMessage(message as Message),\n          (m: MiddlewareMessage) => next(m._grpcMessage)\n        );\n      },\n    };\n    return new InterceptingCall(nextCall(options), requester);\n  };\n}\n\nfunction applyMiddlewareHandlers<T>(\n  name: string,\n  handlers: MiddlewareRequestHandler[],\n  middlewareHandlerReduceFn: (\n    h: MiddlewareRequestHandler\n  ) => (t: T) => Promise<T>,\n  originalInput: T,\n  nextFn: (t: T) => void\n) {\n  let remainingHandlers = handlers;\n  let middlewarePromise: Promise<T> = Promise.resolve(originalInput);\n  while (remainingHandlers.length > 0) {\n    const nextHandler = middlewareHandlerReduceFn(remainingHandlers[0]);\n    middlewarePromise = middlewarePromise\n      .then(newT => nextHandler(newT))\n      .catch(e => {\n        throw e;\n      });\n    remainingHandlers = remainingHandlers.slice(1);\n  }\n\n  middlewarePromise\n    .then(newT => nextFn(newT))\n    .catch(e => {\n      throw e;\n    });\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 480, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 484, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk/src/internal/grpc/grpc-channel-options.ts"],"sourcesContent":["import {GrpcConfiguration} from '../..';\nimport {ChannelOptions} from '@grpc/grpc-js';\n\n// The default value for max_send_message_length is 4mb.  We need to increase this to 5mb in order to\n// support cases where users have requested a limit increase up to our maximum item size of 5mb.\nconst DEFAULT_MAX_REQUEST_SIZE = 5_243_000;\n\nexport function grpcChannelOptionsFromGrpcConfig(\n  grpcConfig: GrpcConfiguration\n): ChannelOptions {\n  return {\n    // default value for max session memory is 10mb.  Under high load, it is easy to exceed this,\n    // after which point all requests will fail with a client-side RESOURCE_EXHAUSTED exception.\n    'grpc-node.max_session_memory': grpcConfig.getMaxSessionMemoryMb(),\n\n    // This flag controls whether channels use a shared global pool of subchannels, or whether\n    // each channel gets its own subchannel pool.  The default value is 0, meaning a single global\n    // pool.  Setting it to 1 provides significant performance improvements when we instantiate more\n    // than one grpc client.\n    'grpc.use_local_subchannel_pool': 1,\n\n    // The default value for max_send_message_length is 4mb.  We need to increase this to 5mb in order to\n    // support cases where users have requested a limit increase up to our maximum item size of 5mb.\n    'grpc.max_send_message_length':\n      grpcConfig.getMaxSendMessageLength() ?? DEFAULT_MAX_REQUEST_SIZE,\n    'grpc.max_receive_message_length':\n      grpcConfig.getMaxReceiveMessageLength() ?? DEFAULT_MAX_REQUEST_SIZE,\n\n    // NOTE: keep-alives are very important for long-lived server environments where there may be periods of time\n    // when the connection is idle. However, they are very problematic for lambda environments where the lambda\n    // runtime is continuously frozen and unfrozen, because the lambda may be frozen before the \"ACK\" is received\n    // from the server. This can cause the keep-alive to timeout even though the connection is completely healthy.\n    // Therefore, keep-alives should be disabled in lambda and similar environments.\n    'grpc.keepalive_permit_without_calls':\n      grpcConfig.getKeepAlivePermitWithoutCalls(),\n    'grpc.keepalive_time_ms': grpcConfig.getKeepAliveTimeMS(),\n    'grpc.keepalive_timeout_ms': grpcConfig.getKeepAliveTimeoutMS(),\n  };\n}\n"],"names":[],"mappings":";;;;;AAGA,qGAAqG;AACrG,gGAAgG;AAChG,MAAM,2BAA2B;AAEjC,SAAgB,iCACd,UAA6B;;IAE7B,OAAO;QACL,6FAA6F;QAC7F,4FAA4F;QAC5F,gCAAgC,WAAW,qBAAqB;QAEhE,0FAA0F;QAC1F,8FAA8F;QAC9F,gGAAgG;QAChG,wBAAwB;QACxB,kCAAkC;QAElC,qGAAqG;QACrG,gGAAgG;QAChG,gCACE,CAAA,KAAA,WAAW,uBAAuB,EAAE,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI;QAC1C,mCACE,CAAA,KAAA,WAAW,0BAA0B,EAAE,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI;QAE7C,6GAA6G;QAC7G,2GAA2G;QAC3G,6GAA6G;QAC7G,8GAA8G;QAC9G,gFAAgF;QAChF,uCACE,WAAW,8BAA8B;QAC3C,0BAA0B,WAAW,kBAAkB;QACvD,6BAA6B,WAAW,qBAAqB;;AAEjE;AA/BA,QAAA,gCAAA,GAAA"}},
    {"offset": {"line": 518, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 522, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk/src/internal/cache-data-client.ts"],"sourcesContent":["import {cache} from '@gomomento/generated-types';\n// older versions of node don't have the global util variables https://github.com/nodejs/node/issues/20365\nimport {TextEncoder} from 'util';\nimport {Header, HeaderInterceptor} from './grpc/headers-interceptor';\nimport {RetryInterceptor} from './grpc/retry-interceptor';\nimport {CacheServiceErrorMapper} from '../errors/cache-service-error-mapper';\nimport {\n  ChannelCredentials,\n  Interceptor,\n  Metadata,\n  ServiceError,\n} from '@grpc/grpc-js';\nimport {\n  AutomaticDecompression,\n  CacheDecreaseTtl,\n  CacheDelete,\n  CacheDictionaryFetch,\n  CacheDictionaryGetField,\n  CacheDictionaryGetFields,\n  CacheDictionaryIncrement,\n  CacheDictionaryLength,\n  CacheDictionaryRemoveField,\n  CacheDictionaryRemoveFields,\n  CacheDictionarySetField,\n  CacheDictionarySetFields,\n  CacheGet,\n  CacheGetBatch,\n  CacheIncreaseTtl,\n  CacheIncrement,\n  CacheItemGetTtl,\n  CacheItemGetType,\n  CacheKeyExists,\n  CacheKeysExist,\n  CacheListConcatenateBack,\n  CacheListConcatenateFront,\n  CacheListFetch,\n  CacheListLength,\n  CacheListPopBack,\n  CacheListPopFront,\n  CacheListPushBack,\n  CacheListPushFront,\n  CacheListRemoveValue,\n  CacheListRetain,\n  CacheSet,\n  CacheSetAddElements,\n  CacheSetBatch,\n  CacheSetContainsElement,\n  CacheSetContainsElements,\n  CacheSetFetch,\n  CacheSetIfAbsent,\n  CacheSetIfAbsentOrEqual,\n  CacheSetIfEqual,\n  CacheSetIfNotEqual,\n  CacheSetIfNotExists,\n  CacheSetIfPresent,\n  CacheSetIfPresentAndNotEqual,\n  CacheSetRemoveElements,\n  CacheSetSample,\n  CacheSortedSetFetch,\n  CacheSortedSetGetRank,\n  CacheSortedSetGetScore,\n  CacheSortedSetGetScores,\n  CacheSortedSetIncrementScore,\n  CacheSortedSetLength,\n  CacheSortedSetLengthByScore,\n  CacheSortedSetPutElement,\n  CacheSortedSetPutElements,\n  CacheSortedSetRemoveElement,\n  CacheSortedSetRemoveElements,\n  CacheUpdateTtl,\n  CollectionTtl,\n  CompressionLevel,\n  CredentialProvider,\n  ICompression,\n  InvalidArgumentError,\n  ItemType,\n  MomentoLogger,\n  MomentoLoggerFactory,\n  ReadConcern,\n  SortedSetOrder,\n  UnknownError,\n} from '..';\nimport {version} from '../../package.json';\nimport {IdleGrpcClientWrapper} from './grpc/idle-grpc-client-wrapper';\nimport {GrpcClientWrapper} from './grpc/grpc-client-wrapper';\nimport {\n  Middleware,\n  MiddlewareRequestHandlerContext,\n} from '../config/middleware/middleware';\nimport {middlewaresInterceptor} from './grpc/middlewares-interceptor';\nimport {cache_client} from '@gomomento/generated-types/dist/cacheclient';\nimport {Configuration} from '../config/configuration';\nimport {\n  Semaphore,\n  validateCacheName,\n  validateDictionaryName,\n  validateListName,\n  validateListSliceStartEnd,\n  validateSetName,\n  validateSetPopCount,\n  validateSetSampleLimit,\n  validateSortedSetCount,\n  validateSortedSetName,\n  validateSortedSetOffset,\n  validateSortedSetRanks,\n  validateSortedSetScores,\n  validateTtlSeconds,\n  validateValidForSeconds,\n} from '@gomomento/sdk-core/dist/src/internal/utils';\nimport {\n  _DictionaryGetResponsePart,\n  _ECacheResult,\n  _SortedSetGetScoreResponsePart,\n} from '@gomomento/sdk-core/dist/src/messages/responses/grpc-response-types';\nimport {IDataClient} from '@gomomento/sdk-core/dist/src/internal/clients';\nimport {ConnectivityState} from '@grpc/grpc-js/build/src/connectivity-state';\nimport {CacheClientAllProps} from './cache-client-all-props';\nimport {grpcChannelOptionsFromGrpcConfig} from './grpc/grpc-channel-options';\nimport {ConnectionError} from '@gomomento/sdk-core/dist/src/errors';\nimport {common} from '@gomomento/generated-types/dist/common';\nimport {\n  GetBatchCallOptions,\n  GetCallOptions,\n  SetBatchCallOptions,\n  SetBatchItem,\n  SetCallOptions,\n  SetIfAbsentCallOptions,\n} from '@gomomento/sdk-core/dist/src/utils';\nimport {CompressionError} from '../errors/compression-error';\nimport {CacheSetLength, CacheSetPop} from '@gomomento/sdk-core';\nimport grpcCache = cache.cache_client;\nimport ECacheResult = cache_client.ECacheResult;\nimport _ItemGetTypeResponse = cache_client._ItemGetTypeResponse;\nimport _Unbounded = common._Unbounded;\nimport Absent = common.Absent;\nimport Present = common.Present;\nimport Equal = common.Equal;\nimport NotEqual = common.NotEqual;\nimport PresentAndNotEqual = common.PresentAndNotEqual;\nimport AbsentOrEqual = common.AbsentOrEqual;\n\nexport const CONNECTION_ID_KEY = Symbol('connectionID');\n\ninterface CompressionDetails {\n  valueCompressor: ICompression;\n  compressionLevel: CompressionLevel;\n  autoDecompressEnabled: boolean;\n}\n\nexport class CacheDataClient implements IDataClient {\n  private readonly clientWrapper: GrpcClientWrapper<grpcCache.ScsClient>;\n  private readonly textEncoder: TextEncoder;\n  private readonly configuration: Configuration;\n  private readonly credentialProvider: CredentialProvider;\n  private readonly defaultTtlSeconds: number;\n  private readonly requestTimeoutMs: number;\n  private static readonly DEFAULT_REQUEST_TIMEOUT_MS: number = 5 * 1000;\n  private readonly logger: MomentoLogger;\n  private readonly cacheServiceErrorMapper: CacheServiceErrorMapper;\n  private readonly interceptors: Interceptor[];\n  private readonly streamingInterceptors: Interceptor[];\n  private readonly compressionDetails?: CompressionDetails;\n  private readonly requestConcurrencySemaphore: Semaphore | undefined;\n\n  /**\n   * @param {CacheClientProps} props\n   * @param dataClientID\n   * @param semaphore\n   */\n  constructor(\n    props: CacheClientAllProps,\n    dataClientID: string,\n    semaphore: Semaphore | undefined\n  ) {\n    this.configuration = props.configuration;\n    this.credentialProvider = props.credentialProvider;\n    this.logger = this.configuration.getLoggerFactory().getLogger(this);\n    this.cacheServiceErrorMapper = new CacheServiceErrorMapper(\n      props.configuration.getThrowOnErrors()\n    );\n    const compression = this.configuration.getCompressionStrategy();\n    if (compression !== undefined) {\n      this.compressionDetails = {\n        valueCompressor: compression.compressorFactory,\n        compressionLevel:\n          compression.compressionLevel ?? CompressionLevel.Balanced,\n        autoDecompressEnabled:\n          (compression.automaticDecompression ??\n            AutomaticDecompression.Enabled) === AutomaticDecompression.Enabled,\n      };\n    } else {\n      this.compressionDetails = undefined;\n    }\n    this.requestConcurrencySemaphore = semaphore;\n\n    const grpcConfig = this.configuration\n      .getTransportStrategy()\n      .getGrpcConfig();\n\n    this.requestTimeoutMs =\n      grpcConfig.getDeadlineMillis() ||\n      CacheDataClient.DEFAULT_REQUEST_TIMEOUT_MS;\n    this.validateRequestTimeout(this.requestTimeoutMs);\n    this.logger.debug(\n      `Creating cache client using endpoint: '${this.credentialProvider.getCacheEndpoint()}'`\n    );\n\n    const channelOptions = grpcChannelOptionsFromGrpcConfig(grpcConfig);\n\n    this.clientWrapper = new IdleGrpcClientWrapper({\n      clientFactoryFn: () => {\n        this.logger.debug(`Constructing channel for clientID ${dataClientID}`);\n        return new grpcCache.ScsClient(\n          this.credentialProvider.getCacheEndpoint(),\n          this.credentialProvider.isCacheEndpointSecure()\n            ? ChannelCredentials.createSsl()\n            : ChannelCredentials.createInsecure(),\n          channelOptions\n        );\n      },\n      loggerFactory: this.configuration.getLoggerFactory(),\n      maxIdleMillis: this.configuration\n        .getTransportStrategy()\n        .getMaxIdleMillis(),\n      maxClientAgeMillis: this.configuration\n        .getTransportStrategy()\n        .getMaxClientAgeMillis(),\n    });\n\n    this.textEncoder = new TextEncoder();\n    this.defaultTtlSeconds = props.defaultTtlSeconds;\n\n    // this context object is currently internal only but can be extended in the Configuration object is we wants clients\n    // to be able to set it.\n    const context: MiddlewareRequestHandlerContext = {};\n    context[CONNECTION_ID_KEY] = dataClientID;\n\n    const headers = [\n      new Header('Authorization', this.credentialProvider.getAuthToken()),\n      new Header('agent', `nodejs:cache:${version}`),\n      new Header('runtime-version', `nodejs:${process.versions.node}`),\n    ];\n\n    // Not sending a head concern header is treated the same as sending a BALANCED read concern header\n    const readConcern = this.configuration.getReadConcern();\n    if (readConcern !== ReadConcern.BALANCED) {\n      headers.push(new Header('read-concern', readConcern));\n    }\n\n    this.interceptors = this.initializeInterceptors(\n      headers,\n      this.configuration.getLoggerFactory(),\n      this.configuration.getMiddlewares(),\n      context\n    );\n    this.streamingInterceptors = this.initializeStreamingInterceptors(headers);\n  }\n\n  close() {\n    this.logger.debug('Closing cache data client');\n    this.clientWrapper.getClient().close();\n  }\n\n  public connect(timeoutSeconds = 10): Promise<void> {\n    this.logger.debug('Attempting to eagerly connect to channel');\n    const deadline = new Date();\n    deadline.setSeconds(deadline.getSeconds() + timeoutSeconds);\n\n    return this.connectWithinDeadline(deadline);\n  }\n\n  private connectionStateToString(state: ConnectivityState): string {\n    switch (state) {\n      case ConnectivityState.IDLE:\n        return 'IDLE';\n      case ConnectivityState.CONNECTING:\n        return 'CONNECTING';\n      case ConnectivityState.READY:\n        return 'READY';\n      case ConnectivityState.TRANSIENT_FAILURE:\n        return 'TRANSIENT_FAILURE';\n      case ConnectivityState.SHUTDOWN:\n        return 'SHUTDOWN';\n    }\n  }\n\n  private connectWithinDeadline(deadline: Date): Promise<void> {\n    return new Promise((resolve, reject) => {\n      // Get the current state and initiate a connection\n      const currentState = this.clientWrapper\n        .getClient()\n        .getChannel()\n        .getConnectivityState(true);\n\n      this.logger.debug(`Client connectivity state: ${currentState}`);\n\n      if (currentState === ConnectivityState.READY) {\n        resolve();\n        return;\n      }\n\n      const now = new Date();\n\n      if (now >= deadline) {\n        const errorMessage = 'Unable to connect to Momento: deadline exceeded.';\n        this.logger.error(errorMessage);\n        reject(new ConnectionError(errorMessage));\n        return;\n      }\n\n      this.clientWrapper\n        .getClient()\n        .getChannel()\n        .watchConnectivityState(currentState, deadline, (error?: Error) => {\n          if (error) {\n            const errorMessage = `Unable to eagerly connect to Momento. Please contact Momento if this persists. currentState: ${this.connectionStateToString(\n              currentState\n            )}, errorName: ${error.name} : errorMessage: ${\n              error.message\n            }, errorStack: ${\n              error.stack ? error.stack : 'Stack trace undefined'\n            }`;\n            this.logger.error(errorMessage);\n            reject(new ConnectionError(errorMessage));\n            return;\n          }\n\n          const newState = this.clientWrapper\n            .getClient()\n            .getChannel()\n            .getConnectivityState(false);\n\n          if (newState === ConnectivityState.READY) {\n            this.logger.debug(\n              `Connected! Current state: ${this.connectionStateToString(\n                newState\n              )}`\n            );\n            resolve();\n          } else if (newState === ConnectivityState.CONNECTING) {\n            // The connection goes through the CONNECTING state before becoming READY,\n            // so we must watch it twice.\n            this.logger.debug(\n              `Connecting! Current state: ${this.connectionStateToString(\n                newState\n              )}`\n            );\n            this.connectWithinDeadline(deadline).then(resolve).catch(reject);\n          } else {\n            const errorMessage = `Unable to connect to Momento: Unexpected connection state: ${this.connectionStateToString(\n              newState\n            )}., oldState: ${this.connectionStateToString(currentState)}\n              Please contact Momento if this persists.`;\n            this.logger.error(errorMessage);\n            reject(new ConnectionError(errorMessage));\n            return;\n          }\n        });\n    });\n  }\n\n  public getEndpoint(): string {\n    const endpoint = this.credentialProvider.getCacheEndpoint();\n    this.logger.debug(`Using cache endpoint: ${endpoint}`);\n    return endpoint;\n  }\n\n  private validateRequestTimeout(timeout?: number) {\n    this.logger.debug(`Request timeout ms: ${String(timeout)}`);\n    if (timeout !== undefined && timeout <= 0) {\n      throw new InvalidArgumentError(\n        'request timeout must be greater than zero.'\n      );\n    }\n  }\n\n  private convertECacheResult(result: grpcCache.ECacheResult): _ECacheResult {\n    switch (result) {\n      case grpcCache.ECacheResult.Hit:\n        return _ECacheResult.Hit;\n      case grpcCache.ECacheResult.Invalid:\n        return _ECacheResult.Invalid;\n      case grpcCache.ECacheResult.Miss:\n        return _ECacheResult.Miss;\n      case grpcCache.ECacheResult.Ok:\n        return _ECacheResult.Ok;\n    }\n  }\n\n  private convertItemTypeResult(\n    result: _ItemGetTypeResponse.ItemType\n  ): ItemType {\n    switch (result) {\n      case _ItemGetTypeResponse.ItemType.SCALAR:\n        return ItemType.SCALAR;\n      case _ItemGetTypeResponse.ItemType.LIST:\n        return ItemType.LIST;\n      case _ItemGetTypeResponse.ItemType.DICTIONARY:\n        return ItemType.DICTIONARY;\n      case _ItemGetTypeResponse.ItemType.SET:\n        return ItemType.SET;\n      case _ItemGetTypeResponse.ItemType.SORTED_SET:\n        return ItemType.SORTED_SET;\n    }\n  }\n\n  // If maxConcurrentRequests is set, use the semaphore to limit the number of concurrent requests.\n  // Otherwise, execute the cache operation without any rate limiting.\n  private async rateLimited<T>(cacheOperation: () => Promise<T>): Promise<T> {\n    try {\n      if (this.requestConcurrencySemaphore !== undefined)\n        await this.requestConcurrencySemaphore.acquire();\n\n      return await cacheOperation();\n    } finally {\n      if (this.requestConcurrencySemaphore !== undefined)\n        this.requestConcurrencySemaphore.release();\n    }\n  }\n\n  public async set(\n    cacheName: string,\n    key: string | Uint8Array,\n    value: string | Uint8Array,\n    options?: SetCallOptions\n  ): Promise<CacheSet.Response> {\n    try {\n      validateCacheName(cacheName);\n      if (options?.ttl !== undefined) {\n        validateTtlSeconds(options.ttl);\n      }\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheSet.Error(err)\n      );\n    }\n\n    const ttlToUse = options?.ttl || this.defaultTtlSeconds;\n    const encodedKey = this.convert(key);\n    let encodedValue = this.convert(value);\n    if (options?.compress) {\n      this.logger.trace(\n        'CacheClient.set; compression enabled, calling value compressor'\n      );\n      if (this.compressionDetails === undefined) {\n        return this.cacheServiceErrorMapper.returnOrThrowError(\n          new CompressionError('CacheClient.set', 'compress'),\n          err => new CacheSet.Error(err)\n        );\n      }\n      encodedValue = await this.compressionDetails.valueCompressor.compress(\n        this.compressionDetails.compressionLevel,\n        encodedValue\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendSet(cacheName, encodedKey, encodedValue, ttlToUse);\n    });\n  }\n\n  private async sendSet(\n    cacheName: string,\n    key: Uint8Array,\n    value: Uint8Array,\n    ttl: number\n  ): Promise<CacheSet.Response> {\n    const request = new grpcCache._SetRequest({\n      cache_body: value,\n      cache_key: key,\n      ttl_milliseconds: ttl * 1000,\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().Set(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp) {\n            resolve(new CacheSet.Success());\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheSet.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async setFetch(\n    cacheName: string,\n    setName: string\n  ): Promise<CacheSetFetch.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateSetName(setName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheSetFetch.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendSetFetch(cacheName, this.convert(setName));\n    });\n  }\n\n  private async sendSetFetch(\n    cacheName: string,\n    setName: Uint8Array\n  ): Promise<CacheSetFetch.Response> {\n    const request = new grpcCache._SetFetchRequest({\n      set_name: setName,\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().SetFetch(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp?.missing) {\n            resolve(new CacheSetFetch.Miss());\n          } else if (resp?.found) {\n            resolve(new CacheSetFetch.Hit(resp.found.elements));\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheSetFetch.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async setAddElements(\n    cacheName: string,\n    setName: string,\n    elements: string[] | Uint8Array[],\n    ttl: CollectionTtl = CollectionTtl.fromCacheTtl()\n  ): Promise<CacheSetAddElements.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateSetName(setName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheSetAddElements.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendSetAddElements(\n        cacheName,\n        this.convert(setName),\n        this.convertArray(elements),\n        ttl.ttlMilliseconds() || this.defaultTtlSeconds * 1000,\n        ttl.refreshTtl()\n      );\n    });\n  }\n\n  private async sendSetAddElements(\n    cacheName: string,\n    setName: Uint8Array,\n    elements: Uint8Array[],\n    ttlMilliseconds: number,\n    refreshTtl: boolean\n  ): Promise<CacheSetAddElements.Response> {\n    const request = new grpcCache._SetUnionRequest({\n      set_name: setName,\n      elements: elements,\n      ttl_milliseconds: ttlMilliseconds,\n      refresh_ttl: refreshTtl,\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().SetUnion(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        err => {\n          if (err) {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheSetAddElements.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          } else {\n            resolve(new CacheSetAddElements.Success());\n          }\n        }\n      );\n    });\n  }\n\n  public async setContainsElement(\n    cacheName: string,\n    setName: string,\n    element: string | Uint8Array\n  ): Promise<CacheSetContainsElement.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateSetName(setName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheSetContainsElement.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendSetContainsElement(\n        cacheName,\n        this.convert(setName),\n        this.convert(element)\n      );\n    });\n  }\n\n  private async sendSetContainsElement(\n    cacheName: string,\n    setName: Uint8Array,\n    element: Uint8Array\n  ): Promise<CacheSetContainsElement.Response> {\n    const request = new grpcCache._SetContainsRequest({\n      set_name: setName,\n      elements: [element],\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().SetContains(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp?.found) {\n            const found_mask = resp?.found.contains;\n            if (found_mask === undefined || found_mask.length === 0) {\n              return reject(\n                new CacheSetContainsElement.Error(\n                  new UnknownError('SetContains response missing contains mask')\n                )\n              );\n            }\n            resolve(new CacheSetContainsElement.Hit(found_mask[0]));\n          } else if (resp?.missing) {\n            resolve(new CacheSetContainsElement.Miss());\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheSetContainsElement.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async setContainsElements(\n    cacheName: string,\n    setName: string,\n    elements: string[] | Uint8Array[]\n  ): Promise<CacheSetContainsElements.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateSetName(setName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheSetContainsElements.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendSetContainsElements(\n        cacheName,\n        this.convert(setName),\n        this.convertArray(elements)\n      );\n    });\n  }\n\n  private async sendSetContainsElements(\n    cacheName: string,\n    setName: Uint8Array,\n    elements: Uint8Array[]\n  ): Promise<CacheSetContainsElements.Response> {\n    const request = new grpcCache._SetContainsRequest({\n      set_name: setName,\n      elements: elements,\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().SetContains(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp?.found) {\n            resolve(\n              new CacheSetContainsElements.Hit(elements, resp?.found.contains)\n            );\n          } else if (resp?.missing) {\n            resolve(new CacheSetContainsElements.Miss());\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e =>\n                new CacheSetContainsElements.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async setRemoveElements(\n    cacheName: string,\n    setName: string,\n    elements: string[] | Uint8Array[]\n  ): Promise<CacheSetRemoveElements.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateSetName(setName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheSetRemoveElements.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendSetRemoveElements(\n        cacheName,\n        this.convert(setName),\n        this.convertArray(elements)\n      );\n    });\n  }\n\n  private async sendSetRemoveElements(\n    cacheName: string,\n    setName: Uint8Array,\n    elements: Uint8Array[]\n  ): Promise<CacheSetRemoveElements.Response> {\n    const subtrahend = new grpcCache._SetDifferenceRequest._Subtrahend({\n      set: new grpcCache._SetDifferenceRequest._Subtrahend._Set({\n        elements: elements,\n      }),\n    });\n    const request = new grpcCache._SetDifferenceRequest({\n      set_name: setName,\n      subtrahend: subtrahend,\n    });\n\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().SetDifference(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        err => {\n          if (err) {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheSetRemoveElements.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          } else {\n            resolve(new CacheSetRemoveElements.Success());\n          }\n        }\n      );\n    });\n  }\n\n  public async setSample(\n    cacheName: string,\n    setName: string,\n    limit: number\n  ): Promise<CacheSetSample.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateSetName(setName);\n      validateSetSampleLimit(limit);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheSetSample.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendSetSample(cacheName, this.convert(setName), limit);\n    });\n  }\n\n  private async sendSetSample(\n    cacheName: string,\n    setName: Uint8Array,\n    limit: number\n  ): Promise<CacheSetSample.Response> {\n    const request = new grpcCache._SetSampleRequest({\n      set_name: setName,\n      limit: limit,\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().SetSample(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp?.missing) {\n            resolve(new CacheSetSample.Miss());\n          } else if (resp?.found) {\n            resolve(new CacheSetSample.Hit(resp.found.elements));\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheSetSample.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async setPop(\n    cacheName: string,\n    setName: string,\n    count: number\n  ): Promise<CacheSetPop.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateSetName(setName);\n      validateSetPopCount(count);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheSetPop.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendSetPop(cacheName, this.convert(setName), count);\n    });\n  }\n\n  private async sendSetPop(\n    cacheName: string,\n    setName: Uint8Array,\n    count: number\n  ): Promise<CacheSetPop.Response> {\n    const request = new grpcCache._SetPopRequest({\n      set_name: setName,\n      count: count,\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().SetPop(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp?.missing) {\n            resolve(new CacheSetPop.Miss());\n          } else if (resp?.found) {\n            resolve(new CacheSetPop.Hit(resp.found.elements));\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheSetPop.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async setLength(\n    cacheName: string,\n    setName: string\n  ): Promise<CacheSetLength.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateSetName(setName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheSetLength.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendSetLength(cacheName, this.convert(setName));\n    });\n  }\n\n  private async sendSetLength(\n    cacheName: string,\n    setName: Uint8Array\n  ): Promise<CacheSetLength.Response> {\n    const request = new grpcCache._SetLengthRequest({\n      set_name: setName,\n    });\n\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().SetLength(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp?.missing) {\n            resolve(new CacheSetLength.Miss());\n          } else if (resp?.found) {\n            if (!resp.found.length) {\n              resolve(new CacheSetLength.Miss());\n            } else {\n              resolve(new CacheSetLength.Hit(resp.found.length));\n            }\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheSetLength.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  // setIfNotExists is deprecated on the service. Here we call the new `SetIf` method with the absent field set\n  // and return `CacheSetIfNotExists` responses.\n  public async setIfNotExists(\n    cacheName: string,\n    key: string | Uint8Array,\n    value: string | Uint8Array,\n    ttl?: number\n  ): Promise<CacheSetIfNotExists.Response> {\n    try {\n      validateCacheName(cacheName);\n      if (ttl !== undefined) {\n        validateTtlSeconds(ttl);\n      }\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheSetIfNotExists.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendSetIfNotExists(\n        cacheName,\n        this.convert(key),\n        this.convert(value),\n        ttl ? ttl * 1000 : this.defaultTtlSeconds * 1000\n      );\n    });\n  }\n\n  private async sendSetIfNotExists(\n    cacheName: string,\n    key: Uint8Array,\n    value: Uint8Array,\n    ttlMilliseconds: number\n  ): Promise<CacheSetIfNotExists.Response> {\n    const request = new grpcCache._SetIfRequest({\n      cache_key: key,\n      cache_body: value,\n      ttl_milliseconds: ttlMilliseconds,\n      absent: new Absent(),\n    });\n    const metadata = this.createMetadata(cacheName);\n\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().SetIf(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp) {\n            switch (resp.result) {\n              case 'stored':\n                resolve(new CacheSetIfNotExists.Stored());\n                break;\n              case 'not_stored':\n                resolve(new CacheSetIfNotExists.NotStored());\n                break;\n              default:\n                resolve(\n                  new CacheSetIfNotExists.Error(\n                    new UnknownError(\n                      'SetIfNotExists responded with an unknown result'\n                    )\n                  )\n                );\n                break;\n            }\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheSetIfNotExists.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async setIfAbsent(\n    cacheName: string,\n    key: string | Uint8Array,\n    value: string | Uint8Array,\n    options?: SetIfAbsentCallOptions\n  ): Promise<CacheSetIfAbsent.Response> {\n    const ttl = options?.ttl;\n    try {\n      validateCacheName(cacheName);\n      if (ttl !== undefined) {\n        validateTtlSeconds(ttl);\n      }\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheSetIfAbsent.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      let encodedValue = this.convert(value);\n      if (options?.compress) {\n        this.logger.trace(\n          'CacheClient.setIfAbsent; compression enabled, calling value compressor'\n        );\n        if (this.compressionDetails === undefined) {\n          return this.cacheServiceErrorMapper.returnOrThrowError(\n            new InvalidArgumentError(\n              'Compressor is not set, but `CacheClient.setIfAbsent` was called with the `compress` option; please install @gomomento/sdk-nodejs-compression and call `Configuration.withCompressionStrategy` to enable compression.'\n            ),\n            err => new CacheSetIfAbsent.Error(err)\n          );\n        }\n        encodedValue = await this.compressionDetails.valueCompressor.compress(\n          this.compressionDetails.compressionLevel,\n          encodedValue\n        );\n      }\n\n      return await this.sendSetIfAbsent(\n        cacheName,\n        this.convert(key),\n        encodedValue,\n        ttl ? ttl * 1000 : this.defaultTtlSeconds * 1000\n      );\n    });\n  }\n\n  private async sendSetIfAbsent(\n    cacheName: string,\n    key: Uint8Array,\n    value: Uint8Array,\n    ttlMilliseconds: number\n  ): Promise<CacheSetIfAbsent.Response> {\n    const request = new grpcCache._SetIfRequest({\n      cache_key: key,\n      cache_body: value,\n      ttl_milliseconds: ttlMilliseconds,\n      absent: new Absent(),\n    });\n    const metadata = this.createMetadata(cacheName);\n\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().SetIf(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp) {\n            switch (resp.result) {\n              case 'stored':\n                resolve(new CacheSetIfAbsent.Stored());\n                break;\n              case 'not_stored':\n                resolve(new CacheSetIfAbsent.NotStored());\n                break;\n              default:\n                resolve(\n                  new CacheSetIfAbsent.Error(\n                    new UnknownError(\n                      'SetIfAbsent responded with an unknown result'\n                    )\n                  )\n                );\n                break;\n            }\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheSetIfAbsent.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async setIfPresent(\n    cacheName: string,\n    key: string | Uint8Array,\n    value: string | Uint8Array,\n    ttl?: number\n  ): Promise<CacheSetIfPresent.Response> {\n    try {\n      validateCacheName(cacheName);\n      if (ttl !== undefined) {\n        validateTtlSeconds(ttl);\n      }\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheSetIfPresent.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendSetIfPresent(\n        cacheName,\n        this.convert(key),\n        this.convert(value),\n        ttl ? ttl * 1000 : this.defaultTtlSeconds * 1000\n      );\n    });\n  }\n\n  private async sendSetIfPresent(\n    cacheName: string,\n    key: Uint8Array,\n    value: Uint8Array,\n    ttlMilliseconds: number\n  ): Promise<CacheSetIfPresent.Response> {\n    const request = new grpcCache._SetIfRequest({\n      cache_key: key,\n      cache_body: value,\n      ttl_milliseconds: ttlMilliseconds,\n      present: new Present(),\n    });\n    const metadata = this.createMetadata(cacheName);\n\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().SetIf(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp) {\n            switch (resp.result) {\n              case 'stored':\n                resolve(new CacheSetIfPresent.Stored());\n                break;\n              case 'not_stored':\n                resolve(new CacheSetIfPresent.NotStored());\n                break;\n              default:\n                resolve(\n                  new CacheSetIfPresent.Error(\n                    new UnknownError(\n                      'SetIfPresent responded with an unknown result'\n                    )\n                  )\n                );\n                break;\n            }\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheSetIfPresent.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async setIfEqual(\n    cacheName: string,\n    key: string | Uint8Array,\n    value: string | Uint8Array,\n    equal: string | Uint8Array,\n    ttl?: number\n  ): Promise<CacheSetIfEqual.Response> {\n    try {\n      validateCacheName(cacheName);\n      if (ttl !== undefined) {\n        validateTtlSeconds(ttl);\n      }\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheSetIfEqual.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendSetIfEqual(\n        cacheName,\n        this.convert(key),\n        this.convert(value),\n        this.convert(equal),\n        ttl ? ttl * 1000 : this.defaultTtlSeconds * 1000\n      );\n    });\n  }\n\n  private async sendSetIfEqual(\n    cacheName: string,\n    key: Uint8Array,\n    value: Uint8Array,\n    equal: Uint8Array,\n    ttlMilliseconds: number\n  ): Promise<CacheSetIfEqual.Response> {\n    const request = new grpcCache._SetIfRequest({\n      cache_key: key,\n      cache_body: value,\n      ttl_milliseconds: ttlMilliseconds,\n      equal: new Equal({value_to_check: equal}),\n    });\n    const metadata = this.createMetadata(cacheName);\n\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().SetIf(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp) {\n            switch (resp.result) {\n              case 'stored':\n                resolve(new CacheSetIfEqual.Stored());\n                break;\n              case 'not_stored':\n                resolve(new CacheSetIfEqual.NotStored());\n                break;\n              default:\n                resolve(\n                  new CacheSetIfEqual.Error(\n                    new UnknownError(\n                      'SetIfEqual responded with an unknown result'\n                    )\n                  )\n                );\n                break;\n            }\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheSetIfEqual.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async setIfNotEqual(\n    cacheName: string,\n    key: string | Uint8Array,\n    value: string | Uint8Array,\n    notEqual: string | Uint8Array,\n    ttl?: number\n  ): Promise<CacheSetIfNotEqual.Response> {\n    try {\n      validateCacheName(cacheName);\n      if (ttl !== undefined) {\n        validateTtlSeconds(ttl);\n      }\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheSetIfNotEqual.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendSetIfNotEqual(\n        cacheName,\n        this.convert(key),\n        this.convert(value),\n        this.convert(notEqual),\n        ttl ? ttl * 1000 : this.defaultTtlSeconds * 1000\n      );\n    });\n  }\n\n  private async sendSetIfNotEqual(\n    cacheName: string,\n    key: Uint8Array,\n    value: Uint8Array,\n    notEqual: Uint8Array,\n    ttlMilliseconds: number\n  ): Promise<CacheSetIfNotEqual.Response> {\n    const request = new grpcCache._SetIfRequest({\n      cache_key: key,\n      cache_body: value,\n      ttl_milliseconds: ttlMilliseconds,\n      not_equal: new NotEqual({value_to_check: notEqual}),\n    });\n    const metadata = this.createMetadata(cacheName);\n\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().SetIf(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp) {\n            switch (resp.result) {\n              case 'stored':\n                resolve(new CacheSetIfNotEqual.Stored());\n                break;\n              case 'not_stored':\n                resolve(new CacheSetIfNotEqual.NotStored());\n                break;\n              default:\n                resolve(\n                  new CacheSetIfNotEqual.Error(\n                    new UnknownError(\n                      'SetIfNotEqual responded with an unknown result'\n                    )\n                  )\n                );\n                break;\n            }\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheSetIfNotEqual.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async setIfPresentAndNotEqual(\n    cacheName: string,\n    key: string | Uint8Array,\n    value: string | Uint8Array,\n    notEqual: string | Uint8Array,\n    ttl?: number\n  ): Promise<CacheSetIfPresentAndNotEqual.Response> {\n    try {\n      validateCacheName(cacheName);\n      if (ttl !== undefined) {\n        validateTtlSeconds(ttl);\n      }\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheSetIfPresentAndNotEqual.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendSetIfPresentAndNotEqual(\n        cacheName,\n        this.convert(key),\n        this.convert(value),\n        this.convert(notEqual),\n        ttl ? ttl * 1000 : this.defaultTtlSeconds * 1000\n      );\n    });\n  }\n\n  private async sendSetIfPresentAndNotEqual(\n    cacheName: string,\n    key: Uint8Array,\n    value: Uint8Array,\n    notEqual: Uint8Array,\n    ttlMilliseconds: number\n  ): Promise<CacheSetIfPresentAndNotEqual.Response> {\n    const request = new grpcCache._SetIfRequest({\n      cache_key: key,\n      cache_body: value,\n      ttl_milliseconds: ttlMilliseconds,\n      present_and_not_equal: new PresentAndNotEqual({value_to_check: notEqual}),\n    });\n    const metadata = this.createMetadata(cacheName);\n\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().SetIf(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp) {\n            switch (resp.result) {\n              case 'stored':\n                resolve(new CacheSetIfPresentAndNotEqual.Stored());\n                break;\n              case 'not_stored':\n                resolve(new CacheSetIfPresentAndNotEqual.NotStored());\n                break;\n              default:\n                resolve(\n                  new CacheSetIfPresentAndNotEqual.Error(\n                    new UnknownError(\n                      'SetIfPresentAndNotEqual responded with an unknown result'\n                    )\n                  )\n                );\n                break;\n            }\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e =>\n                new CacheSetIfPresentAndNotEqual.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async setIfAbsentOrEqual(\n    cacheName: string,\n    key: string | Uint8Array,\n    value: string | Uint8Array,\n    equal: string | Uint8Array,\n    ttl?: number\n  ): Promise<CacheSetIfAbsentOrEqual.Response> {\n    try {\n      validateCacheName(cacheName);\n      if (ttl !== undefined) {\n        validateTtlSeconds(ttl);\n      }\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheSetIfAbsentOrEqual.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendSetIfAbsentOrEqual(\n        cacheName,\n        this.convert(key),\n        this.convert(value),\n        this.convert(equal),\n        ttl ? ttl * 1000 : this.defaultTtlSeconds * 1000\n      );\n    });\n  }\n\n  private async sendSetIfAbsentOrEqual(\n    cacheName: string,\n    key: Uint8Array,\n    value: Uint8Array,\n    equal: Uint8Array,\n    ttlMilliseconds: number\n  ): Promise<CacheSetIfAbsentOrEqual.Response> {\n    const request = new grpcCache._SetIfRequest({\n      cache_key: key,\n      cache_body: value,\n      ttl_milliseconds: ttlMilliseconds,\n      absent_or_equal: new AbsentOrEqual({value_to_check: equal}),\n    });\n    const metadata = this.createMetadata(cacheName);\n\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().SetIf(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp) {\n            switch (resp.result) {\n              case 'stored':\n                resolve(new CacheSetIfAbsentOrEqual.Stored());\n                break;\n              case 'not_stored':\n                resolve(new CacheSetIfAbsentOrEqual.NotStored());\n                break;\n              default:\n                resolve(\n                  new CacheSetIfAbsentOrEqual.Error(\n                    new UnknownError(\n                      'SetIfAbsentOrEqual responded with an unknown result'\n                    )\n                  )\n                );\n                break;\n            }\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheSetIfAbsentOrEqual.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async delete(\n    cacheName: string,\n    key: string | Uint8Array\n  ): Promise<CacheDelete.Response> {\n    try {\n      validateCacheName(cacheName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheDelete.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendDelete(cacheName, this.convert(key));\n    });\n  }\n\n  private async sendDelete(\n    cacheName: string,\n    key: Uint8Array\n  ): Promise<CacheDelete.Response> {\n    const request = new grpcCache._DeleteRequest({\n      cache_key: key,\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().Delete(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp) {\n            resolve(new CacheDelete.Success());\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheDelete.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async get(\n    cacheName: string,\n    key: string | Uint8Array,\n    options?: GetCallOptions\n  ): Promise<CacheGet.Response> {\n    try {\n      validateCacheName(cacheName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheGet.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendGet(cacheName, this.convert(key), options);\n    });\n  }\n\n  private async sendGet(\n    cacheName: string,\n    key: Uint8Array,\n    options?: GetCallOptions\n  ): Promise<CacheGet.Response> {\n    const request = new grpcCache._GetRequest({\n      cache_key: key,\n    });\n    const metadata = this.createMetadata(cacheName);\n\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().Get(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp) {\n            switch (resp.result) {\n              case grpcCache.ECacheResult.Miss:\n                resolve(new CacheGet.Miss());\n                break;\n              case grpcCache.ECacheResult.Hit: {\n                const shouldDecompress =\n                  options?.decompress ??\n                  this.compressionDetails?.autoDecompressEnabled === true;\n                if (!shouldDecompress) {\n                  resolve(new CacheGet.Hit(resp.cache_body));\n                } else {\n                  if (this.compressionDetails === undefined) {\n                    resolve(\n                      new CacheGet.Error(\n                        new CompressionError('CacheClient.Get', 'decompress')\n                      )\n                    );\n                  } else {\n                    this.compressionDetails.valueCompressor\n                      .decompressIfCompressed(resp.cache_body)\n                      .then(v => resolve(new CacheGet.Hit(v)))\n                      .catch(e =>\n                        resolve(\n                          // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                          new CacheGet.Error(new InvalidArgumentError(`${e}`))\n                        )\n                      );\n                  }\n                }\n                break;\n              }\n              case grpcCache.ECacheResult.Invalid:\n              case grpcCache.ECacheResult.Ok:\n                resolve(new CacheGet.Error(new UnknownError(resp.message)));\n                break;\n              default:\n                resolve(\n                  new CacheGet.Error(\n                    new UnknownError(\n                      'An unknown error occurred: ' + resp.message\n                    )\n                  )\n                );\n                break;\n            }\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheGet.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async getBatch(\n    cacheName: string,\n    keys: Array<string | Uint8Array>,\n    options?: GetBatchCallOptions\n  ): Promise<CacheGetBatch.Response> {\n    try {\n      validateCacheName(cacheName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheGetBatch.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendGetBatch(\n        cacheName,\n        keys.map(key => this.convert(key)),\n        options?.decompress\n      );\n    });\n  }\n\n  private async sendGetBatch(\n    cacheName: string,\n    keys: Uint8Array[],\n    decompress?: boolean\n  ): Promise<CacheGetBatch.Response> {\n    const getRequests = [];\n    for (const k of keys) {\n      const getRequest = new grpcCache._GetRequest({\n        cache_key: k,\n      });\n      getRequests.push(getRequest);\n    }\n    const request = new grpcCache._GetBatchRequest({\n      items: getRequests,\n    });\n    const metadata = this.createMetadata(cacheName);\n\n    const call = this.clientWrapper.getClient().GetBatch(request, metadata, {\n      interceptors: this.streamingInterceptors,\n    });\n\n    return await new Promise((resolve, reject) => {\n      const results: CacheGet.Response[] = [];\n      call.on('data', (getResponse: grpcCache._GetResponse) => {\n        const result = getResponse.result;\n        switch (result) {\n          case grpcCache.ECacheResult.Hit:\n            results.push(new CacheGet.Hit(getResponse.cache_body));\n            break;\n          case grpcCache.ECacheResult.Miss:\n            results.push(new CacheGet.Miss());\n            break;\n          default:\n            results.push(\n              new CacheGet.Error(new UnknownError(getResponse.message))\n            );\n        }\n      });\n\n      call.on('end', () => {\n        const shouldDecompress =\n          decompress ?? this.compressionDetails?.autoDecompressEnabled === true;\n        if (!shouldDecompress) {\n          resolve(new CacheGetBatch.Success(results, keys));\n        } else {\n          if (this.compressionDetails === undefined) {\n            resolve(\n              new CacheGetBatch.Error(\n                new CompressionError('CacheClient.Get', 'decompress')\n              )\n            );\n          } else {\n            const compressor: ICompression =\n              this.compressionDetails.valueCompressor;\n            Promise.all(\n              results.map(async r => {\n                if (r instanceof CacheGet.Hit) {\n                  return new CacheGet.Hit(\n                    await compressor.decompressIfCompressed(r.valueUint8Array())\n                  );\n                }\n                return r;\n              })\n            )\n              .then(decompressedResults =>\n                resolve(new CacheGetBatch.Success(decompressedResults, keys))\n              )\n              .catch(e =>\n                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                resolve(new CacheGetBatch.Error(new UnknownError(`${e}`)))\n              );\n          }\n        }\n      });\n\n      call.on('error', (err: ServiceError | null) => {\n        this.cacheServiceErrorMapper.resolveOrRejectError({\n          err: err,\n          errorResponseFactoryFn: e => new CacheGetBatch.Error(e),\n          resolveFn: resolve,\n          rejectFn: reject,\n        });\n      });\n    });\n  }\n\n  public async setBatch(\n    cacheName: string,\n    items:\n      | Record<string, string | Uint8Array>\n      | Map<string | Uint8Array, string | Uint8Array>\n      | Array<SetBatchItem>,\n    options?: SetBatchCallOptions\n  ): Promise<CacheSetBatch.Response> {\n    try {\n      validateCacheName(cacheName);\n      if (options?.ttl !== undefined) {\n        validateTtlSeconds(options?.ttl);\n      }\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheSetBatch.Error(err)\n      );\n    }\n\n    const ttlToUse = options?.ttl || this.defaultTtlSeconds;\n\n    return await this.rateLimited(async () => {\n      let itemsToUse: [Uint8Array, Uint8Array, number][] =\n        this.convertSetBatchElements(items, ttlToUse);\n      if (options?.compress) {\n        this.logger.trace(\n          'CacheClient.setBatch; compression enabled, calling value compressor'\n        );\n        if (this.compressionDetails === undefined) {\n          return this.cacheServiceErrorMapper.returnOrThrowError(\n            new CompressionError('CacheClient.setBatch', 'compress'),\n            err => new CacheSetBatch.Error(err)\n          );\n        } else {\n          const compressor: ICompression =\n            this.compressionDetails.valueCompressor;\n          const compressionLevel: CompressionLevel =\n            this.compressionDetails.compressionLevel;\n          itemsToUse = await Promise.all(\n            itemsToUse.map(async ([key, value, ttl]) => {\n              return [\n                key,\n                await compressor.compress(compressionLevel, value),\n                ttl,\n              ];\n            })\n          );\n        }\n      }\n\n      return await this.sendSetBatch(cacheName, itemsToUse);\n    });\n  }\n\n  private async sendSetBatch(\n    cacheName: string,\n    items: [Uint8Array, Uint8Array, number][]\n  ): Promise<CacheSetBatch.Response> {\n    const setRequests = [];\n    for (const item of items) {\n      const setRequest = new grpcCache._SetRequest({\n        cache_key: item[0],\n        cache_body: item[1],\n        ttl_milliseconds: item[2] * 1000,\n      });\n      setRequests.push(setRequest);\n    }\n    const request = new grpcCache._SetBatchRequest({\n      items: setRequests,\n    });\n\n    const metadata = this.createMetadata(cacheName);\n\n    const call = this.clientWrapper.getClient().SetBatch(request, metadata, {\n      interceptors: this.streamingInterceptors,\n    });\n\n    return await new Promise((resolve, reject) => {\n      const results: CacheSet.Response[] = [];\n      call.on('data', (setResponse: grpcCache._SetResponse) => {\n        const result = setResponse.result;\n        switch (result) {\n          case grpcCache.ECacheResult.Ok:\n            results.push(new CacheSet.Success());\n            break;\n          default:\n            results.push(\n              new CacheSet.Error(new UnknownError(setResponse.message))\n            );\n        }\n      });\n\n      call.on('end', () => {\n        resolve(new CacheSetBatch.Success(results));\n      });\n\n      call.on('error', (err: ServiceError | null) => {\n        this.cacheServiceErrorMapper.resolveOrRejectError({\n          err: err,\n          errorResponseFactoryFn: e => new CacheSetBatch.Error(e),\n          resolveFn: resolve,\n          rejectFn: reject,\n        });\n      });\n    });\n  }\n\n  public async listConcatenateBack(\n    cacheName: string,\n    listName: string,\n    values: string[] | Uint8Array[],\n    truncateFrontToSize?: number,\n    ttl: CollectionTtl = CollectionTtl.fromCacheTtl()\n  ): Promise<CacheListConcatenateBack.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateListName(listName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheListConcatenateBack.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendListConcatenateBack(\n        cacheName,\n        this.convert(listName),\n        this.convertArray(values),\n        ttl.ttlMilliseconds() || this.defaultTtlSeconds * 1000,\n        ttl.refreshTtl(),\n        truncateFrontToSize\n      );\n    });\n  }\n\n  private async sendListConcatenateBack(\n    cacheName: string,\n    listName: Uint8Array,\n    values: Uint8Array[],\n    ttlMilliseconds: number,\n    refreshTtl: boolean,\n    truncateFrontToSize?: number\n  ): Promise<CacheListConcatenateBack.Response> {\n    const request = new grpcCache._ListConcatenateBackRequest({\n      list_name: listName,\n      values: values,\n      ttl_milliseconds: ttlMilliseconds,\n      refresh_ttl: refreshTtl,\n      truncate_front_to_size: truncateFrontToSize,\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().ListConcatenateBack(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp) {\n            resolve(new CacheListConcatenateBack.Success(resp.list_length));\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e =>\n                new CacheListConcatenateBack.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async listConcatenateFront(\n    cacheName: string,\n    listName: string,\n    values: string[] | Uint8Array[],\n    truncateBackToSize?: number,\n    ttl: CollectionTtl = CollectionTtl.fromCacheTtl()\n  ): Promise<CacheListConcatenateFront.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateListName(listName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheListConcatenateFront.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendListConcatenateFront(\n        cacheName,\n        this.convert(listName),\n        this.convertArray(values),\n        ttl.ttlMilliseconds() || this.defaultTtlSeconds * 1000,\n        ttl.refreshTtl(),\n        truncateBackToSize\n      );\n    });\n  }\n\n  private async sendListConcatenateFront(\n    cacheName: string,\n    listName: Uint8Array,\n    values: Uint8Array[],\n    ttlMilliseconds: number,\n    refreshTtl: boolean,\n    truncateBackToSize?: number\n  ): Promise<CacheListConcatenateFront.Response> {\n    const request = new grpcCache._ListConcatenateFrontRequest({\n      list_name: listName,\n      values: values,\n      ttl_milliseconds: ttlMilliseconds,\n      refresh_ttl: refreshTtl,\n      truncate_back_to_size: truncateBackToSize,\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().ListConcatenateFront(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp) {\n            resolve(new CacheListConcatenateFront.Success(resp.list_length));\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e =>\n                new CacheListConcatenateFront.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async listFetch(\n    cacheName: string,\n    listName: string,\n    startIndex?: number,\n    endIndex?: number\n  ): Promise<CacheListFetch.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateListName(listName);\n      validateListSliceStartEnd(startIndex, endIndex);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheListFetch.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendListFetch(\n        cacheName,\n        this.convert(listName),\n        startIndex,\n        endIndex\n      );\n    });\n  }\n\n  private async sendListFetch(\n    cacheName: string,\n    listName: Uint8Array,\n    start?: number,\n    end?: number\n  ): Promise<CacheListFetch.Response> {\n    const request = new grpcCache._ListFetchRequest({\n      list_name: listName,\n    });\n    if (start) {\n      request.inclusive_start = start;\n    } else {\n      request.unbounded_start = new _Unbounded();\n    }\n    if (end) {\n      request.exclusive_end = end;\n    } else {\n      request.unbounded_end = new _Unbounded();\n    }\n    const metadata = this.createMetadata(cacheName);\n\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().ListFetch(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp?.missing) {\n            resolve(new CacheListFetch.Miss());\n          } else if (resp?.found) {\n            resolve(new CacheListFetch.Hit(resp.found.values));\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheListFetch.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async listRetain(\n    cacheName: string,\n    listName: string,\n    startIndex?: number,\n    endIndex?: number,\n    ttl: CollectionTtl = CollectionTtl.fromCacheTtl()\n  ): Promise<CacheListRetain.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateListName(listName);\n      validateListSliceStartEnd(startIndex, endIndex);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheListRetain.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendListRetain(\n        cacheName,\n        this.convert(listName),\n        startIndex,\n        endIndex,\n        ttl.ttlMilliseconds() || this.defaultTtlSeconds * 1000,\n        ttl.refreshTtl()\n      );\n    });\n  }\n\n  private async sendListRetain(\n    cacheName: string,\n    listName: Uint8Array,\n    start?: number,\n    end?: number,\n    ttlMilliseconds?: number,\n    refreshTtl?: boolean\n  ): Promise<CacheListRetain.Response> {\n    const request = new grpcCache._ListRetainRequest({\n      list_name: listName,\n      ttl_milliseconds: ttlMilliseconds,\n      refresh_ttl: refreshTtl,\n    });\n    if (start) {\n      request.inclusive_start = start;\n    } else {\n      request.unbounded_start = new _Unbounded();\n    }\n    if (end) {\n      request.exclusive_end = end;\n    } else {\n      request.unbounded_end = new _Unbounded();\n    }\n    const metadata = this.createMetadata(cacheName);\n\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().ListRetain(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp) {\n            resolve(new CacheListRetain.Success());\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheListRetain.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async listLength(\n    cacheName: string,\n    listName: string\n  ): Promise<CacheListLength.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateListName(listName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheListLength.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendListLength(cacheName, this.convert(listName));\n    });\n  }\n\n  private async sendListLength(\n    cacheName: string,\n    listName: Uint8Array\n  ): Promise<CacheListLength.Response> {\n    const request = new grpcCache._ListLengthRequest({\n      list_name: listName,\n    });\n    const metadata = this.createMetadata(cacheName);\n\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().ListLength(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp?.missing) {\n            resolve(new CacheListLength.Miss());\n          } else if (resp?.found) {\n            resolve(new CacheListLength.Hit(resp.found.length));\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheListLength.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async listPopBack(\n    cacheName: string,\n    listName: string\n  ): Promise<CacheListPopBack.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateListName(listName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheListPopBack.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendListPopBack(cacheName, this.convert(listName));\n    });\n  }\n\n  private async sendListPopBack(\n    cacheName: string,\n    listName: Uint8Array\n  ): Promise<CacheListPopBack.Response> {\n    const request = new grpcCache._ListPopBackRequest({\n      list_name: listName,\n    });\n    const metadata = this.createMetadata(cacheName);\n\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().ListPopBack(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp?.missing) {\n            resolve(new CacheListPopBack.Miss());\n          } else if (resp?.found) {\n            resolve(new CacheListPopBack.Hit(resp.found.back));\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheListPopBack.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async listPopFront(\n    cacheName: string,\n    listName: string\n  ): Promise<CacheListPopFront.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateListName(listName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheListPopFront.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendListPopFront(cacheName, this.convert(listName));\n    });\n  }\n\n  private async sendListPopFront(\n    cacheName: string,\n    listName: Uint8Array\n  ): Promise<CacheListPopFront.Response> {\n    const request = new grpcCache._ListPopFrontRequest({\n      list_name: listName,\n    });\n    const metadata = this.createMetadata(cacheName);\n\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().ListPopFront(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp?.missing) {\n            resolve(new CacheListPopFront.Miss());\n          } else if (resp?.found) {\n            resolve(new CacheListPopFront.Hit(resp.found.front));\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheListPopFront.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async listPushBack(\n    cacheName: string,\n    listName: string,\n    value: string | Uint8Array,\n    truncateFrontToSize?: number,\n    ttl: CollectionTtl = CollectionTtl.fromCacheTtl()\n  ): Promise<CacheListPushBack.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateListName(listName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheListPushBack.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendListPushBack(\n        cacheName,\n        this.convert(listName),\n        this.convert(value),\n        ttl.ttlMilliseconds() || this.defaultTtlSeconds * 1000,\n        ttl.refreshTtl(),\n        truncateFrontToSize\n      );\n    });\n  }\n\n  private async sendListPushBack(\n    cacheName: string,\n    listName: Uint8Array,\n    value: Uint8Array,\n    ttlMilliseconds: number,\n    refreshTtl: boolean,\n    truncateFrontToSize?: number\n  ): Promise<CacheListPushBack.Response> {\n    const request = new grpcCache._ListPushBackRequest({\n      list_name: listName,\n      value: value,\n      ttl_milliseconds: ttlMilliseconds,\n      refresh_ttl: refreshTtl,\n      truncate_front_to_size: truncateFrontToSize,\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().ListPushBack(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp) {\n            resolve(new CacheListPushBack.Success(resp.list_length));\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheListPushBack.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async listPushFront(\n    cacheName: string,\n    listName: string,\n    value: string | Uint8Array,\n    truncateBackToSize?: number,\n    ttl: CollectionTtl = CollectionTtl.fromCacheTtl()\n  ): Promise<CacheListPushFront.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateListName(listName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheListPushFront.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendListPushFront(\n        cacheName,\n        this.convert(listName),\n        this.convert(value),\n        ttl.ttlMilliseconds() || this.defaultTtlSeconds * 1000,\n        ttl.refreshTtl(),\n        truncateBackToSize\n      );\n    });\n  }\n\n  private async sendListPushFront(\n    cacheName: string,\n    listName: Uint8Array,\n    value: Uint8Array,\n    ttlMilliseconds: number,\n    refreshTtl: boolean,\n    truncateBackToSize?: number\n  ): Promise<CacheListPushFront.Response> {\n    const request = new grpcCache._ListPushFrontRequest({\n      list_name: listName,\n      value: value,\n      ttl_milliseconds: ttlMilliseconds,\n      refresh_ttl: refreshTtl,\n      truncate_back_to_size: truncateBackToSize,\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().ListPushFront(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp) {\n            resolve(new CacheListPushFront.Success(resp.list_length));\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheListPushFront.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async listRemoveValue(\n    cacheName: string,\n    listName: string,\n    value: string | Uint8Array\n  ): Promise<CacheListRemoveValue.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateListName(listName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheListRemoveValue.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendListRemoveValue(\n        cacheName,\n        this.convert(listName),\n        this.convert(value)\n      );\n    });\n  }\n\n  private async sendListRemoveValue(\n    cacheName: string,\n    listName: Uint8Array,\n    value: Uint8Array\n  ): Promise<CacheListRemoveValue.Response> {\n    const request = new grpcCache._ListRemoveRequest({\n      list_name: listName,\n      all_elements_with_value: value,\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().ListRemove(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp) {\n            resolve(new CacheListRemoveValue.Success());\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheListRemoveValue.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async dictionaryFetch(\n    cacheName: string,\n    dictionaryName: string\n  ): Promise<CacheDictionaryFetch.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateDictionaryName(dictionaryName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheDictionaryFetch.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendDictionaryFetch(\n        cacheName,\n        this.convert(dictionaryName)\n      );\n    });\n  }\n\n  private async sendDictionaryFetch(\n    cacheName: string,\n    dictionaryName: Uint8Array\n  ): Promise<CacheDictionaryFetch.Response> {\n    const request = new grpcCache._DictionaryFetchRequest({\n      dictionary_name: dictionaryName,\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().DictionaryFetch(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp?.found) {\n            resolve(new CacheDictionaryFetch.Hit(resp.found.items));\n          } else if (resp?.missing) {\n            resolve(new CacheDictionaryFetch.Miss());\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheDictionaryFetch.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async dictionarySetField(\n    cacheName: string,\n    dictionaryName: string,\n    field: string | Uint8Array,\n    value: string | Uint8Array,\n    ttl: CollectionTtl = CollectionTtl.fromCacheTtl()\n  ): Promise<CacheDictionarySetField.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateDictionaryName(dictionaryName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheDictionarySetField.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendDictionarySetField(\n        cacheName,\n        this.convert(dictionaryName),\n        this.convert(field),\n        this.convert(value),\n        ttl.ttlMilliseconds() || this.defaultTtlSeconds * 1000,\n        ttl.refreshTtl()\n      );\n    });\n  }\n\n  private async sendDictionarySetField(\n    cacheName: string,\n    dictionaryName: Uint8Array,\n    field: Uint8Array,\n    value: Uint8Array,\n    ttlMilliseconds: number,\n    refreshTtl: boolean\n  ): Promise<CacheDictionarySetField.Response> {\n    const request = new grpcCache._DictionarySetRequest({\n      dictionary_name: dictionaryName,\n      items: this.toSingletonFieldValuePair(field, value),\n      ttl_milliseconds: ttlMilliseconds,\n      refresh_ttl: refreshTtl,\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().DictionarySet(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp) {\n            resolve(new CacheDictionarySetField.Success());\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheDictionarySetField.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async dictionarySetFields(\n    cacheName: string,\n    dictionaryName: string,\n    elements:\n      | Map<string | Uint8Array, string | Uint8Array>\n      | Record<string, string | Uint8Array>\n      | Array<[string, string | Uint8Array]>,\n    ttl: CollectionTtl = CollectionTtl.fromCacheTtl()\n  ): Promise<CacheDictionarySetFields.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateDictionaryName(dictionaryName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheDictionarySetFields.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      const dictionaryFieldValuePairs = this.convertElements(elements);\n\n      return await this.sendDictionarySetFields(\n        cacheName,\n        this.convert(dictionaryName),\n        dictionaryFieldValuePairs,\n        ttl.ttlMilliseconds() || this.defaultTtlSeconds * 1000,\n        ttl.refreshTtl()\n      );\n    });\n  }\n\n  private async sendDictionarySetFields(\n    cacheName: string,\n    dictionaryName: Uint8Array,\n    elements: grpcCache._DictionaryFieldValuePair[],\n    ttlMilliseconds: number,\n    refreshTtl: boolean\n  ): Promise<CacheDictionarySetFields.Response> {\n    const request = new grpcCache._DictionarySetRequest({\n      dictionary_name: dictionaryName,\n      items: elements,\n      ttl_milliseconds: ttlMilliseconds,\n      refresh_ttl: refreshTtl,\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().DictionarySet(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp) {\n            resolve(new CacheDictionarySetFields.Success());\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e =>\n                new CacheDictionarySetFields.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async dictionaryGetField(\n    cacheName: string,\n    dictionaryName: string,\n    field: string | Uint8Array\n  ): Promise<CacheDictionaryGetField.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateDictionaryName(dictionaryName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheDictionaryGetField.Error(err, this.convert(field))\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendDictionaryGetField(\n        cacheName,\n        this.convert(dictionaryName),\n        this.convert(field)\n      );\n    });\n  }\n\n  private async sendDictionaryGetField(\n    cacheName: string,\n    dictionaryName: Uint8Array,\n    field: Uint8Array\n  ): Promise<CacheDictionaryGetField.Response> {\n    const request = new grpcCache._DictionaryGetRequest({\n      dictionary_name: dictionaryName,\n      fields: [field],\n    });\n    const metadata = this.createMetadata(cacheName);\n\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().DictionaryGet(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp?.dictionary === 'missing') {\n            resolve(new CacheDictionaryGetField.Miss(field));\n          } else if (resp?.dictionary === 'found') {\n            if (resp?.found.items.length === 0) {\n              resolve(\n                new CacheDictionaryGetField.Error(\n                  new UnknownError(\n                    '_DictionaryGetResponseResponse contained no data but was found'\n                  ),\n                  field\n                )\n              );\n            } else if (\n              resp?.found.items[0].result === grpcCache.ECacheResult.Miss\n            ) {\n              resolve(new CacheDictionaryGetField.Miss(field));\n            } else {\n              resolve(\n                new CacheDictionaryGetField.Hit(\n                  resp?.found.items[0].cache_body,\n                  field\n                )\n              );\n            }\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e =>\n                new CacheDictionaryGetField.Error(e, field),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async dictionaryGetFields(\n    cacheName: string,\n    dictionaryName: string,\n    fields: string[] | Uint8Array[]\n  ): Promise<CacheDictionaryGetFields.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateDictionaryName(dictionaryName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheDictionaryGetFields.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendDictionaryGetFields(\n        cacheName,\n        this.convert(dictionaryName),\n        this.convertArray(fields)\n      );\n    });\n  }\n\n  private async sendDictionaryGetFields(\n    cacheName: string,\n    dictionaryName: Uint8Array,\n    fields: Uint8Array[]\n  ): Promise<CacheDictionaryGetFields.Response> {\n    const request = new grpcCache._DictionaryGetRequest({\n      dictionary_name: dictionaryName,\n      fields: fields,\n    });\n    const metadata = this.createMetadata(cacheName);\n\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().DictionaryGet(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp?.dictionary === 'found') {\n            const items = resp.found.items.map(item => {\n              const result = this.convertECacheResult(item.result);\n              return new _DictionaryGetResponsePart(result, item.cache_body);\n            });\n            resolve(new CacheDictionaryGetFields.Hit(items, fields));\n          } else if (resp?.dictionary === 'missing') {\n            resolve(new CacheDictionaryGetFields.Miss());\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e =>\n                new CacheDictionaryGetFields.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async dictionaryRemoveField(\n    cacheName: string,\n    dictionaryName: string,\n    field: string | Uint8Array\n  ): Promise<CacheDictionaryRemoveField.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateDictionaryName(dictionaryName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheDictionaryRemoveField.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendDictionaryRemoveField(\n        cacheName,\n        this.convert(dictionaryName),\n        this.convert(field)\n      );\n    });\n  }\n\n  private async sendDictionaryRemoveField(\n    cacheName: string,\n    dictionaryName: Uint8Array,\n    field: Uint8Array\n  ): Promise<CacheDictionaryRemoveField.Response> {\n    const request = new grpcCache._DictionaryDeleteRequest({\n      dictionary_name: dictionaryName,\n      some: new grpcCache._DictionaryDeleteRequest.Some(),\n    });\n    request.some.fields.push(field);\n    const metadata = this.createMetadata(cacheName);\n\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().DictionaryDelete(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp) {\n            resolve(new CacheDictionaryRemoveField.Success());\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e =>\n                new CacheDictionaryRemoveField.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async dictionaryRemoveFields(\n    cacheName: string,\n    dictionaryName: string,\n    fields: string[] | Uint8Array[]\n  ): Promise<CacheDictionaryRemoveFields.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateDictionaryName(dictionaryName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheDictionaryRemoveFields.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendDictionaryRemoveFields(\n        cacheName,\n        this.convert(dictionaryName),\n        this.convertArray(fields)\n      );\n    });\n  }\n\n  private async sendDictionaryRemoveFields(\n    cacheName: string,\n    dictionaryName: Uint8Array,\n    fields: Uint8Array[]\n  ): Promise<CacheDictionaryRemoveFields.Response> {\n    const request = new grpcCache._DictionaryDeleteRequest({\n      dictionary_name: dictionaryName,\n      some: new grpcCache._DictionaryDeleteRequest.Some(),\n    });\n    fields.forEach(field => request.some.fields.push(field));\n    const metadata = this.createMetadata(cacheName);\n\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().DictionaryDelete(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp) {\n            resolve(new CacheDictionaryRemoveFields.Success());\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e =>\n                new CacheDictionaryRemoveFields.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async dictionaryLength(\n    cacheName: string,\n    dictionaryName: string\n  ): Promise<CacheDictionaryLength.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateDictionaryName(dictionaryName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheDictionaryLength.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendDictionaryLength(\n        cacheName,\n        this.convert(dictionaryName)\n      );\n    });\n  }\n\n  private async sendDictionaryLength(\n    cacheName: string,\n    dictionaryName: Uint8Array\n  ): Promise<CacheDictionaryLength.Response> {\n    const request = new grpcCache._DictionaryLengthRequest({\n      dictionary_name: dictionaryName,\n    });\n    const metadata = this.createMetadata(cacheName);\n\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().DictionaryLength(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp?.missing) {\n            resolve(new CacheDictionaryLength.Miss());\n          } else if (resp?.found) {\n            resolve(new CacheDictionaryLength.Hit(resp.found.length));\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheDictionaryLength.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async increment(\n    cacheName: string,\n    field: string | Uint8Array,\n    amount = 1,\n    ttl?: number\n  ): Promise<CacheIncrement.Response> {\n    try {\n      validateCacheName(cacheName);\n      if (ttl !== undefined) {\n        validateTtlSeconds(ttl);\n      }\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheIncrement.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendIncrement(\n        cacheName,\n        this.convert(field),\n        amount,\n        (ttl || this.defaultTtlSeconds) * 1000\n      );\n    });\n  }\n\n  private async sendIncrement(\n    cacheName: string,\n    field: Uint8Array,\n    amount = 1,\n    ttlMilliseconds: number\n  ): Promise<CacheIncrement.Response> {\n    const request = new grpcCache._IncrementRequest({\n      cache_key: field,\n      amount,\n      ttl_milliseconds: ttlMilliseconds,\n    });\n    const metadata = this.createMetadata(cacheName);\n\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().Increment(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp) {\n            if (resp.value) {\n              resolve(new CacheIncrement.Success(resp.value));\n            } else {\n              resolve(new CacheIncrement.Success(0));\n            }\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheIncrement.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async dictionaryIncrement(\n    cacheName: string,\n    dictionaryName: string,\n    field: string | Uint8Array,\n    amount = 1,\n    ttl: CollectionTtl = CollectionTtl.fromCacheTtl()\n  ): Promise<CacheDictionaryIncrement.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateDictionaryName(dictionaryName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheDictionaryIncrement.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendDictionaryIncrement(\n        cacheName,\n        this.convert(dictionaryName),\n        this.convert(field),\n        amount,\n        ttl.ttlMilliseconds() || this.defaultTtlSeconds * 1000,\n        ttl.refreshTtl()\n      );\n    });\n  }\n\n  private async sendDictionaryIncrement(\n    cacheName: string,\n    dictionaryName: Uint8Array,\n    field: Uint8Array,\n    amount: number,\n    ttlMilliseconds: number,\n    refreshTtl: boolean\n  ): Promise<CacheDictionaryIncrement.Response> {\n    const request = new grpcCache._DictionaryIncrementRequest({\n      dictionary_name: dictionaryName,\n      field,\n      amount,\n      ttl_milliseconds: ttlMilliseconds,\n      refresh_ttl: refreshTtl,\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().DictionaryIncrement(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp) {\n            if (resp.value) {\n              resolve(new CacheDictionaryIncrement.Success(resp.value));\n            } else {\n              resolve(new CacheDictionaryIncrement.Success(0));\n            }\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e =>\n                new CacheDictionaryIncrement.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async sortedSetPutElement(\n    cacheName: string,\n    sortedSetName: string,\n    value: string | Uint8Array,\n    score: number,\n    ttl: CollectionTtl = CollectionTtl.fromCacheTtl()\n  ): Promise<CacheSortedSetPutElement.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateSortedSetName(sortedSetName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheSortedSetPutElement.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendSortedSetPutElement(\n        cacheName,\n        this.convert(sortedSetName),\n        this.convert(value),\n        score,\n        ttl.ttlMilliseconds() || this.defaultTtlSeconds * 1000,\n        ttl.refreshTtl()\n      );\n    });\n  }\n\n  private async sendSortedSetPutElement(\n    cacheName: string,\n    sortedSetName: Uint8Array,\n    value: Uint8Array,\n    score: number,\n    ttlMilliseconds: number,\n    refreshTtl: boolean\n  ): Promise<CacheSortedSetPutElement.Response> {\n    const request = new grpcCache._SortedSetPutRequest({\n      set_name: sortedSetName,\n      elements: [new grpcCache._SortedSetElement({value, score})],\n      ttl_milliseconds: ttlMilliseconds,\n      refresh_ttl: refreshTtl,\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().SortedSetPut(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp) {\n            resolve(new CacheSortedSetPutElement.Success());\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e =>\n                new CacheSortedSetPutElement.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async sortedSetPutElements(\n    cacheName: string,\n    sortedSetName: string,\n    elements:\n      | Map<string | Uint8Array, number>\n      | Record<string, number>\n      | Array<[string, number]>,\n    ttl: CollectionTtl = CollectionTtl.fromCacheTtl()\n  ): Promise<CacheSortedSetPutElements.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateSortedSetName(sortedSetName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheSortedSetPutElements.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      const sortedSetValueScorePairs =\n        this.convertSortedSetMapOrRecord(elements);\n\n      return await this.sendSortedSetPutElements(\n        cacheName,\n        this.convert(sortedSetName),\n        sortedSetValueScorePairs,\n        ttl.ttlMilliseconds() || this.defaultTtlSeconds * 1000,\n        ttl.refreshTtl()\n      );\n    });\n  }\n\n  private async sendSortedSetPutElements(\n    cacheName: string,\n    sortedSetName: Uint8Array,\n    elements: grpcCache._SortedSetElement[],\n    ttlMilliseconds: number,\n    refreshTtl: boolean\n  ): Promise<CacheSortedSetPutElements.Response> {\n    const request = new grpcCache._SortedSetPutRequest({\n      set_name: sortedSetName,\n      elements: elements,\n      ttl_milliseconds: ttlMilliseconds,\n      refresh_ttl: refreshTtl,\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().SortedSetPut(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp) {\n            resolve(new CacheSortedSetPutElements.Success());\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e =>\n                new CacheSortedSetPutElements.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async sortedSetFetchByRank(\n    cacheName: string,\n    sortedSetName: string,\n    order: SortedSetOrder,\n    startRank: number,\n    endRank?: number\n  ): Promise<CacheSortedSetFetch.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateSortedSetName(sortedSetName);\n      validateSortedSetRanks(startRank, endRank);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheSortedSetFetch.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendSortedSetFetchByRank(\n        cacheName,\n        this.convert(sortedSetName),\n        order,\n        startRank,\n        endRank\n      );\n    });\n  }\n\n  private async sendSortedSetFetchByRank(\n    cacheName: string,\n    sortedSetName: Uint8Array,\n    order: SortedSetOrder,\n    startRank: number,\n    endRank?: number\n  ): Promise<CacheSortedSetFetch.Response> {\n    const by_index = new grpcCache._SortedSetFetchRequest._ByIndex();\n    if (startRank) {\n      by_index.inclusive_start_index = startRank;\n    } else {\n      by_index.unbounded_start = new _Unbounded();\n    }\n    if (endRank) {\n      by_index.exclusive_end_index = endRank;\n    } else {\n      by_index.unbounded_end = new _Unbounded();\n    }\n\n    const protoBufOrder =\n      order === SortedSetOrder.Descending\n        ? grpcCache._SortedSetFetchRequest.Order.DESCENDING\n        : grpcCache._SortedSetFetchRequest.Order.ASCENDING;\n\n    const request = new grpcCache._SortedSetFetchRequest({\n      set_name: sortedSetName,\n      order: protoBufOrder,\n      with_scores: true,\n      by_index: by_index,\n    });\n\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().SortedSetFetch(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp) {\n            if (resp?.found) {\n              if (resp?.found?.values_with_scores) {\n                resolve(\n                  new CacheSortedSetFetch.Hit(\n                    resp.found.values_with_scores.elements\n                  )\n                );\n              } else {\n                resolve(\n                  new CacheSortedSetFetch.Error(\n                    new UnknownError(\n                      'Unknown sorted set fetch hit response type'\n                    )\n                  )\n                );\n              }\n            } else if (resp?.missing) {\n              resolve(new CacheSortedSetFetch.Miss());\n            } else {\n              resolve(\n                new CacheSortedSetFetch.Error(\n                  new UnknownError('Unknown sorted set fetch response type')\n                )\n              );\n            }\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheSortedSetFetch.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async sortedSetFetchByScore(\n    cacheName: string,\n    sortedSetName: string,\n    order: SortedSetOrder,\n    minScore?: number,\n    maxScore?: number,\n    offset?: number,\n    count?: number\n  ): Promise<CacheSortedSetFetch.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateSortedSetName(sortedSetName);\n      validateSortedSetScores(minScore, maxScore);\n      if (offset !== undefined) {\n        validateSortedSetOffset(offset);\n      }\n      if (count !== undefined) {\n        validateSortedSetCount(count);\n      }\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheSortedSetFetch.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendSortedSetFetchByScore(\n        cacheName,\n        this.convert(sortedSetName),\n        order,\n        minScore,\n        maxScore,\n        offset,\n        count\n      );\n    });\n  }\n\n  private async sendSortedSetFetchByScore(\n    cacheName: string,\n    sortedSetName: Uint8Array,\n    order: SortedSetOrder,\n    minScore?: number,\n    maxScore?: number,\n    offset?: number,\n    count?: number\n  ): Promise<CacheSortedSetFetch.Response> {\n    const by_score = new grpcCache._SortedSetFetchRequest._ByScore();\n    if (minScore !== undefined) {\n      by_score.min_score = new grpcCache._SortedSetFetchRequest._ByScore._Score(\n        {\n          score: minScore,\n          exclusive: false,\n        }\n      );\n    } else {\n      by_score.unbounded_min = new _Unbounded();\n    }\n    if (maxScore !== undefined) {\n      by_score.max_score = new grpcCache._SortedSetFetchRequest._ByScore._Score(\n        {\n          score: maxScore,\n          exclusive: false,\n        }\n      );\n    } else {\n      by_score.unbounded_max = new _Unbounded();\n    }\n    by_score.offset = offset ?? 0;\n    // Note: the service reserves negative counts to mean all elements in the\n    // result set.\n    by_score.count = count ?? -1;\n\n    const protoBufOrder =\n      order === SortedSetOrder.Descending\n        ? grpcCache._SortedSetFetchRequest.Order.DESCENDING\n        : grpcCache._SortedSetFetchRequest.Order.ASCENDING;\n\n    const request = new grpcCache._SortedSetFetchRequest({\n      set_name: sortedSetName,\n      order: protoBufOrder,\n      with_scores: true,\n      by_score: by_score,\n    });\n\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().SortedSetFetch(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp) {\n            if (resp?.found) {\n              if (resp?.found?.values_with_scores) {\n                resolve(\n                  new CacheSortedSetFetch.Hit(\n                    resp.found.values_with_scores.elements\n                  )\n                );\n              } else {\n                resolve(\n                  new CacheSortedSetFetch.Error(\n                    new UnknownError(\n                      'Unknown sorted set fetch hit response type'\n                    )\n                  )\n                );\n              }\n            } else if (resp?.missing) {\n              resolve(new CacheSortedSetFetch.Miss());\n            } else {\n              resolve(\n                new CacheSortedSetFetch.Error(\n                  new UnknownError('Unknown sorted set fetch response type')\n                )\n              );\n            }\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheSortedSetFetch.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async sortedSetGetRank(\n    cacheName: string,\n    sortedSetName: string,\n    value: string | Uint8Array,\n    order?: SortedSetOrder\n  ): Promise<CacheSortedSetGetRank.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateSortedSetName(sortedSetName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheSortedSetGetRank.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendSortedSetGetRank(\n        cacheName,\n        this.convert(sortedSetName),\n        this.convert(value),\n        order\n      );\n    });\n  }\n\n  private async sendSortedSetGetRank(\n    cacheName: string,\n    sortedSetName: Uint8Array,\n    value: Uint8Array,\n    order?: SortedSetOrder\n  ): Promise<CacheSortedSetGetRank.Response> {\n    const protoBufOrder =\n      order === SortedSetOrder.Descending\n        ? grpcCache._SortedSetGetRankRequest.Order.DESCENDING\n        : grpcCache._SortedSetGetRankRequest.Order.ASCENDING;\n\n    const request = new grpcCache._SortedSetGetRankRequest({\n      set_name: sortedSetName,\n      value: value,\n      order: protoBufOrder,\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper\n        .getClient()\n        .SortedSetGetRank(\n          request,\n          metadata,\n          {interceptors: this.interceptors},\n          (err, resp) => {\n            if (\n              resp?.missing ||\n              resp?.element_rank?.result === ECacheResult.Miss\n            ) {\n              resolve(new CacheSortedSetGetRank.Miss());\n            } else if (resp?.element_rank?.result === ECacheResult.Hit) {\n              if (resp?.element_rank.rank === undefined) {\n                resolve(new CacheSortedSetGetRank.Miss());\n              } else {\n                resolve(new CacheSortedSetGetRank.Hit(resp.element_rank.rank));\n              }\n            } else {\n              this.cacheServiceErrorMapper.resolveOrRejectError({\n                err: err,\n                errorResponseFactoryFn: e => new CacheSortedSetGetRank.Error(e),\n                resolveFn: resolve,\n                rejectFn: reject,\n              });\n            }\n          }\n        );\n    });\n  }\n\n  public async sortedSetGetScore(\n    cacheName: string,\n    sortedSetName: string,\n    value: string | Uint8Array\n  ): Promise<CacheSortedSetGetScore.Response> {\n    const responses = await this.sortedSetGetScores(cacheName, sortedSetName, [\n      value,\n    ] as string[] | Uint8Array[]);\n    if (responses instanceof CacheSortedSetGetScores.Hit) {\n      return responses.responses()[0];\n    } else if (responses instanceof CacheSortedSetGetScores.Miss) {\n      return new CacheSortedSetGetScore.Miss(this.convert(value));\n    } else if (responses instanceof CacheSortedSetGetScores.Error) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        responses.innerException(),\n        err => new CacheSortedSetGetScore.Error(err, this.convert(value))\n      );\n    }\n\n    return this.cacheServiceErrorMapper.returnOrThrowError(\n      new UnknownError('Unknown response type'),\n      err => new CacheSortedSetGetScore.Error(err, this.convert(value))\n    );\n  }\n\n  public async sortedSetGetScores(\n    cacheName: string,\n    sortedSetName: string,\n    values: string[] | Uint8Array[]\n  ): Promise<CacheSortedSetGetScores.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateSortedSetName(sortedSetName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheSortedSetGetScores.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendSortedSetGetScores(\n        cacheName,\n        this.convert(sortedSetName),\n        values.map(value => this.convert(value))\n      );\n    });\n  }\n\n  private async sendSortedSetGetScores(\n    cacheName: string,\n    sortedSetName: Uint8Array,\n    values: Uint8Array[]\n  ): Promise<CacheSortedSetGetScores.Response> {\n    const request = new grpcCache._SortedSetGetScoreRequest({\n      set_name: sortedSetName,\n      values: values,\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper\n        .getClient()\n        .SortedSetGetScore(\n          request,\n          metadata,\n          {interceptors: this.interceptors},\n          (err, resp) => {\n            if (resp?.missing) {\n              resolve(new CacheSortedSetGetScores.Miss());\n            } else if (resp?.found) {\n              const elements = resp.found.elements.map(ele => {\n                const result = this.convertECacheResult(ele.result);\n                return new _SortedSetGetScoreResponsePart(result, ele.score);\n              });\n              resolve(new CacheSortedSetGetScores.Hit(elements, values));\n            } else {\n              this.cacheServiceErrorMapper.resolveOrRejectError({\n                err: err,\n                errorResponseFactoryFn: e =>\n                  new CacheSortedSetGetScores.Error(e),\n                resolveFn: resolve,\n                rejectFn: reject,\n              });\n            }\n          }\n        );\n    });\n  }\n\n  public async sortedSetIncrementScore(\n    cacheName: string,\n    sortedSetName: string,\n    value: string | Uint8Array,\n    amount = 1,\n    ttl: CollectionTtl = CollectionTtl.fromCacheTtl()\n  ): Promise<CacheSortedSetIncrementScore.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateSortedSetName(sortedSetName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheSortedSetIncrementScore.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendSortedSetIncrementScore(\n        cacheName,\n        this.convert(sortedSetName),\n        this.convert(value),\n        amount,\n        ttl.ttlMilliseconds() || this.defaultTtlSeconds * 1000,\n        ttl.refreshTtl()\n      );\n    });\n  }\n\n  private async sendSortedSetIncrementScore(\n    cacheName: string,\n    sortedSetName: Uint8Array,\n    value: Uint8Array,\n    amount: number,\n    ttlMilliseconds: number,\n    refreshTtl: boolean\n  ): Promise<CacheSortedSetIncrementScore.Response> {\n    const request = new grpcCache._SortedSetIncrementRequest({\n      set_name: sortedSetName,\n      value: value,\n      amount: amount,\n      ttl_milliseconds: ttlMilliseconds,\n      refresh_ttl: refreshTtl,\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper\n        .getClient()\n        .SortedSetIncrement(\n          request,\n          metadata,\n          {interceptors: this.interceptors},\n          (err, resp) => {\n            if (resp) {\n              if (resp.score) {\n                resolve(new CacheSortedSetIncrementScore.Success(resp.score));\n              } else {\n                resolve(new CacheSortedSetIncrementScore.Success(0));\n              }\n            } else {\n              this.cacheServiceErrorMapper.resolveOrRejectError({\n                err: err,\n                errorResponseFactoryFn: e =>\n                  new CacheSortedSetIncrementScore.Error(e),\n                resolveFn: resolve,\n                rejectFn: reject,\n              });\n            }\n          }\n        );\n    });\n  }\n\n  public async sortedSetRemoveElement(\n    cacheName: string,\n    sortedSetName: string,\n    value: string | Uint8Array\n  ): Promise<CacheSortedSetRemoveElement.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateSortedSetName(sortedSetName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheSortedSetRemoveElement.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendSortedSetRemoveElement(\n        cacheName,\n        this.convert(sortedSetName),\n        this.convert(value)\n      );\n    });\n  }\n\n  private async sendSortedSetRemoveElement(\n    cacheName: string,\n    sortedSetName: Uint8Array,\n    value: Uint8Array\n  ): Promise<CacheSortedSetRemoveElement.Response> {\n    const request = new grpcCache._SortedSetRemoveRequest({\n      set_name: sortedSetName,\n      some: new grpcCache._SortedSetRemoveRequest._Some({\n        values: [value],\n      }),\n    });\n\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().SortedSetRemove(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        err => {\n          if (err) {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e =>\n                new CacheSortedSetRemoveElement.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          } else {\n            resolve(new CacheSortedSetRemoveElement.Success());\n          }\n        }\n      );\n    });\n  }\n\n  public async sortedSetRemoveElements(\n    cacheName: string,\n    sortedSetName: string,\n    values: string[] | Uint8Array[]\n  ): Promise<CacheSortedSetRemoveElements.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateSortedSetName(sortedSetName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheSortedSetRemoveElements.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendSortedSetRemoveElements(\n        cacheName,\n        this.convert(sortedSetName),\n        this.convertArray(values)\n      );\n    });\n  }\n\n  private async sendSortedSetRemoveElements(\n    cacheName: string,\n    sortedSetName: Uint8Array,\n    values: Uint8Array[]\n  ): Promise<CacheSortedSetRemoveElements.Response> {\n    const request = new grpcCache._SortedSetRemoveRequest({\n      set_name: sortedSetName,\n      some: new grpcCache._SortedSetRemoveRequest._Some({\n        values: values,\n      }),\n    });\n\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().SortedSetRemove(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        err => {\n          if (err) {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e =>\n                new CacheSortedSetRemoveElements.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          } else {\n            resolve(new CacheSortedSetRemoveElements.Success());\n          }\n        }\n      );\n    });\n  }\n\n  public async sortedSetLength(\n    cacheName: string,\n    sortedSetName: string\n  ): Promise<CacheSortedSetLength.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateSortedSetName(sortedSetName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheSortedSetLength.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendSortedSetLength(\n        cacheName,\n        this.convert(sortedSetName)\n      );\n    });\n  }\n\n  private async sendSortedSetLength(\n    cacheName: string,\n    sortedSetName: Uint8Array\n  ): Promise<CacheSortedSetLength.Response> {\n    const request = new grpcCache._SortedSetLengthRequest({\n      set_name: sortedSetName,\n    });\n\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().SortedSetLength(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp?.missing) {\n            resolve(new CacheSortedSetLength.Miss());\n          } else if (resp?.found) {\n            if (!resp.found.length) {\n              resolve(new CacheSortedSetLength.Miss());\n            } else {\n              resolve(new CacheSortedSetLength.Hit(resp.found.length));\n            }\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheSortedSetLength.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async sortedSetLengthByScore(\n    cacheName: string,\n    sortedSetName: string,\n    minScore?: number,\n    maxScore?: number\n  ): Promise<CacheSortedSetLengthByScore.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateSortedSetName(sortedSetName);\n      validateSortedSetScores(minScore, maxScore);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheSortedSetLengthByScore.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendSortedSetLengthByScore(\n        cacheName,\n        this.convert(sortedSetName),\n        minScore,\n        maxScore\n      );\n    });\n  }\n\n  private async sendSortedSetLengthByScore(\n    cacheName: string,\n    sortedSetName: Uint8Array,\n    minScore?: number,\n    maxScore?: number\n  ): Promise<CacheSortedSetLengthByScore.Response> {\n    const request = new grpcCache._SortedSetLengthByScoreRequest({\n      set_name: sortedSetName,\n    });\n\n    if (minScore === undefined) {\n      request.unbounded_min = new _Unbounded();\n    } else {\n      request.inclusive_min = minScore;\n    }\n\n    if (maxScore === undefined) {\n      request.unbounded_max = new _Unbounded();\n    } else {\n      request.inclusive_max = maxScore;\n    }\n\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().SortedSetLengthByScore(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp?.missing) {\n            resolve(new CacheSortedSetLengthByScore.Miss());\n          } else if (resp?.found) {\n            if (!resp.found.length) {\n              resolve(new CacheSortedSetLengthByScore.Miss());\n            } else {\n              resolve(new CacheSortedSetLengthByScore.Hit(resp.found.length));\n            }\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e =>\n                new CacheSortedSetLengthByScore.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  private initializeInterceptors(\n    headers: Header[],\n    loggerFactory: MomentoLoggerFactory,\n    middlewares: Middleware[],\n    middlewareRequestContext: MiddlewareRequestHandlerContext\n  ): Interceptor[] {\n    return [\n      middlewaresInterceptor(\n        loggerFactory,\n        middlewares,\n        middlewareRequestContext,\n        this.clientWrapper.getClient()\n      ),\n      HeaderInterceptor.createHeadersInterceptor(headers),\n      RetryInterceptor.createRetryInterceptor({\n        clientName: 'CacheDataClient',\n        loggerFactory: this.configuration.getLoggerFactory(),\n        retryStrategy: this.configuration.getRetryStrategy(),\n        overallRequestTimeoutMs: this.requestTimeoutMs,\n      }),\n    ];\n  }\n\n  // TODO https://github.com/momentohq/client-sdk-nodejs/issues/349\n  // decide on streaming interceptors and middlewares\n  private initializeStreamingInterceptors(headers: Header[]): Interceptor[] {\n    return [HeaderInterceptor.createHeadersInterceptor(headers)];\n  }\n\n  private convert(v: string | Uint8Array): Uint8Array {\n    if (typeof v === 'string') {\n      return this.textEncoder.encode(v);\n    }\n    return v;\n  }\n\n  private convertArray(v: string[] | Uint8Array[]): Uint8Array[] {\n    return v.map(i => this.convert(i));\n  }\n\n  private convertElements(\n    elements:\n      | Map<string | Uint8Array, string | Uint8Array>\n      | Record<string, string | Uint8Array>\n      | Array<[string, string | Uint8Array]>\n  ): grpcCache._DictionaryFieldValuePair[] {\n    if (elements instanceof Array) {\n      return this.convertElements(new Map(elements));\n    } else if (elements instanceof Map) {\n      return [...elements.entries()].map(\n        element =>\n          new grpcCache._DictionaryFieldValuePair({\n            field: this.convert(element[0]),\n            value: this.convert(element[1]),\n          })\n      );\n    } else {\n      return Object.entries(elements).map(\n        element =>\n          new grpcCache._DictionaryFieldValuePair({\n            field: this.convert(element[0]),\n            value: this.convert(element[1]),\n          })\n      );\n    }\n  }\n\n  private convertSortedSetMapOrRecord(\n    elements:\n      | Map<string | Uint8Array, number>\n      | Record<string, number>\n      | Array<[string, number]>\n  ): grpcCache._SortedSetElement[] {\n    if (elements instanceof Array) {\n      return this.convertSortedSetMapOrRecord(new Map(elements));\n    } else if (elements instanceof Map) {\n      return [...elements.entries()].map(\n        element =>\n          new grpcCache._SortedSetElement({\n            value: this.convert(element[0]),\n            score: element[1],\n          })\n      );\n    } else {\n      return Object.entries(elements).map(\n        element =>\n          new grpcCache._SortedSetElement({\n            value: this.convert(element[0]),\n            score: element[1],\n          })\n      );\n    }\n  }\n\n  private convertSetBatchElements(\n    elements:\n      | Map<string | Uint8Array, string | Uint8Array>\n      | Record<string, string | Uint8Array>\n      | Array<SetBatchItem>,\n    ttl: number\n  ): [Uint8Array, Uint8Array, number][] {\n    if (elements instanceof Array) {\n      return elements.map(element => [\n        this.convert(element.key),\n        this.convert(element.value),\n        element.ttl ?? ttl,\n      ]);\n    } else if (elements instanceof Map) {\n      return [...elements.entries()].map(([k, v]) => [\n        this.convert(k),\n        this.convert(v),\n        ttl,\n      ]);\n    } else {\n      return Object.entries(elements).map(element => [\n        this.convert(element[0]),\n        this.convert(element[1]),\n        ttl,\n      ]);\n    }\n  }\n\n  public async itemGetType(\n    cacheName: string,\n    key: string | Uint8Array\n  ): Promise<CacheItemGetType.Response> {\n    try {\n      validateCacheName(cacheName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheItemGetType.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendItemGetType(cacheName, this.convert(key));\n    });\n  }\n\n  private async sendItemGetType(\n    cacheName: string,\n    key: Uint8Array\n  ): Promise<CacheItemGetType.Response> {\n    const request = new grpcCache._ItemGetTypeRequest({\n      cache_key: key,\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().ItemGetType(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp?.missing) {\n            resolve(new CacheItemGetType.Miss());\n          } else if (resp?.found) {\n            resolve(\n              new CacheItemGetType.Hit(\n                this.convertItemTypeResult(resp.found.item_type)\n              )\n            );\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheItemGetType.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async itemGetTtl(\n    cacheName: string,\n    key: string | Uint8Array\n  ): Promise<CacheItemGetTtl.Response> {\n    try {\n      validateCacheName(cacheName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheItemGetTtl.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendItemGetTtl(cacheName, this.convert(key));\n    });\n  }\n\n  private async sendItemGetTtl(\n    cacheName: string,\n    key: Uint8Array\n  ): Promise<CacheItemGetTtl.Response> {\n    const request = new grpcCache._ItemGetTtlRequest({\n      cache_key: key,\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().ItemGetTtl(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp?.missing) {\n            resolve(new CacheItemGetTtl.Miss());\n          } else if (resp?.found) {\n            resolve(new CacheItemGetTtl.Hit(resp.found.remaining_ttl_millis));\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheItemGetTtl.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async keyExists(\n    cacheName: string,\n    key: string | Uint8Array\n  ): Promise<CacheKeyExists.Response> {\n    try {\n      validateCacheName(cacheName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheKeyExists.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendKeyExists(cacheName, this.convert(key));\n    });\n  }\n\n  private async sendKeyExists(\n    cacheName: string,\n    key: Uint8Array\n  ): Promise<CacheKeyExists.Response> {\n    const request = new grpcCache._KeysExistRequest({\n      cache_keys: [key],\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().KeysExist(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp) {\n            resolve(new CacheKeyExists.Success(resp.exists));\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheKeyExists.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async updateTtl(\n    cacheName: string,\n    key: string | Uint8Array,\n    ttlMilliseconds: number\n  ): Promise<CacheUpdateTtl.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateValidForSeconds(ttlMilliseconds);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheUpdateTtl.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendUpdateTtl(\n        cacheName,\n        this.convert(key),\n        ttlMilliseconds\n      );\n    });\n  }\n\n  private async sendUpdateTtl(\n    cacheName: string,\n    key: Uint8Array,\n    ttlMilliseconds: number\n  ): Promise<CacheUpdateTtl.Response> {\n    const request = new grpcCache._UpdateTtlRequest({\n      cache_key: key,\n      overwrite_to_milliseconds: ttlMilliseconds,\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().UpdateTtl(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp?.missing) {\n            resolve(new CacheUpdateTtl.Miss());\n          } else if (resp?.set) {\n            resolve(new CacheUpdateTtl.Set());\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheUpdateTtl.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async keysExist(\n    cacheName: string,\n    keys: string[] | Uint8Array[]\n  ): Promise<CacheKeysExist.Response> {\n    try {\n      validateCacheName(cacheName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheKeysExist.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendKeysExist(cacheName, this.convertArray(keys));\n    });\n  }\n\n  private async sendKeysExist(\n    cacheName: string,\n    keys: Uint8Array[]\n  ): Promise<CacheKeysExist.Response> {\n    const request = new grpcCache._KeysExistRequest({\n      cache_keys: keys,\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().KeysExist(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp) {\n            resolve(new CacheKeysExist.Success(keys, resp.exists));\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheKeysExist.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async increaseTtl(\n    cacheName: string,\n    key: string | Uint8Array,\n    ttlMilliseconds: number\n  ): Promise<CacheIncreaseTtl.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateValidForSeconds(ttlMilliseconds);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheIncreaseTtl.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendIncreaseTtl(\n        cacheName,\n        this.convert(key),\n        ttlMilliseconds\n      );\n    });\n  }\n\n  private async sendIncreaseTtl(\n    cacheName: string,\n    key: Uint8Array,\n    ttlMilliseconds: number\n  ): Promise<CacheIncreaseTtl.Response> {\n    const request = new grpcCache._UpdateTtlRequest({\n      cache_key: key,\n      increase_to_milliseconds: ttlMilliseconds,\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().UpdateTtl(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp?.missing) {\n            resolve(new CacheIncreaseTtl.Miss());\n          } else if (resp?.set) {\n            resolve(new CacheIncreaseTtl.Set());\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheIncreaseTtl.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async decreaseTtl(\n    cacheName: string,\n    key: string | Uint8Array,\n    ttlMilliseconds: number\n  ): Promise<CacheDecreaseTtl.Response> {\n    try {\n      validateCacheName(cacheName);\n      validateValidForSeconds(ttlMilliseconds);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CacheDecreaseTtl.Error(err)\n      );\n    }\n\n    return await this.rateLimited(async () => {\n      return await this.sendDecreaseTtl(\n        cacheName,\n        this.convert(key),\n        ttlMilliseconds\n      );\n    });\n  }\n\n  private async sendDecreaseTtl(\n    cacheName: string,\n    key: Uint8Array,\n    ttlMilliseconds: number\n  ): Promise<CacheDecreaseTtl.Response> {\n    const request = new grpcCache._UpdateTtlRequest({\n      cache_key: key,\n      decrease_to_milliseconds: ttlMilliseconds,\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.clientWrapper.getClient().UpdateTtl(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err, resp) => {\n          if (resp?.missing) {\n            resolve(new CacheDecreaseTtl.Miss());\n          } else if (resp?.set) {\n            resolve(new CacheDecreaseTtl.Set());\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new CacheDecreaseTtl.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  private createMetadata(cacheName: string): Metadata {\n    const metadata = new Metadata();\n    metadata.set('cache', cacheName);\n    return metadata;\n  }\n\n  private toSingletonFieldValuePair(\n    field: Uint8Array,\n    value: Uint8Array\n  ): grpcCache._DictionaryFieldValuePair[] {\n    return [\n      new grpcCache._DictionaryFieldValuePair({\n        field: field,\n        value: value,\n      }),\n    ];\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3281, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3285, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk/src/internal/pubsub-client.ts"],"sourcesContent":["import {pubsub} from '@gomomento/generated-types';\nimport grpcPubsub = pubsub.cache_client.pubsub;\n// older versions of node don't have the global util variables https://github.com/nodejs/node/issues/20365\nimport {Header, HeaderInterceptor} from './grpc/headers-interceptor';\nimport {CacheServiceErrorMapper} from '../errors/cache-service-error-mapper';\nimport {ChannelCredentials, Interceptor, ServiceError} from '@grpc/grpc-js';\nimport {version} from '../../package.json';\nimport {middlewaresInterceptor} from './grpc/middlewares-interceptor';\nimport {\n  CredentialProvider,\n  StaticGrpcConfiguration,\n  TopicDiscontinuity,\n  TopicHeartbeat,\n  TopicGrpcConfiguration,\n  TopicItem,\n  TopicPublish,\n  TopicSubscribe,\n  UnknownError,\n} from '../';\nimport {truncateString} from '@gomomento/sdk-core/dist/src/internal/utils';\nimport {\n  AbstractPubsubClient,\n  SendSubscribeOptions,\n  PrepareSubscribeCallbackOptions,\n} from '@gomomento/sdk-core/dist/src/internal/clients/pubsub/AbstractPubsubClient';\nimport {TopicConfiguration} from '../config/topic-configuration';\nimport {TopicClientAllProps} from './topic-client-all-props';\nimport {grpcChannelOptionsFromGrpcConfig} from './grpc/grpc-channel-options';\nimport {RetryInterceptor} from './grpc/retry-interceptor';\n\nexport class PubsubClient extends AbstractPubsubClient<ServiceError> {\n  private readonly client: grpcPubsub.PubsubClient;\n  protected readonly credentialProvider: CredentialProvider;\n  private readonly unaryRequestTimeoutMs: number;\n  private static readonly DEFAULT_REQUEST_TIMEOUT_MS: number = 5 * 1000;\n  private static readonly DEFAULT_MAX_SESSION_MEMORY_MB: number = 256;\n  private readonly unaryInterceptors: Interceptor[];\n  private readonly streamingInterceptors: Interceptor[];\n\n  // private static readonly RST_STREAM_NO_ERROR_MESSAGE =\n  //   'Received RST_STREAM with code 0';\n\n  /**\n   * @param {TopicClientProps} props\n   */\n  constructor(props: TopicClientAllProps) {\n    super(\n      props.configuration.getLoggerFactory(),\n      props.configuration.getLoggerFactory().getLogger(PubsubClient.name),\n      new CacheServiceErrorMapper(props.configuration.getThrowOnErrors())\n    );\n    this.credentialProvider = props.credentialProvider;\n    this.unaryRequestTimeoutMs = PubsubClient.DEFAULT_REQUEST_TIMEOUT_MS;\n    this.getLogger().debug(\n      `Creating topic client using endpoint: '${this.credentialProvider.getCacheEndpoint()}'`\n    );\n\n    const topicGrpcConfig: TopicGrpcConfiguration = props.configuration\n      .getTransportStrategy()\n      .getGrpcConfig();\n\n    // NOTE: This is hard-coded for now but we may want to expose it via TopicConfiguration in the\n    // future, as we do with some of the other clients.\n    const grpcConfig = new StaticGrpcConfiguration({\n      deadlineMillis: this.unaryRequestTimeoutMs,\n      maxSessionMemoryMb: PubsubClient.DEFAULT_MAX_SESSION_MEMORY_MB,\n      keepAlivePermitWithoutCalls:\n        topicGrpcConfig.getKeepAlivePermitWithoutCalls(),\n      keepAliveTimeMs: topicGrpcConfig.getKeepAliveTimeMS(),\n      keepAliveTimeoutMs: topicGrpcConfig.getKeepAliveTimeoutMS(),\n    });\n\n    const channelOptions = grpcChannelOptionsFromGrpcConfig(grpcConfig);\n\n    this.getLogger().debug(\n      `Creating pubsub client with channel options: ${JSON.stringify(\n        channelOptions,\n        null,\n        2\n      )}`\n    );\n\n    this.client = new grpcPubsub.PubsubClient(\n      this.credentialProvider.getCacheEndpoint(),\n      this.credentialProvider.isCacheEndpointSecure()\n        ? ChannelCredentials.createSsl()\n        : ChannelCredentials.createInsecure(),\n      channelOptions\n    );\n\n    const headers: Header[] = [\n      new Header('Authorization', this.credentialProvider.getAuthToken()),\n      new Header('agent', `nodejs:topic:${version}`),\n      new Header('runtime-version', `nodejs:${process.versions.node}`),\n    ];\n    this.unaryInterceptors = PubsubClient.initializeUnaryInterceptors(\n      headers,\n      props.configuration,\n      this.unaryRequestTimeoutMs\n    );\n    this.streamingInterceptors =\n      PubsubClient.initializeStreamingInterceptors(headers);\n  }\n\n  public getEndpoint(): string {\n    const endpoint = this.credentialProvider.getCacheEndpoint();\n    this.getLogger().debug(`Using cache endpoint: ${endpoint}`);\n    return endpoint;\n  }\n\n  protected async sendPublish(\n    cacheName: string,\n    topicName: string,\n    value: string | Uint8Array\n  ): Promise<TopicPublish.Response> {\n    const topicValue = new grpcPubsub._TopicValue();\n    if (typeof value === 'string') {\n      topicValue.text = value;\n    } else {\n      topicValue.binary = value;\n    }\n\n    const request = new grpcPubsub._PublishRequest({\n      cache_name: cacheName,\n      topic: topicName,\n      value: topicValue,\n    });\n\n    return await new Promise((resolve, reject) => {\n      this.client.Publish(\n        request,\n        {\n          interceptors: this.unaryInterceptors,\n        },\n        (err, resp) => {\n          if (resp) {\n            resolve(new TopicPublish.Success());\n          } else {\n            this.getCacheServiceErrorMapper().resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new TopicPublish.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  /**\n   * @remark This method is responsible for restarting the stream if it ends unexpectedly.\n   * Since we return a single subscription object to the user, we need to update it with the\n   * unsubscribe function should we restart the stream. This is why we pass the subscription\n   * state and subscription object to this method.\n   *\n   * Handling a cache not exists requires special care as well. In the most likely case,\n   * when the subscription starts and the cache does not exist, we receive an error immediately.\n   * We return an error from the subscribe method and do immediately unsubscribe. In a distinct,\n   * unlikely but possible case, the user deletes the cache while the stream is running. In this\n   * case we already returned a subscription object to the user, so we instead cancel the stream and\n   * propagate an error to the user via the error handler.\n   */\n  protected override sendSubscribe(\n    options: SendSubscribeOptions\n  ): Promise<TopicSubscribe.Response> {\n    const request = new grpcPubsub._SubscriptionRequest({\n      cache_name: options.cacheName,\n      topic: options.topicName,\n      resume_at_topic_sequence_number:\n        options.subscriptionState.resumeAtTopicSequenceNumber,\n    });\n\n    this.getLogger().trace(\n      'Subscribing to topic with resume_at_topic_sequence_number: %s',\n      options.subscriptionState.resumeAtTopicSequenceNumber\n    );\n    const call = this.client.Subscribe(request, {\n      interceptors: this.streamingInterceptors,\n    });\n    options.subscriptionState.setSubscribed();\n\n    // Allow the caller to cancel the stream.\n    // Note that because we restart the stream on error or stream end,\n    // we need to ensure we keep the same subscription object. That way\n    // stream restarts are transparent to the caller.\n    options.subscriptionState.unsubscribeFn = () => {\n      call.cancel();\n    };\n\n    return new Promise((resolve, _reject) => {\n      const prepareCallbackOptions: PrepareSubscribeCallbackOptions = {\n        ...options,\n        resolve,\n      };\n      call.on('data', this.prepareDataCallback(prepareCallbackOptions));\n      call.on('error', this.prepareErrorCallback(prepareCallbackOptions));\n      call.on('end', this.prepareEndCallback(prepareCallbackOptions));\n    });\n  }\n\n  private prepareDataCallback(\n    options: PrepareSubscribeCallbackOptions\n  ): (resp: grpcPubsub._SubscriptionItem) => void {\n    return (resp: grpcPubsub._SubscriptionItem) => {\n      if (options.firstMessage) {\n        options.resolve(options.subscription);\n      }\n      options.firstMessage = false;\n\n      if (resp.item) {\n        const sequenceNumber = resp.item.topic_sequence_number;\n        options.subscriptionState.lastTopicSequenceNumber = sequenceNumber;\n        this.getLogger().trace(\n          'Received an item on subscription stream; topic: %s; sequence number: %s',\n          truncateString(options.topicName),\n          sequenceNumber\n        );\n        if (resp.item.value.text) {\n          options.onItem(\n            new TopicItem(resp.item.value.text, sequenceNumber, {\n              tokenId: resp.item.publisher_id,\n            })\n          );\n        } else if (resp.item.value.binary) {\n          options.onItem(\n            new TopicItem(resp.item.value.binary, sequenceNumber, {\n              tokenId: resp.item.publisher_id,\n            })\n          );\n        } else {\n          this.getLogger().error(\n            'Received subscription item with unknown type; topic: %s',\n            truncateString(options.topicName)\n          );\n          options.onError(\n            new TopicSubscribe.Error(\n              new UnknownError('Unknown item value type')\n            ),\n            options.subscription\n          );\n        }\n      } else if (resp.heartbeat) {\n        this.getLogger().trace(\n          'Received heartbeat from subscription stream; topic: %s',\n          truncateString(options.topicName)\n        );\n        options.onHeartbeat(new TopicHeartbeat());\n      } else if (resp.discontinuity) {\n        this.getLogger().trace(\n          'Received discontinuity from subscription stream; topic: %s',\n          truncateString(options.topicName)\n        );\n        options.onDiscontinuity(\n          new TopicDiscontinuity(\n            resp.discontinuity.last_topic_sequence,\n            resp.discontinuity.new_topic_sequence\n          )\n        );\n      } else {\n        this.getLogger().error(\n          'Received unknown subscription item; topic: %s',\n          truncateString(options.topicName)\n        );\n        options.onError(\n          new TopicSubscribe.Error(new UnknownError('Unknown item type')),\n          options.subscription\n        );\n      }\n    };\n  }\n\n  private prepareErrorCallback(\n    options: PrepareSubscribeCallbackOptions\n  ): (err: Error) => void {\n    return (err: Error) => {\n      // When the caller unsubscribes, we may get a follow on error, which we ignore.\n      if (!options.subscriptionState.isSubscribed) {\n        return;\n      }\n\n      const serviceError = err as unknown as ServiceError;\n      this.getLogger().trace(\n        `Subscription encountered an error: ${serviceError.code}: ${serviceError.message}: ${serviceError.details}`\n      );\n      const shouldReconnectSubscription =\n        // previously, we were only attempting a reconnect on this one very specific case, but our current expectation is that\n        // we should err on the side of retrying. This may become a sort of \"deny list\" of error types to *not* retry on\n        // in the future, but for now we will be aggressive about retrying.\n        // // serviceError.code === Status.INTERNAL &&\n        //  // serviceError.details === PubsubClient.RST_STREAM_NO_ERROR_MESSAGE;\n        true;\n      const momentoError = new TopicSubscribe.Error(\n        this.getCacheServiceErrorMapper().convertError(serviceError)\n      );\n      this.handleSubscribeError(\n        options,\n        momentoError,\n        shouldReconnectSubscription\n      );\n    };\n  }\n\n  private static initializeUnaryInterceptors(\n    headers: Header[],\n    configuration: TopicConfiguration,\n    requestTimeoutMs: number\n  ): Interceptor[] {\n    return [\n      middlewaresInterceptor(configuration.getLoggerFactory(), [], {}),\n      HeaderInterceptor.createHeadersInterceptor(headers),\n      RetryInterceptor.createRetryInterceptor({\n        clientName: 'PubSubClient',\n        loggerFactory: configuration.getLoggerFactory(),\n        overallRequestTimeoutMs: requestTimeoutMs,\n      }),\n    ];\n  }\n\n  // TODO https://github.com/momentohq/client-sdk-nodejs/issues/349\n  // decide on streaming interceptors and middlewares\n  private static initializeStreamingInterceptors(\n    headers: Header[]\n  ): Interceptor[] {\n    return [HeaderInterceptor.createHeadersInterceptor(headers)];\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3482, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3486, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk/src/internal/webhook-client.ts"],"sourcesContent":["import {webhook} from '@gomomento/generated-types';\nimport grpcWebhook = webhook.webhook;\nimport {\n  CredentialProvider,\n  MomentoLogger,\n  Webhook,\n  WebhookId,\n  DeleteWebhook,\n  PutWebhook,\n  ListWebhooks,\n  PostUrlWebhookDestination,\n  GetWebhookSecret,\n  RotateWebhookSecret,\n} from '@gomomento/sdk-core';\nimport {ChannelCredentials, Interceptor} from '@grpc/grpc-js';\nimport {IWebhookClient} from '@gomomento/sdk-core/dist/src/internal/clients/pubsub/IWebhookClient';\nimport {Header, HeaderInterceptor} from './grpc/headers-interceptor';\nimport {version} from '../../package.json';\nimport {CacheServiceErrorMapper} from '../errors/cache-service-error-mapper';\nimport {\n  validateCacheName,\n  validateTopicName,\n  validateWebhookName,\n} from '@gomomento/sdk-core/dist/src/internal/utils';\nimport {RetryInterceptor} from './grpc/retry-interceptor';\nimport {TopicClientAllProps} from './topic-client-all-props';\n\nexport class WebhookClient implements IWebhookClient {\n  private readonly webhookClient: grpcWebhook.WebhookClient;\n  protected readonly credentialProvider: CredentialProvider;\n  private readonly logger: MomentoLogger;\n  private readonly cacheServiceErrorMapper: CacheServiceErrorMapper;\n  private static readonly DEFAULT_REQUEST_TIMEOUT_MS: number = 5 * 1000;\n  private readonly unaryInterceptors: Interceptor[];\n\n  /**\n   * @param {TopicClientProps} props\n   */\n  constructor(props: TopicClientAllProps) {\n    this.credentialProvider = props.credentialProvider;\n    this.logger = props.configuration.getLoggerFactory().getLogger(this);\n    this.cacheServiceErrorMapper = new CacheServiceErrorMapper(\n      props.configuration.getThrowOnErrors()\n    );\n    const headers = [\n      new Header('Authorization', props.credentialProvider.getAuthToken()),\n      new Header('agent', `nodejs:webhook:${version}`),\n      new Header('runtime-version', `nodejs:${process.versions.node}`),\n    ];\n    this.unaryInterceptors = [\n      HeaderInterceptor.createHeadersInterceptor(headers),\n      RetryInterceptor.createRetryInterceptor({\n        clientName: 'WebhookClient',\n        loggerFactory: props.configuration.getLoggerFactory(),\n        overallRequestTimeoutMs: WebhookClient.DEFAULT_REQUEST_TIMEOUT_MS,\n      }),\n    ];\n    this.webhookClient = new webhook.webhook.WebhookClient(\n      props.credentialProvider.getControlEndpoint(),\n      props.credentialProvider.isControlEndpointSecure()\n        ? ChannelCredentials.createSsl()\n        : ChannelCredentials.createInsecure()\n    );\n  }\n\n  async deleteWebhook(id: WebhookId): Promise<DeleteWebhook.Response> {\n    try {\n      validateCacheName(id.cacheName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new DeleteWebhook.Error(err)\n      );\n    }\n    const request = new grpcWebhook._DeleteWebhookRequest({\n      webhook_id: new grpcWebhook._WebhookId({\n        cache_name: id.cacheName,\n        webhook_name: id.webhookName,\n      }),\n    });\n    this.logger.debug('issuing \"DeleteWebhook\" request');\n\n    return await new Promise<DeleteWebhook.Response>((resolve, reject) => {\n      this.webhookClient.DeleteWebhook(\n        request,\n        {interceptors: this.unaryInterceptors},\n        (err, _resp) => {\n          if (err) {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new DeleteWebhook.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          } else {\n            resolve(new DeleteWebhook.Success());\n          }\n        }\n      );\n    });\n  }\n\n  async listWebhooks(cache: string): Promise<ListWebhooks.Response> {\n    try {\n      validateCacheName(cache);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new ListWebhooks.Error(err)\n      );\n    }\n    const request = new grpcWebhook._ListWebhookRequest({cache_name: cache});\n    this.logger.debug('issuing \"ListWebhooks\" request');\n\n    return await new Promise<ListWebhooks.Response>((resolve, reject) => {\n      this.webhookClient.ListWebhooks(\n        request,\n        {interceptors: this.unaryInterceptors},\n        (err, resp) => {\n          if (err || !resp) {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new ListWebhooks.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          } else {\n            const webhooks = resp.webhook.map(wh => {\n              const webhook: Webhook = {\n                id: {\n                  cacheName: wh.webhook_id.cache_name,\n                  webhookName: wh.webhook_id.webhook_name,\n                },\n                topicName: wh.topic_name,\n                destination: new PostUrlWebhookDestination(\n                  wh.destination.post_url\n                ),\n              };\n              return webhook;\n            });\n            resolve(new ListWebhooks.Success(webhooks));\n          }\n        }\n      );\n    });\n  }\n\n  async putWebhook(webhook: Webhook): Promise<PutWebhook.Response> {\n    try {\n      validateCacheName(webhook.id.cacheName);\n      validateTopicName(webhook.topicName);\n      validateWebhookName(webhook.id.webhookName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new PutWebhook.Error(err)\n      );\n    }\n\n    const request = new grpcWebhook._PutWebhookRequest({\n      webhook: new grpcWebhook._Webhook({\n        webhook_id: new grpcWebhook._WebhookId({\n          cache_name: webhook.id.cacheName,\n          webhook_name: webhook.id.webhookName,\n        }),\n        destination: new grpcWebhook._WebhookDestination({\n          post_url: webhook.destination.url(),\n        }),\n        topic_name: webhook.topicName,\n      }),\n    });\n    this.logger.debug('issuing \"PutWebhook\" request');\n\n    return await new Promise<PutWebhook.Response>((resolve, reject) => {\n      this.webhookClient.PutWebhook(\n        request,\n        {interceptors: this.unaryInterceptors},\n        (err, resp) => {\n          if (err || !resp) {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new PutWebhook.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          } else {\n            resolve(new PutWebhook.Success(resp.secret_string));\n          }\n        }\n      );\n    });\n  }\n\n  async getWebhookSecret(id: WebhookId): Promise<GetWebhookSecret.Response> {\n    try {\n      validateCacheName(id.cacheName);\n      validateWebhookName(id.webhookName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new GetWebhookSecret.Error(err)\n      );\n    }\n\n    const request = new grpcWebhook._GetWebhookSecretRequest({\n      webhook_name: id.webhookName,\n      cache_name: id.cacheName,\n    });\n    this.logger.debug('issuing \"GetWebhookSecret\" request');\n\n    return await new Promise<GetWebhookSecret.Response>((resolve, reject) => {\n      this.webhookClient.GetWebhookSecret(\n        request,\n        {interceptors: this.unaryInterceptors},\n        (err, resp) => {\n          if (err || !resp) {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new GetWebhookSecret.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          } else {\n            resolve(\n              new GetWebhookSecret.Success({\n                secret: resp.secret_string,\n                webhookName: resp.webhook_name,\n                cacheName: resp.cache_name,\n              })\n            );\n          }\n        }\n      );\n    });\n  }\n\n  async rotateWebhookSecret(\n    id: WebhookId\n  ): Promise<RotateWebhookSecret.Response> {\n    try {\n      validateCacheName(id.cacheName);\n      validateWebhookName(id.webhookName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new RotateWebhookSecret.Error(err)\n      );\n    }\n\n    const webhookId = grpcWebhook._WebhookId.fromObject({\n      webhook_name: id.webhookName,\n      cache_name: id.cacheName,\n    });\n    const request = new grpcWebhook._RotateWebhookSecretRequest({\n      webhook_id: webhookId,\n    });\n    this.logger.debug('issuing \"RotateWebhookSecret\" request');\n\n    return await new Promise<RotateWebhookSecret.Response>(\n      (resolve, reject) => {\n        this.webhookClient.RotateWebhookSecret(\n          request,\n          {interceptors: this.unaryInterceptors},\n          (err, resp) => {\n            if (err || !resp) {\n              this.cacheServiceErrorMapper.resolveOrRejectError({\n                err: err,\n                errorResponseFactoryFn: e => new RotateWebhookSecret.Error(e),\n                resolveFn: resolve,\n                rejectFn: reject,\n              });\n            } else {\n              resolve(\n                new RotateWebhookSecret.Success({\n                  secret: resp.secret_string,\n                  webhookName: id.webhookName,\n                  cacheName: id.cacheName,\n                })\n              );\n            }\n          }\n        );\n      }\n    );\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3700, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3704, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk/src/internal/storage-control-client.ts"],"sourcesContent":["import {control} from '@gomomento/generated-types';\nimport grpcControl = control.control_client;\nimport {Header, HeaderInterceptor} from './grpc/headers-interceptor';\nimport {CacheServiceErrorMapper} from '../errors/cache-service-error-mapper';\nimport {ChannelCredentials, Interceptor} from '@grpc/grpc-js';\nimport {MomentoLogger, StoreInfo, ListStores, MomentoErrorCode} from '..';\nimport {version} from '../../package.json';\nimport {validateStoreName} from '@gomomento/sdk-core/dist/src/internal/utils';\nimport {CreateStore, DeleteStore} from '@gomomento/sdk-core';\nimport {RetryInterceptor} from './grpc/retry-interceptor';\nimport {StorageClientAllProps} from './storage-client-all-props';\n\nexport class StorageControlClient {\n  private readonly clientWrapper: grpcControl.ScsControlClient;\n  private readonly interceptors: Interceptor[];\n  private static readonly REQUEST_TIMEOUT_MS: number = 60 * 1000;\n  private readonly logger: MomentoLogger;\n  private readonly cacheServiceErrorMapper: CacheServiceErrorMapper;\n\n  /**\n   * @param {StorageClientProps} props\n   */\n  constructor(props: StorageClientAllProps) {\n    this.logger = props.configuration.getLoggerFactory().getLogger(this);\n    this.cacheServiceErrorMapper = new CacheServiceErrorMapper(false);\n    const headers = [\n      new Header('Authorization', props.credentialProvider.getAuthToken()),\n      new Header('agent', `nodejs:store:${version}`),\n      new Header('runtime-version', `nodejs:${process.versions.node}`),\n    ];\n    this.interceptors = [\n      HeaderInterceptor.createHeadersInterceptor(headers),\n      RetryInterceptor.createRetryInterceptor({\n        clientName: 'StorageControlClient',\n        loggerFactory: props.configuration.getLoggerFactory(),\n        overallRequestTimeoutMs: StorageControlClient.REQUEST_TIMEOUT_MS,\n      }),\n    ];\n    this.logger.debug(\n      `Creating storage control client using endpoint: '${props.credentialProvider.getControlEndpoint()}`\n    );\n\n    this.clientWrapper = new grpcControl.ScsControlClient(\n      props.credentialProvider.getControlEndpoint(),\n      props.credentialProvider.isControlEndpointSecure()\n        ? ChannelCredentials.createSsl()\n        : ChannelCredentials.createInsecure()\n    );\n  }\n  close() {\n    this.logger.debug('Closing storage control client');\n    this.clientWrapper.close();\n  }\n\n  public async createStore(name: string): Promise<CreateStore.Response> {\n    try {\n      validateStoreName(name);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new CreateStore.Error(err)\n      );\n    }\n    this.logger.debug(`Creating store: ${name}`);\n    const request = new grpcControl._CreateStoreRequest({\n      store_name: name,\n    });\n    return await new Promise<CreateStore.Response>((resolve, reject) => {\n      this.clientWrapper.CreateStore(\n        request,\n        {interceptors: this.interceptors},\n        (err, _resp) => {\n          if (err) {\n            const sdkError = this.cacheServiceErrorMapper.convertError(err);\n            if (\n              sdkError.errorCode() ===\n              MomentoErrorCode.STORE_ALREADY_EXISTS_ERROR\n            ) {\n              resolve(new CreateStore.AlreadyExists());\n            } else {\n              this.cacheServiceErrorMapper.resolveOrRejectError({\n                err: err,\n                errorResponseFactoryFn: e => new CreateStore.Error(e),\n                resolveFn: resolve,\n                rejectFn: reject,\n              });\n            }\n          } else {\n            resolve(new CreateStore.Success());\n          }\n        }\n      );\n    });\n  }\n\n  public async deleteStore(name: string): Promise<DeleteStore.Response> {\n    try {\n      validateStoreName(name);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new DeleteStore.Error(err)\n      );\n    }\n    const request = new grpcControl._DeleteStoreRequest({\n      store_name: name,\n    });\n    this.logger.debug(`Deleting store: ${name}`);\n    return await new Promise<DeleteStore.Response>((resolve, reject) => {\n      this.clientWrapper.DeleteStore(\n        request,\n        {interceptors: this.interceptors},\n        (err, _resp) => {\n          if (err) {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new DeleteStore.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          } else {\n            resolve(new DeleteStore.Success());\n          }\n        }\n      );\n    });\n  }\n\n  public async listStores(): Promise<ListStores.Response> {\n    const request = new grpcControl._ListStoresRequest();\n    request.next_token = '';\n    this.logger.debug(\"Issuing 'listStores' request\");\n    return await new Promise<ListStores.Response>((resolve, reject) => {\n      this.clientWrapper.ListStores(\n        request,\n        {interceptors: this.interceptors},\n        (err, resp) => {\n          if (err || !resp) {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new ListStores.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          } else {\n            const stores = resp.store.map(store => {\n              const storeName = store.store_name;\n              return new StoreInfo(storeName);\n            });\n            resolve(new ListStores.Success(stores));\n          }\n        }\n      );\n    });\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3832, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3836, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk/src/internal/storage-data-client.ts"],"sourcesContent":["import {\n  CredentialProvider,\n  InvalidArgumentError,\n  MomentoErrorCode,\n  MomentoLogger,\n  MomentoLoggerFactory,\n  StorageDelete,\n  StorageGet,\n  StoragePut,\n  UnknownError,\n} from '@gomomento/sdk-core';\nimport {validateStoreName} from '@gomomento/sdk-core/dist/src/internal/utils';\nimport {store} from '@gomomento/generated-types/dist/store';\nimport {Header, HeaderInterceptor} from './grpc/headers-interceptor';\nimport {\n  ChannelCredentials,\n  Interceptor,\n  Metadata,\n  ServiceError,\n} from '@grpc/grpc-js';\nimport {version} from '../../package.json';\nimport {grpcChannelOptionsFromGrpcConfig} from './grpc/grpc-channel-options';\nimport {IStorageDataClient} from '@gomomento/sdk-core/dist/src/internal/clients';\nimport {StorageConfiguration} from '../config/storage-configuration';\nimport {StorageClientAllProps} from './storage-client-all-props';\nimport {StaticGrpcConfiguration} from '../config/transport/cache';\nimport {CacheServiceErrorMapper} from '../errors/cache-service-error-mapper';\nimport {RetryInterceptor} from './grpc/retry-interceptor';\n\nexport class StorageDataClient implements IStorageDataClient {\n  private readonly configuration: StorageConfiguration;\n  private readonly credentialProvider: CredentialProvider;\n  private readonly cacheServiceErrorMapper: CacheServiceErrorMapper;\n  private readonly logger: MomentoLogger;\n  private readonly requestTimeoutMs: number;\n  private readonly client: store.StoreClient;\n  private readonly interceptors: Interceptor[];\n  private static readonly DEFAULT_MAX_SESSION_MEMORY_MB: number = 256;\n\n  /**\n   * @param {StorageClientAllProps} props\n   */\n  constructor(props: StorageClientAllProps) {\n    this.configuration = props.configuration;\n    this.credentialProvider = props.credentialProvider;\n    this.cacheServiceErrorMapper = new CacheServiceErrorMapper(false);\n    this.logger = this.configuration.getLoggerFactory().getLogger(this);\n    this.requestTimeoutMs = this.configuration\n      .getTransportStrategy()\n      .getGrpcConfig()\n      .getDeadlineMillis();\n    this.validateRequestTimeout(this.requestTimeoutMs);\n    this.logger.debug(\n      `Creating storage client using endpoint: '${this.credentialProvider.getStorageEndpoint()}'`\n    );\n\n    // NOTE: This is hard-coded for now but we may want to expose it via StorageConfiguration in the\n    // future, as we do with some of the other clients.\n    const grpcConfig = new StaticGrpcConfiguration({\n      deadlineMillis: this.configuration\n        .getTransportStrategy()\n        .getGrpcConfig()\n        .getDeadlineMillis(),\n      maxSessionMemoryMb: StorageDataClient.DEFAULT_MAX_SESSION_MEMORY_MB,\n    });\n    const channelOptions = grpcChannelOptionsFromGrpcConfig(grpcConfig);\n\n    this.client = new store.StoreClient(\n      this.credentialProvider.getStorageEndpoint(),\n      this.credentialProvider.isStorageEndpointSecure()\n        ? ChannelCredentials.createSsl()\n        : ChannelCredentials.createInsecure(),\n      channelOptions\n    );\n    this.interceptors = this.initializeInterceptors(\n      this.configuration.getLoggerFactory()\n    );\n  }\n\n  close() {\n    this.logger.debug('Closing storage data clients');\n    this.client.close();\n  }\n\n  private validateRequestTimeout(timeout?: number) {\n    this.logger.debug(`Request timeout ms: ${String(timeout)}`);\n    if (timeout !== undefined && timeout <= 0) {\n      throw new InvalidArgumentError(\n        'request timeout must be greater than zero.'\n      );\n    }\n  }\n\n  private validateStoreNameOrThrowError(storeName: string) {\n    try {\n      validateStoreName(storeName);\n      return;\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new StoragePut.Error(err)\n      );\n    }\n  }\n\n  private initializeInterceptors(\n    _loggerFactory: MomentoLoggerFactory\n  ): Interceptor[] {\n    const headers = [\n      new Header('Authorization', this.credentialProvider.getAuthToken()),\n      new Header('agent', `nodejs:store:${version}`),\n      new Header('runtime-version', `nodejs:${process.versions.node}`),\n    ];\n    return [\n      HeaderInterceptor.createHeadersInterceptor(headers),\n      RetryInterceptor.createRetryInterceptor({\n        clientName: 'StorageDataClient',\n        loggerFactory: this.configuration.getLoggerFactory(),\n        retryStrategy: this.configuration.getRetryStrategy(),\n        overallRequestTimeoutMs: this.requestTimeoutMs,\n      }),\n    ];\n  }\n\n  private createMetadata(storeName: string): Metadata {\n    const metadata = new Metadata();\n    metadata.set('store', storeName);\n    return metadata;\n  }\n\n  public async get(\n    storeName: string,\n    key: string\n  ): Promise<StorageGet.Response> {\n    try {\n      validateStoreName(storeName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new StorageGet.Error(err)\n      );\n    }\n    this.logger.trace(\n      `Issuing 'get' request; store: ${storeName}, key: ${key}`\n    );\n    return await this.sendGet(storeName, key);\n  }\n\n  private async sendGet(\n    storeName: string,\n    key: string\n  ): Promise<StorageGet.Response> {\n    const request = new store._StoreGetRequest({\n      key: key,\n    });\n    const metadata = this.createMetadata(storeName);\n    return await new Promise((resolve, reject) => {\n      this.client.Get(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err: ServiceError | null, resp) => {\n          const value = resp?.value?.value;\n          if (value) {\n            switch (value) {\n              case 'double_value': {\n                return resolve(\n                  StorageGet.Found.ofDouble(resp.value.double_value)\n                );\n              }\n              case 'string_value': {\n                return resolve(\n                  StorageGet.Found.ofString(resp.value.string_value)\n                );\n              }\n              case 'bytes_value': {\n                return resolve(\n                  StorageGet.Found.ofBytes(resp.value.bytes_value)\n                );\n              }\n              case 'integer_value': {\n                return resolve(\n                  StorageGet.Found.ofInt(resp.value.integer_value)\n                );\n              }\n              case 'none': {\n                return resolve(\n                  new StorageGet.Error(\n                    new UnknownError(\n                      'StorageGet responded with an unknown result'\n                    )\n                  )\n                );\n              }\n            }\n          } else {\n            const sdkError = this.cacheServiceErrorMapper.convertError(err);\n            if (\n              sdkError.errorCode() ===\n              MomentoErrorCode.STORE_ITEM_NOT_FOUND_ERROR\n            ) {\n              return resolve(new StorageGet.NotFound());\n            }\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new StorageGet.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async putInt(\n    storeName: string,\n    key: string,\n    value: number\n  ): Promise<StoragePut.Response> {\n    this.validateStoreNameOrThrowError(storeName);\n    this.logger.trace(\n      `Issuing 'put' request; store: ${storeName}, key: ${key}`\n    );\n    const storeValue = new store._StoreValue({integer_value: value});\n    return await this.sendPut(storeName, key, storeValue);\n  }\n\n  public async putDouble(\n    storeName: string,\n    key: string,\n    value: number\n  ): Promise<StoragePut.Response> {\n    this.validateStoreNameOrThrowError(storeName);\n    this.logger.trace(\n      `Issuing 'put' request; store: ${storeName}, key: ${key}`\n    );\n    const storeValue = new store._StoreValue({double_value: value});\n    return await this.sendPut(storeName, key, storeValue);\n  }\n\n  public async putString(\n    storeName: string,\n    key: string,\n    value: string\n  ): Promise<StoragePut.Response> {\n    this.validateStoreNameOrThrowError(storeName);\n    this.logger.trace(\n      `Issuing 'put' request; store: ${storeName}, key: ${key}`\n    );\n    const storeValue = new store._StoreValue({string_value: value});\n    return await this.sendPut(storeName, key, storeValue);\n  }\n\n  public async putBytes(\n    storeName: string,\n    key: string,\n    value: Uint8Array\n  ): Promise<StoragePut.Response> {\n    this.validateStoreNameOrThrowError(storeName);\n    this.logger.trace(\n      `Issuing 'put' request; store: ${storeName}, key: ${key}`\n    );\n    const storeValue = new store._StoreValue({bytes_value: value});\n    return await this.sendPut(storeName, key, storeValue);\n  }\n\n  private async sendPut(\n    storeName: string,\n    key: string,\n    storeValue: store._StoreValue\n  ): Promise<StoragePut.Response> {\n    const request = new store._StorePutRequest({\n      key: key,\n      value: storeValue,\n    });\n    const metadata = this.createMetadata(storeName);\n    return await new Promise((resolve, reject) => {\n      this.client.Put(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err: ServiceError | null, resp) => {\n          if (resp) {\n            resolve(new StoragePut.Success());\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new StoragePut.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async delete(\n    storeName: string,\n    key: string\n  ): Promise<StorageDelete.Response> {\n    try {\n      validateStoreName(storeName);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new StorageDelete.Error(err)\n      );\n    }\n    this.logger.trace(\n      `Issuing 'delete' request; store: ${storeName}, key: ${key}`\n    );\n    return await this.sendDelete(storeName, key);\n  }\n\n  private async sendDelete(\n    storeName: string,\n    key: string\n  ): Promise<StorageDelete.Response> {\n    const request = new store._StoreDeleteRequest({\n      key: key,\n    });\n    const metadata = this.createMetadata(storeName);\n    return await new Promise((resolve, reject) => {\n      this.client.Delete(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err: ServiceError | null, resp) => {\n          if (resp) {\n            resolve(new StorageDelete.Success());\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new StorageDelete.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA;AAWA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AAMA,MAAA;AACA,MAAA;AAIA,MAAA;AACA,MAAA;AACA,MAAA;AAEA,MAAa;IAUX;;QAGA,YAAY,KAA4B,CAAA;QACtC,IAAI,CAAC,aAAa,GAAG,MAAM,aAAa;QACxC,IAAI,CAAC,kBAAkB,GAAG,MAAM,kBAAkB;QAClD,IAAI,CAAC,uBAAuB,GAAG,IAAI,6BAAA,uBAAuB,CAAC;QAC3D,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC,gBAAgB,GAAG,SAAS,CAAC,IAAI;QAClE,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,aAAa,CACvC,oBAAoB,GACpB,aAAa,GACb,iBAAiB;QACpB,IAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC,gBAAgB;QACjD,IAAI,CAAC,MAAM,CAAC,KAAK,CACf,CAAA,yCAAA,EAA4C,IAAI,CAAC,kBAAkB,CAAC,kBAAkB,GAAE,CAAA,CAAG;QAG7F,gGAAgG;QAChG,mDAAmD;QACnD,MAAM,aAAa,IAAI,QAAA,uBAAuB,CAAC;YAC7C,gBAAgB,IAAI,CAAC,aAAa,CAC/B,oBAAoB,GACpB,aAAa,GACb,iBAAiB;YACpB,oBAAoB,kBAAkB,6BAA6B;;QAErE,MAAM,iBAAiB,CAAA,GAAA,uBAAA,gCAAgC,EAAC;QAExD,IAAI,CAAC,MAAM,GAAG,IAAI,QAAA,KAAK,CAAC,WAAW,CACjC,IAAI,CAAC,kBAAkB,CAAC,kBAAkB,IAC1C,IAAI,CAAC,kBAAkB,CAAC,uBAAuB,KAC3C,UAAA,kBAAkB,CAAC,SAAS,KAC5B,UAAA,kBAAkB,CAAC,cAAc,IACrC;QAEF,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,sBAAsB,CAC7C,IAAI,CAAC,aAAa,CAAC,gBAAgB;IAEvC;IAEA,QAAK;QACH,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC;QAClB,IAAI,CAAC,MAAM,CAAC,KAAK;IACnB;IAEQ,uBAAuB,OAAgB,EAAA;QAC7C,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAA,oBAAA,EAAuB,OAAO,SAAQ,CAAE;QAC1D,IAAI,YAAY,aAAa,WAAW,GAAG;YACzC,MAAM,IAAI,WAAA,oBAAoB,CAC5B;;IAGN;IAEQ,8BAA8B,SAAiB,EAAA;QACrD,IAAI;YACF,CAAA,GAAA,QAAA,iBAAiB,EAAC;YAClB;UACA,OAAO,KAAK;YACZ,OAAO,IAAI,CAAC,uBAAuB,CAAC,kBAAkB,CACpD,KACA,CAAA,MAAO,IAAI,WAAA,UAAU,CAAC,KAAK,CAAC;;IAGlC;IAEQ,uBACN,cAAoC,EAAA;QAEpC,MAAM,UAAU;YACd,IAAI,sBAAA,MAAM,CAAC,iBAAiB,IAAI,CAAC,kBAAkB,CAAC,YAAY;YAChE,IAAI,sBAAA,MAAM,CAAC,SAAS,CAAA,aAAA,EAAgB,eAAA,OAAO,CAAA,CAAE;YAC7C,IAAI,sBAAA,MAAM,CAAC,mBAAmB,CAAA,OAAA,EAAU,QAAQ,QAAQ,CAAC,IAAI,CAAA,CAAE;SAChE;QACD,OAAO;YACL,sBAAA,iBAAiB,CAAC,wBAAwB,CAAC;YAC3C,oBAAA,gBAAgB,CAAC,sBAAsB,CAAC;gBACtC,YAAY;gBACZ,eAAe,IAAI,CAAC,aAAa,CAAC,gBAAgB;gBAClD,eAAe,IAAI,CAAC,aAAa,CAAC,gBAAgB;gBAClD,yBAAyB,IAAI,CAAC,gBAAgB;;SAEjD;IACH;IAEQ,eAAe,SAAiB,EAAA;QACtC,MAAM,WAAW,IAAI,UAAA,QAAQ;QAC7B,SAAS,GAAG,CAAC,SAAS;QACtB,OAAO;IACT;IAEO,MAAM,IACX,SAAiB,EACjB,GAAW,EAAA;QAEX,IAAI;YACF,CAAA,GAAA,QAAA,iBAAiB,EAAC;UAClB,OAAO,KAAK;YACZ,OAAO,IAAI,CAAC,uBAAuB,CAAC,kBAAkB,CACpD,KACA,CAAA,MAAO,IAAI,WAAA,UAAU,CAAC,KAAK,CAAC;;QAGhC,IAAI,CAAC,MAAM,CAAC,KAAK,CACf,CAAA,8BAAA,EAAiC,UAAS,OAAA,EAAU,IAAG,CAAE;QAE3D,OAAO,MAAM,IAAI,CAAC,OAAO,CAAC,WAAW;IACvC;IAEQ,MAAM,QACZ,SAAiB,EACjB,GAAW,EAAA;QAEX,MAAM,UAAU,IAAI,QAAA,KAAK,CAAC,gBAAgB,CAAC;YACzC,KAAK;;QAEP,MAAM,WAAW,IAAI,CAAC,cAAc,CAAC;QACrC,OAAO,MAAM,IAAI,QAAQ,CAAC,SAAS;YACjC,IAAI,CAAC,MAAM,CAAC,GAAG,CACb,SACA,UACA;gBACE,cAAc,IAAI,CAAC,YAAY;eAEjC,CAAC,KAA0B;;gBACzB,MAAM,QAAQ,CAAA,KAAA,SAAI,QAAJ,SAAI,KAAA,IAAA,KAAA,IAAJ,KAAM,KAAK,MAAA,QAAA,OAAA,KAAA,IAAA,KAAA,IAAA,GAAE,KAAK;gBAChC,IAAI,OAAO;oBACT,OAAQ;wBACN,KAAK;4BAAgB;gCACnB,OAAO,QACL,WAAA,UAAU,CAAC,KAAK,CAAC,QAAQ,CAAC,KAAK,KAAK,CAAC,YAAY;;wBAGrD,KAAK;4BAAgB;gCACnB,OAAO,QACL,WAAA,UAAU,CAAC,KAAK,CAAC,QAAQ,CAAC,KAAK,KAAK,CAAC,YAAY;;wBAGrD,KAAK;4BAAe;gCAClB,OAAO,QACL,WAAA,UAAU,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,KAAK,CAAC,WAAW;;wBAGnD,KAAK;4BAAiB;gCACpB,OAAO,QACL,WAAA,UAAU,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,KAAK,CAAC,aAAa;;wBAGnD,KAAK;4BAAQ;gCACX,OAAO,QACL,IAAI,WAAA,UAAU,CAAC,KAAK,CAClB,IAAI,WAAA,YAAY,CACd;;;uBAML;oBACL,MAAM,WAAW,IAAI,CAAC,uBAAuB,CAAC,YAAY,CAAC;oBAC3D,IACE,SAAS,SAAS,OAClB,WAAA,gBAAgB,CAAC,0BAA0B,EAC3C;wBACA,OAAO,QAAQ,IAAI,WAAA,UAAU,CAAC,QAAQ;;oBAExC,IAAI,CAAC,uBAAuB,CAAC,oBAAoB,CAAC;wBAChD,KAAK;wBACL,wBAAwB,CAAA,IAAK,IAAI,WAAA,UAAU,CAAC,KAAK,CAAC;wBAClD,WAAW;wBACX,UAAU;;;YAGhB;QAEJ;IACF;IAEO,MAAM,OACX,SAAiB,EACjB,GAAW,EACX,KAAa,EAAA;QAEb,IAAI,CAAC,6BAA6B,CAAC;QACnC,IAAI,CAAC,MAAM,CAAC,KAAK,CACf,CAAA,8BAAA,EAAiC,UAAS,OAAA,EAAU,IAAG,CAAE;QAE3D,MAAM,aAAa,IAAI,QAAA,KAAK,CAAC,WAAW,CAAC;YAAC,eAAe;QAAK;QAC9D,OAAO,MAAM,IAAI,CAAC,OAAO,CAAC,WAAW,KAAK;IAC5C;IAEO,MAAM,UACX,SAAiB,EACjB,GAAW,EACX,KAAa,EAAA;QAEb,IAAI,CAAC,6BAA6B,CAAC;QACnC,IAAI,CAAC,MAAM,CAAC,KAAK,CACf,CAAA,8BAAA,EAAiC,UAAS,OAAA,EAAU,IAAG,CAAE;QAE3D,MAAM,aAAa,IAAI,QAAA,KAAK,CAAC,WAAW,CAAC;YAAC,cAAc;QAAK;QAC7D,OAAO,MAAM,IAAI,CAAC,OAAO,CAAC,WAAW,KAAK;IAC5C;IAEO,MAAM,UACX,SAAiB,EACjB,GAAW,EACX,KAAa,EAAA;QAEb,IAAI,CAAC,6BAA6B,CAAC;QACnC,IAAI,CAAC,MAAM,CAAC,KAAK,CACf,CAAA,8BAAA,EAAiC,UAAS,OAAA,EAAU,IAAG,CAAE;QAE3D,MAAM,aAAa,IAAI,QAAA,KAAK,CAAC,WAAW,CAAC;YAAC,cAAc;QAAK;QAC7D,OAAO,MAAM,IAAI,CAAC,OAAO,CAAC,WAAW,KAAK;IAC5C;IAEO,MAAM,SACX,SAAiB,EACjB,GAAW,EACX,KAAiB,EAAA;QAEjB,IAAI,CAAC,6BAA6B,CAAC;QACnC,IAAI,CAAC,MAAM,CAAC,KAAK,CACf,CAAA,8BAAA,EAAiC,UAAS,OAAA,EAAU,IAAG,CAAE;QAE3D,MAAM,aAAa,IAAI,QAAA,KAAK,CAAC,WAAW,CAAC;YAAC,aAAa;QAAK;QAC5D,OAAO,MAAM,IAAI,CAAC,OAAO,CAAC,WAAW,KAAK;IAC5C;IAEQ,MAAM,QACZ,SAAiB,EACjB,GAAW,EACX,UAA6B,EAAA;QAE7B,MAAM,UAAU,IAAI,QAAA,KAAK,CAAC,gBAAgB,CAAC;YACzC,KAAK;YACL,OAAO;;QAET,MAAM,WAAW,IAAI,CAAC,cAAc,CAAC;QACrC,OAAO,MAAM,IAAI,QAAQ,CAAC,SAAS;YACjC,IAAI,CAAC,MAAM,CAAC,GAAG,CACb,SACA,UACA;gBACE,cAAc,IAAI,CAAC,YAAY;eAEjC,CAAC,KAA0B;gBACzB,IAAI,MAAM;oBACR,QAAQ,IAAI,WAAA,UAAU,CAAC,OAAO;uBACzB;oBACL,IAAI,CAAC,uBAAuB,CAAC,oBAAoB,CAAC;wBAChD,KAAK;wBACL,wBAAwB,CAAA,IAAK,IAAI,WAAA,UAAU,CAAC,KAAK,CAAC;wBAClD,WAAW;wBACX,UAAU;;;YAGhB;QAEJ;IACF;IAEO,MAAM,OACX,SAAiB,EACjB,GAAW,EAAA;QAEX,IAAI;YACF,CAAA,GAAA,QAAA,iBAAiB,EAAC;UAClB,OAAO,KAAK;YACZ,OAAO,IAAI,CAAC,uBAAuB,CAAC,kBAAkB,CACpD,KACA,CAAA,MAAO,IAAI,WAAA,aAAa,CAAC,KAAK,CAAC;;QAGnC,IAAI,CAAC,MAAM,CAAC,KAAK,CACf,CAAA,iCAAA,EAAoC,UAAS,OAAA,EAAU,IAAG,CAAE;QAE9D,OAAO,MAAM,IAAI,CAAC,UAAU,CAAC,WAAW;IAC1C;IAEQ,MAAM,WACZ,SAAiB,EACjB,GAAW,EAAA;QAEX,MAAM,UAAU,IAAI,QAAA,KAAK,CAAC,mBAAmB,CAAC;YAC5C,KAAK;;QAEP,MAAM,WAAW,IAAI,CAAC,cAAc,CAAC;QACrC,OAAO,MAAM,IAAI,QAAQ,CAAC,SAAS;YACjC,IAAI,CAAC,MAAM,CAAC,MAAM,CAChB,SACA,UACA;gBACE,cAAc,IAAI,CAAC,YAAY;eAEjC,CAAC,KAA0B;gBACzB,IAAI,MAAM;oBACR,QAAQ,IAAI,WAAA,aAAa,CAAC,OAAO;uBAC5B;oBACL,IAAI,CAAC,uBAAuB,CAAC,oBAAoB,CAAC;wBAChD,KAAK;wBACL,wBAAwB,CAAA,IAAK,IAAI,WAAA,aAAa,CAAC,KAAK,CAAC;wBACrD,WAAW;wBACX,UAAU;;;YAGhB;QAEJ;IACF;;AAhUF,QAAA,iBAAA,GAAA;AAQ0B,kBAAA,6BAA6B,GAAW"}},
    {"offset": {"line": 4058, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4062, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk/dist/src/internal/vendor/printf/printf.js"],"sourcesContent":["/* eslint-disable */\n\nvar util = require('util');\n\nvar tokenize = function(/*String*/ str, /*RegExp*/ re, /*Function?*/ parseDelim, /*Object?*/ instance){\n  // summary:\n  //    Split a string by a regular expression with the ability to capture the delimeters\n  // parseDelim:\n  //    Each group (excluding the 0 group) is passed as a parameter. If the function returns\n  //    a value, it's added to the list of tokens.\n  // instance:\n  //    Used as the \"this' instance when calling parseDelim\n  var tokens = [];\n  var match, content, lastIndex = 0;\n  while((match = re.exec(str))){\n    content = str.slice(lastIndex, re.lastIndex - match[0].length);\n    if(content.length){\n      tokens.push(content);\n    }\n    if(parseDelim){\n      var parsed = parseDelim.apply(instance, match.slice(1).concat(tokens.length));\n      if(typeof parsed != 'undefined'){\n        if(parsed.specifier === '%'){\n          tokens.push('%');\n        }else{\n          tokens.push(parsed);\n        }\n      }\n    }\n    lastIndex = re.lastIndex;\n  }\n  content = str.slice(lastIndex);\n  if(content.length){\n    tokens.push(content);\n  }\n  return tokens;\n};\n\nvar Formatter = function(/*String*/ format){\n  this._mapped = false;\n  this._format = format;\n  this._tokens = tokenize(format, this._re, this._parseDelim, this);\n};\n\n// The old regexp `/\\%(?:\\(([\\w_.]+)\\)|([1-9]\\d*)\\$)?([0 +\\-\\#]*)(\\*|\\d+)?(\\.)?(\\*|\\d+)?[hlL]?([\\%bscdeEfFgGioOuxX])/` has a cubic worst-case time complexity behavior due to overlapping capture groups `([0 +\\-\\#]*)(\\*|\\d+)?(\\.)?(\\*|\\d+)?`. And a pump string of 0 can be consumed by `([0 +\\-\\#]*), (\\*|\\d+)?, or (\\*|\\d+)?`.\n// The solution replace the sub-regexp (\\*|\\d+)?(\\.)?(\\*|\\d+)? with the sub-regexp `(\\*|\\d+)?(?:(\\.)(\\*|\\d+)?)?`, see the figure in [#32](https://github.com/adaltas/node-printf/pull/32)\n// There are also performance improvement, see in [#31](https://github.com/adaltas/node-printf/issues/31#issuecomment-776731490)\nFormatter.prototype._re = /\\%(?:\\(([\\w_.]+)\\)|([1-9]\\d*)\\$)?([0 +\\-\\#]*)(\\*|\\d+)?(?:(\\.)(\\*|\\d+)?)?[hlL]?([\\%bscdeEfFgGioOuxX])/g;\nFormatter.prototype._parseDelim = function(mapping, intmapping, flags, minWidth, period, precision, specifier){\n  if(mapping){\n    this._mapped = true;\n  }\n  return {\n    mapping: mapping,\n    intmapping: intmapping,\n    flags: flags,\n    _minWidth: minWidth, // May be dependent on parameters\n    period: period,\n    _precision: precision, // May be dependent on parameters\n    specifier: specifier\n  };\n};\nFormatter.prototype._specifiers = {\n  b: {\n    base: 2,\n    isInt: true\n  },\n  o: {\n    base: 8,\n    isInt: true\n  },\n  x: {\n    base: 16,\n    isInt: true\n  },\n  X: {\n    extend: ['x'],\n    toUpper: true\n  },\n  d: {\n    base: 10,\n    isInt: true\n  },\n  i: {\n    extend: ['d']\n  },\n  u: {\n    extend: ['d'],\n    isUnsigned: true\n  },\n  c: {\n    setArg: function(token){\n      if(!isNaN(token.arg)){\n        var num = parseInt(token.arg);\n        if(num < 0 || num > 127){\n          throw new Error('invalid character code passed to %c in printf');\n        }\n        token.arg = isNaN(num) ? '' + num : String.fromCharCode(num);\n      }\n    }\n  },\n  s: {\n    setMaxWidth: function(token){\n      token.maxWidth = (token.period == '.') ? token.precision : -1;\n    }\n  },\n  e: {\n    isDouble: true,\n    doubleNotation: 'e'\n  },\n  E: {\n    extend: ['e'],\n    toUpper: true\n  },\n  f: {\n    isDouble: true,\n    doubleNotation: 'f'\n  },\n  F: {\n    extend: ['f']\n  },\n  g: {\n    isDouble: true,\n    doubleNotation: 'g'\n  },\n  G: {\n    extend: ['g'],\n    toUpper: true\n  },\n  O: {\n    isObject: true\n  }\n};\nFormatter.prototype.format = function(/*mixed...*/ filler){\n  if(this._mapped && typeof filler != 'object'){\n    throw new Error('format requires a mapping');\n  }\n\n  var str = '';\n  var position = 0;\n  for(var i = 0, token; i < this._tokens.length; i++){\n    token = this._tokens[i];\n\n    if(typeof token == 'string'){\n      str += token;\n    }else{\n      if(this._mapped){\n        // Identify value of property defined in `token.mapping`\n        var tokens = token.mapping.split('.');\n        var value = filler;\n        for (var j = 0, c = tokens.length; j < c; j++) {\n          value = value[tokens[j]];\n          if (typeof value === 'undefined') {\n            break\n          }\n        }\n        if(typeof value == 'undefined'){\n          throw new Error('missing key \\'' + token.mapping + '\\'');\n        }\n        token.arg = value;\n      }else{\n        if(token.intmapping){\n          position = parseInt(token.intmapping) - 1;\n        }\n        if(position >= arguments.length){\n          throw new Error('got ' + arguments.length + ' printf arguments, insufficient for \\'' + this._format + '\\'');\n        }\n        token.arg = arguments[position++];\n      }\n\n      if(!token.compiled){\n        token.compiled = true;\n        token.sign = '';\n        token.zeroPad = false;\n        token.rightJustify = false;\n        token.alternative = false;\n\n        var flags = {};\n        for(var fi = token.flags.length; fi--;){\n          var flag = token.flags.charAt(fi);\n          flags[flag] = true;\n          switch(flag){\n            case ' ':\n              token.sign = ' ';\n              break;\n            case '+':\n              token.sign = '+';\n              break;\n            case '0':\n              token.zeroPad = (flags['-']) ? false : true;\n              break;\n            case '-':\n              token.rightJustify = true;\n              token.zeroPad = false;\n              break;\n            case '#':\n              token.alternative = true;\n              break;\n            default:\n              throw Error('bad formatting flag \\'' + token.flags.charAt(fi) + '\\'');\n          }\n        }\n\n        token.minWidth = (token._minWidth) ? parseInt(token._minWidth) : 0;\n        token.maxWidth = -1;\n        token.toUpper = false;\n        token.isUnsigned = false;\n        token.isInt = false;\n        token.isDouble = false;\n        token.isObject = false;\n        token.precision = 1;\n        if(token.period == '.'){\n          if(token._precision){\n            token.precision = parseInt(token._precision);\n          }else{\n            token.precision = 0;\n          }\n        }\n\n        var mixins = this._specifiers[token.specifier];\n        if(typeof mixins == 'undefined'){\n          throw new Error('unexpected specifier \\'' + token.specifier + '\\'');\n        }\n        if(mixins.extend){\n          var s = this._specifiers[mixins.extend];\n          for(var k in s){\n            mixins[k] = s[k];\n          }\n          delete mixins.extend;\n        }\n        for(var l in mixins){\n          token[l] = mixins[l];\n        }\n      }\n\n      if(typeof token.setArg == 'function'){\n        token.setArg(token);\n      }\n\n      if(typeof token.setMaxWidth == 'function'){\n        token.setMaxWidth(token);\n      }\n\n      if(token._minWidth == '*'){\n        if(this._mapped){\n          throw new Error('* width not supported in mapped formats');\n        }\n        token.minWidth = parseInt(arguments[position++]);\n        if(isNaN(token.minWidth)){\n          throw new Error('the argument for * width at position ' + position + ' is not a number in ' + this._format);\n        }\n        // negative width means rightJustify\n        if (token.minWidth < 0) {\n          token.rightJustify = true;\n          token.minWidth = -token.minWidth;\n        }\n      }\n\n      if(token._precision == '*' && token.period == '.'){\n        if(this._mapped){\n          throw new Error('* precision not supported in mapped formats');\n        }\n        token.precision = parseInt(arguments[position++]);\n        if(isNaN(token.precision)){\n          throw Error('the argument for * precision at position ' + position + ' is not a number in ' + this._format);\n        }\n        // negative precision means unspecified\n        if (token.precision < 0) {\n          token.precision = 1;\n          token.period = '';\n        }\n      }\n      if(token.isInt){\n        // a specified precision means no zero padding\n        if(token.period == '.'){\n          token.zeroPad = false;\n        }\n        this.formatInt(token);\n      }else if(token.isDouble){\n        if(token.period != '.'){\n          token.precision = 6;\n        }\n        this.formatDouble(token);\n      }else if(token.isObject){\n        this.formatObject(token);\n      }\n      this.fitField(token);\n      str += '' + token.arg;\n    }\n  }\n\n  return str;\n};\nFormatter.prototype._zeros10 = '0000000000';\nFormatter.prototype._spaces10 = '          ';\nFormatter.prototype.formatInt = function(token) {\n  var i = parseInt(token.arg);\n  if(!isFinite(i)){ // isNaN(f) || f == Number.POSITIVE_INFINITY || f == Number.NEGATIVE_INFINITY)\n    // allow this only if arg is number\n    if(typeof token.arg != 'number'){\n      throw new Error('format argument \\'' + token.arg + '\\' not an integer; parseInt returned ' + i);\n    }\n    //return '' + i;\n    i = 0;\n  }\n\n  // if not base 10, make negatives be positive\n  // otherwise, (-10).toString(16) is '-a' instead of 'fffffff6'\n  if(i < 0 && (token.isUnsigned || token.base != 10)){\n    i = 0xffffffff + i + 1;\n  }\n\n  if(i < 0){\n    token.arg = (- i).toString(token.base);\n    this.zeroPad(token);\n    token.arg = '-' + token.arg;\n  }else{\n    token.arg = i.toString(token.base);\n    // need to make sure that argument 0 with precision==0 is formatted as ''\n    if(!i && !token.precision){\n      token.arg = '';\n    }else{\n      this.zeroPad(token);\n    }\n    if(token.sign){\n      token.arg = token.sign + token.arg;\n    }\n  }\n  if(token.base == 16){\n    if(token.alternative){\n      token.arg = '0x' + token.arg;\n    }\n    token.arg = token.toUpper ? token.arg.toUpperCase() : token.arg.toLowerCase();\n  }\n  if(token.base == 8){\n    if(token.alternative && token.arg.charAt(0) != '0'){\n      token.arg = '0' + token.arg;\n    }\n  }\n};\nFormatter.prototype.formatDouble = function(token) {\n  var f = parseFloat(token.arg);\n  if(!isFinite(f)){ // isNaN(f) || f == Number.POSITIVE_INFINITY || f == Number.NEGATIVE_INFINITY)\n    // allow this only if arg is number\n    if(typeof token.arg != 'number'){\n      throw new Error('format argument \\'' + token.arg + '\\' not a float; parseFloat returned ' + f);\n    }\n    // C99 says that for 'f':\n    //   infinity -> '[-]inf' or '[-]infinity' ('[-]INF' or '[-]INFINITY' for 'F')\n    //   NaN -> a string  starting with 'nan' ('NAN' for 'F')\n    // this is not commonly implemented though.\n    //return '' + f;\n    f = 0;\n  }\n\n  switch(token.doubleNotation) {\n    case 'e': {\n      token.arg = f.toExponential(token.precision);\n      break;\n    }\n    case 'f': {\n      token.arg = f.toFixed(token.precision);\n      break;\n    }\n    case 'g': {\n      // C says use 'e' notation if exponent is < -4 or is >= prec\n      // ECMAScript for toPrecision says use exponential notation if exponent is >= prec,\n      // though step 17 of toPrecision indicates a test for < -6 to force exponential.\n      if(Math.abs(f) < 0.0001){\n        //print('forcing exponential notation for f=' + f);\n        token.arg = f.toExponential(token.precision > 0 ? token.precision - 1 : token.precision);\n      }else{\n        token.arg = f.toPrecision(token.precision);\n      }\n\n      // In C, unlike 'f', 'gG' removes trailing 0s from fractional part, unless alternative format flag ('#').\n      // But ECMAScript formats toPrecision as 0.00100000. So remove trailing 0s.\n      if(!token.alternative){\n        //print('replacing trailing 0 in \\'' + s + '\\'');\n        token.arg = token.arg.replace(/(\\..*[^0])0*e/, '$1e');\n        // if fractional part is entirely 0, remove it and decimal point\n        token.arg = token.arg.replace(/\\.0*e/, 'e').replace(/\\.0$/,'');\n      }\n      break;\n    }\n    default: throw new Error('unexpected double notation \\'' + token.doubleNotation + '\\'');\n  }\n\n  // C says that exponent must have at least two digits.\n  // But ECMAScript does not; toExponential results in things like '1.000000e-8' and '1.000000e+8'.\n  // Note that s.replace(/e([\\+\\-])(\\d)/, 'e$10$2') won't work because of the '$10' instead of '$1'.\n  // And replace(re, func) isn't supported on IE50 or Safari1.\n  token.arg = token.arg.replace(/e\\+(\\d)$/, 'e+0$1').replace(/e\\-(\\d)$/, 'e-0$1');\n\n  // if alt, ensure a decimal point\n  if(token.alternative){\n    token.arg = token.arg.replace(/^(\\d+)$/,'$1.');\n    token.arg = token.arg.replace(/^(\\d+)e/,'$1.e');\n  }\n\n  if(f >= 0 && token.sign){\n    token.arg = token.sign + token.arg;\n  }\n\n  token.arg = token.toUpper ? token.arg.toUpperCase() : token.arg.toLowerCase();\n};\nFormatter.prototype.formatObject = function(token) {\n  // If no precision is specified, then reset it to null (infinite depth).\n  var precision = (token.period === '.') ? token.precision : null;\n  // Historically, inspect was called with 3 options\n  // token.arg = util.inspect(token.arg, !token.alternative, precision, token.sign);\n  // Now using an object but not sure colors make any sense here\n  token.arg = util.inspect(token.arg, {\n    showHidden: !token.alternative,\n    depth: precision,\n    colors: token.sign,\n    compact: true\n  });\n};\nFormatter.prototype.zeroPad = function(token, /*Int*/ length) {\n  length = (arguments.length == 2) ? length : token.precision;\n  var negative = false;\n  if(typeof token.arg != \"string\"){\n    token.arg = \"\" + token.arg;\n  }\n  if (token.arg.substr(0,1) === '-') {\n    negative = true;\n    token.arg = token.arg.substr(1);\n  }\n\n  var tenless = length - 10;\n  while(token.arg.length < tenless){\n    token.arg = (token.rightJustify) ? token.arg + this._zeros10 : this._zeros10 + token.arg;\n  }\n  var pad = length - token.arg.length;\n  token.arg = (token.rightJustify) ? token.arg + this._zeros10.substring(0, pad) : this._zeros10.substring(0, pad) + token.arg;\n  if (negative) token.arg = '-' + token.arg;\n};\nFormatter.prototype.fitField = function(token) {\n  if(token.maxWidth >= 0 && token.arg.length > token.maxWidth){\n    token.arg = token.arg.substring(0, token.maxWidth);\n  }\n  if(token.zeroPad){\n    this.zeroPad(token, token.minWidth);\n    return;\n  }\n  this.spacePad(token);\n};\nFormatter.prototype.spacePad = function(token, /*Int*/ length) {\n  length = (arguments.length == 2) ? length : token.minWidth;\n  if(typeof token.arg != 'string'){\n    token.arg = '' + token.arg;\n  }\n  var tenless = length - 10;\n  while(token.arg.length < tenless){\n    token.arg = (token.rightJustify) ? token.arg + this._spaces10 : this._spaces10 + token.arg;\n  }\n  var pad = length - token.arg.length;\n  token.arg = (token.rightJustify) ? token.arg + this._spaces10.substring(0, pad) : this._spaces10.substring(0, pad) + token.arg;\n};\n\nmodule.exports = function(){\n  var args = Array.prototype.slice.call(arguments),\n    stream, format;\n  if(args[0] instanceof require('stream').Stream){\n    stream = args.shift();\n  }\n  format = args.shift();\n  var formatter = new Formatter(format);\n  var string = formatter.format.apply(formatter, args);\n  if(stream){\n    stream.write(string);\n  }else{\n    return string;\n  }\n};\n\nmodule.exports.Formatter = Formatter;\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4528, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4532, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk/src/internal/utils.ts"],"sourcesContent":["export function convert(v: string | Uint8Array): Uint8Array {\n  if (typeof v === 'string') {\n    return new TextEncoder().encode(v);\n  }\n  return v;\n}\n"],"names":[],"mappings":";;;;;AAAA,SAAgB,QAAQ,CAAsB;IAC5C,IAAI,OAAO,MAAM,UAAU;QACzB,OAAO,IAAI,cAAc,MAAM,CAAC;;IAElC,OAAO;AACT;AALA,QAAA,OAAA,GAAA"}},
    {"offset": {"line": 4544, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4548, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk/src/internal/internal-auth-client.ts"],"sourcesContent":["import {auth, token} from '@gomomento/generated-types';\nimport grpcAuth = auth.auth;\nimport {Header, HeaderInterceptor} from './grpc/headers-interceptor';\nimport {ChannelCredentials, Interceptor} from '@grpc/grpc-js';\nimport {version} from '../../package.json';\nimport {CacheServiceErrorMapper} from '../errors/cache-service-error-mapper';\nimport {\n  InternalSuperUserPermissions,\n  validateDisposableTokenExpiry,\n  validateValidForSeconds,\n  validateCacheKeyOrPrefix,\n  validateDisposableTokenTokenID,\n} from '@gomomento/sdk-core/dist/src/internal/utils';\nimport Never = grpcAuth._GenerateApiTokenRequest.Never;\nimport Expires = grpcAuth._GenerateApiTokenRequest.Expires;\nimport {\n  ExpiresIn,\n  ExpiresAt,\n  CredentialProvider,\n  RefreshApiKey,\n  GenerateApiKey,\n  PermissionScope,\n  Permissions,\n  Permission,\n  TopicPermission,\n  CachePermission,\n  TopicRole,\n  CacheRole,\n  AllCaches,\n  AllTopics,\n  isCacheName,\n  isTopicName,\n  GenerateDisposableToken,\n  AllCacheItems,\n  isCacheItemKey,\n  isCacheItemKeyPrefix,\n  DisposableTokenScope,\n} from '@gomomento/sdk-core';\nimport {IAuthClient} from '@gomomento/sdk-core/dist/src/internal/clients';\nimport {\n  asCachePermission,\n  asPermissionsObject,\n  asTopicPermission,\n  isCachePermission,\n  isPermissionsObject,\n  isTopicPermission,\n  PredefinedScope,\n} from '@gomomento/sdk-core/dist/src/auth/tokens/permission-scope';\nimport {permission_messages} from '@gomomento/generated-types/dist/permissionmessages';\nimport {convert} from './utils';\nimport {\n  asDisposableTokenCachePermission,\n  asDisposableTokenPermissionsObject,\n  DisposableTokenCachePermission,\n  DisposableTokenProps,\n  isDisposableTokenCachePermission,\n  isDisposableTokenPermissionsObject,\n} from '@gomomento/sdk-core/dist/src/auth/tokens/disposable-token-scope';\nimport {RetryInterceptor} from './grpc/retry-interceptor';\nimport {AuthClientConfigurations} from '../index';\nimport {AuthClientAllProps} from './auth-client-all-props';\n\nexport class InternalAuthClient implements IAuthClient {\n  private static readonly REQUEST_TIMEOUT_MS: number = 60 * 1000;\n\n  private readonly cacheServiceErrorMapper: CacheServiceErrorMapper;\n  private readonly creds: CredentialProvider;\n  private readonly interceptors: Interceptor[];\n  private readonly tokenClient: token.token.TokenClient;\n  private readonly authClient: grpcAuth.AuthClient;\n\n  constructor(props: AuthClientAllProps) {\n    const configuration =\n      props.configuration ?? AuthClientConfigurations.Default.latest();\n    this.cacheServiceErrorMapper = new CacheServiceErrorMapper(\n      props.throwOnErrors ?? false\n    );\n    this.creds = props.credentialProvider;\n    const headers = [\n      new Header('agent', `nodejs:auth:${version}`),\n      new Header('runtime-version', `nodejs:${process.versions.node}`),\n    ];\n    this.interceptors = [\n      HeaderInterceptor.createHeadersInterceptor(headers),\n      RetryInterceptor.createRetryInterceptor({\n        clientName: 'AuthClient',\n        loggerFactory: configuration.getLoggerFactory(),\n        overallRequestTimeoutMs: InternalAuthClient.REQUEST_TIMEOUT_MS,\n      }),\n    ];\n    this.tokenClient = new token.token.TokenClient(\n      this.creds.getTokenEndpoint(),\n      this.creds.isTokenEndpointSecure()\n        ? ChannelCredentials.createSsl()\n        : ChannelCredentials.createInsecure()\n    );\n    this.authClient = new grpcAuth.AuthClient(\n      this.creds.getControlEndpoint(),\n      this.creds.isTokenEndpointSecure()\n        ? ChannelCredentials.createSsl()\n        : ChannelCredentials.createInsecure()\n    );\n  }\n\n  public async generateApiKey(\n    scope: PermissionScope,\n    expiresIn: ExpiresIn\n  ): Promise<GenerateApiKey.Response> {\n    let permissions;\n    try {\n      permissions = permissionsFromTokenScope(scope);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new GenerateApiKey.Error(err)\n      );\n    }\n    const request = new grpcAuth._GenerateApiTokenRequest({\n      auth_token: this.creds.getAuthToken(),\n      permissions: permissions,\n    });\n\n    if (expiresIn.doesExpire()) {\n      try {\n        validateValidForSeconds(expiresIn.seconds());\n      } catch (err) {\n        return this.cacheServiceErrorMapper.returnOrThrowError(\n          err as Error,\n          err => new GenerateApiKey.Error(err)\n        );\n      }\n\n      request.expires = new Expires({\n        valid_for_seconds: expiresIn.seconds(),\n      });\n    } else {\n      request.never = new Never();\n    }\n\n    return await new Promise<GenerateApiKey.Response>((resolve, reject) => {\n      this.authClient.GenerateApiToken(\n        request,\n        {interceptors: this.interceptors},\n        (err, resp) => {\n          if (err || !resp) {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new GenerateApiKey.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          } else {\n            resolve(\n              new GenerateApiKey.Success(\n                resp.api_key,\n                resp.refresh_token,\n                resp.endpoint,\n                ExpiresAt.fromEpoch(resp.valid_until)\n              )\n            );\n          }\n        }\n      );\n    });\n  }\n\n  /**\n   * @deprecated please use `generateApiKey` instead\n   */\n  public generateAuthToken(\n    scope: PermissionScope,\n    expiresIn: ExpiresIn\n  ): Promise<GenerateApiKey.Response> {\n    return this.generateApiKey(scope, expiresIn);\n  }\n\n  public async refreshApiKey(\n    refreshToken: string\n  ): Promise<RefreshApiKey.Response> {\n    const request = new grpcAuth._RefreshApiTokenRequest({\n      api_key: this.creds.getAuthToken(),\n      refresh_token: refreshToken,\n    });\n\n    return await new Promise<RefreshApiKey.Response>((resolve, reject) => {\n      this.authClient.RefreshApiToken(\n        request,\n        {interceptors: this.interceptors},\n        (err, resp) => {\n          if (err || !resp) {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new RefreshApiKey.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          } else {\n            resolve(\n              new RefreshApiKey.Success(\n                resp.api_key,\n                resp.refresh_token,\n                resp.endpoint,\n                ExpiresAt.fromEpoch(resp.valid_until)\n              )\n            );\n          }\n        }\n      );\n    });\n  }\n\n  /**\n   * @deprecated please use `refreshApiKey` instead\n   */\n  public refreshAuthToken(\n    refreshToken: string\n  ): Promise<RefreshApiKey.Response> {\n    return this.refreshApiKey(refreshToken);\n  }\n\n  public async generateDisposableToken(\n    scope: DisposableTokenScope,\n    expiresIn: ExpiresIn,\n    disposableTokenProps?: DisposableTokenProps\n  ): Promise<GenerateDisposableToken.Response> {\n    try {\n      validateDisposableTokenExpiry(expiresIn);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new GenerateDisposableToken.Error(err)\n      );\n    }\n    const expires = new token.token._GenerateDisposableTokenRequest.Expires({\n      valid_for_seconds: expiresIn.seconds(),\n    });\n\n    let permissions;\n    try {\n      permissions = permissionsFromDisposableTokenScope(scope);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new GenerateDisposableToken.Error(err)\n      );\n    }\n\n    const tokenId = disposableTokenProps?.tokenId;\n    if (tokenId !== undefined) {\n      try {\n        validateDisposableTokenTokenID(tokenId);\n      } catch (err) {\n        return this.cacheServiceErrorMapper.returnOrThrowError(\n          err as Error,\n          err => new GenerateDisposableToken.Error(err)\n        );\n      }\n    }\n\n    const request = new token.token._GenerateDisposableTokenRequest({\n      expires: expires,\n      auth_token: this.creds.getAuthToken(),\n      permissions: permissions,\n      token_id: tokenId,\n    });\n\n    return await new Promise<GenerateDisposableToken.Response>(\n      (resolve, reject) => {\n        this.tokenClient.GenerateDisposableToken(\n          request,\n          {interceptors: this.interceptors},\n          (err, resp) => {\n            if (err || !resp) {\n              this.cacheServiceErrorMapper.resolveOrRejectError({\n                err: err,\n                errorResponseFactoryFn: e =>\n                  new GenerateDisposableToken.Error(e),\n                resolveFn: resolve,\n                rejectFn: reject,\n              });\n            } else {\n              resolve(\n                new GenerateDisposableToken.Success(\n                  resp.api_key,\n                  resp.endpoint,\n                  ExpiresAt.fromEpoch(resp.valid_until)\n                )\n              );\n            }\n          }\n        );\n      }\n    );\n  }\n}\n\nexport function permissionsFromTokenScope(\n  scope: PermissionScope\n): permission_messages.Permissions {\n  const result = new permission_messages.Permissions();\n  if (scope instanceof InternalSuperUserPermissions) {\n    result.super_user = permission_messages.SuperUserPermissions.SuperUser;\n    return result;\n  } else if (isPermissionsObject(scope)) {\n    const scopePermissions: Permissions = asPermissionsObject(scope);\n    const explicitPermissions = new permission_messages.ExplicitPermissions();\n    explicitPermissions.permissions = scopePermissions.permissions.map(p =>\n      tokenPermissionToGrpcPermission(p)\n    );\n    result.explicit = explicitPermissions;\n    return result;\n  }\n  throw new Error(`Unrecognized token scope: ${JSON.stringify(scope)}`);\n}\n\nexport function permissionsFromDisposableTokenScope(\n  scope: DisposableTokenScope\n): permission_messages.Permissions {\n  const result = new permission_messages.Permissions();\n  if (\n    !(scope instanceof PredefinedScope) &&\n    isDisposableTokenPermissionsObject(scope)\n  ) {\n    const scopePermissions = asDisposableTokenPermissionsObject(scope);\n    const explicitPermissions = new permission_messages.ExplicitPermissions();\n    explicitPermissions.permissions = scopePermissions.permissions.map(p =>\n      disposableTokenPermissionToGrpcPermission(p)\n    );\n    result.explicit = explicitPermissions;\n    return result;\n  } else if (isPermissionsObject(scope)) {\n    const scopePermissions: Permissions = asPermissionsObject(scope);\n    const explicitPermissions = new permission_messages.ExplicitPermissions();\n    explicitPermissions.permissions = scopePermissions.permissions.map(p =>\n      tokenPermissionToGrpcPermission(p)\n    );\n    result.explicit = explicitPermissions;\n    return result;\n  }\n  throw new Error(`Unrecognized token scope: ${JSON.stringify(scope)}`);\n}\n\nfunction tokenPermissionToGrpcPermission(\n  permission: Permission\n): permission_messages.PermissionsType {\n  const result = new permission_messages.PermissionsType();\n  if (isTopicPermission(permission)) {\n    result.topic_permissions = topicPermissionToGrpcPermission(\n      asTopicPermission(permission)\n    );\n    return result;\n  } else if (isCachePermission(permission)) {\n    result.cache_permissions = cachePermissionToGrpcPermission(\n      asCachePermission(permission)\n    );\n    return result;\n  }\n  throw new Error(\n    `Unrecognized token permission: ${JSON.stringify(permission)}`\n  );\n}\n\nfunction topicPermissionToGrpcPermission(\n  permission: TopicPermission\n): permission_messages.PermissionsType.TopicPermissions {\n  const grpcPermission =\n    new permission_messages.PermissionsType.TopicPermissions();\n  switch (permission.role) {\n    case TopicRole.PublishSubscribe: {\n      grpcPermission.role = permission_messages.TopicRole.TopicReadWrite;\n      break;\n    }\n    case TopicRole.SubscribeOnly: {\n      grpcPermission.role = permission_messages.TopicRole.TopicReadOnly;\n      break;\n    }\n    case TopicRole.PublishOnly: {\n      grpcPermission.role = permission_messages.TopicRole.TopicWriteOnly;\n      break;\n    }\n    default: {\n      throw new Error(`Unrecognized topic role: ${JSON.stringify(permission)}`);\n    }\n  }\n\n  if (permission.cache === AllCaches) {\n    grpcPermission.all_caches = new permission_messages.PermissionsType.All();\n  } else if (typeof permission.cache === 'string') {\n    grpcPermission.cache_selector =\n      new permission_messages.PermissionsType.CacheSelector({\n        cache_name: permission.cache,\n      });\n  } else if (isCacheName(permission.cache)) {\n    grpcPermission.cache_selector =\n      new permission_messages.PermissionsType.CacheSelector({\n        cache_name: permission.cache.name,\n      });\n  } else {\n    throw new Error(\n      `Unrecognized cache specification in topic permission: ${JSON.stringify(\n        permission\n      )}`\n    );\n  }\n\n  if (permission.topic === AllTopics) {\n    grpcPermission.all_topics = new permission_messages.PermissionsType.All();\n  } else if (typeof permission.topic === 'string') {\n    grpcPermission.topic_selector =\n      new permission_messages.PermissionsType.TopicSelector({\n        topic_name: permission.topic,\n      });\n  } else if (isTopicName(permission.topic)) {\n    grpcPermission.topic_selector =\n      new permission_messages.PermissionsType.TopicSelector({\n        topic_name: permission.topic.name,\n      });\n  } else {\n    throw new Error(\n      `Unrecognized topic specification in topic permission: ${JSON.stringify(\n        permission\n      )}`\n    );\n  }\n  return grpcPermission;\n}\n\nfunction assignCacheRole(\n  permission: CachePermission | DisposableTokenCachePermission,\n  grpcPermission: permission_messages.PermissionsType.CachePermissions\n): permission_messages.PermissionsType.CachePermissions {\n  switch (permission.role) {\n    case CacheRole.ReadWrite: {\n      grpcPermission.role = permission_messages.CacheRole.CacheReadWrite;\n      break;\n    }\n    case CacheRole.ReadOnly: {\n      grpcPermission.role = permission_messages.CacheRole.CacheReadOnly;\n      break;\n    }\n    case CacheRole.WriteOnly: {\n      grpcPermission.role = permission_messages.CacheRole.CacheWriteOnly;\n      break;\n    }\n    default: {\n      throw new Error(`Unrecognized cache role: ${JSON.stringify(permission)}`);\n    }\n  }\n  return grpcPermission;\n}\n\nfunction assignCacheSelector(\n  permission: CachePermission | DisposableTokenCachePermission,\n  grpcPermission: permission_messages.PermissionsType.CachePermissions\n): permission_messages.PermissionsType.CachePermissions {\n  if (permission.cache === AllCaches) {\n    grpcPermission.all_caches = new permission_messages.PermissionsType.All();\n  } else if (typeof permission.cache === 'string') {\n    grpcPermission.cache_selector =\n      new permission_messages.PermissionsType.CacheSelector({\n        cache_name: permission.cache,\n      });\n  } else if (isCacheName(permission.cache)) {\n    grpcPermission.cache_selector =\n      new permission_messages.PermissionsType.CacheSelector({\n        cache_name: permission.cache.name,\n      });\n  } else {\n    throw new Error(\n      `Unrecognized cache specification in cache permission: ${JSON.stringify(\n        permission\n      )}`\n    );\n  }\n  return grpcPermission;\n}\n\nfunction assignCacheItemSelector(\n  permission: DisposableTokenCachePermission,\n  grpcPermission: permission_messages.PermissionsType.CachePermissions\n): permission_messages.PermissionsType.CachePermissions {\n  if (permission.item === AllCacheItems) {\n    grpcPermission.all_items = new permission_messages.PermissionsType.All();\n  } else if (typeof permission.item === 'string') {\n    grpcPermission.item_selector =\n      new permission_messages.PermissionsType.CacheItemSelector({\n        key: convert(permission.item),\n      });\n  } else if (isCacheItemKey(permission.item)) {\n    validateCacheKeyOrPrefix(permission.item.key);\n    grpcPermission.item_selector =\n      new permission_messages.PermissionsType.CacheItemSelector({\n        key: convert(permission.item.key),\n      });\n  } else if (isCacheItemKeyPrefix(permission.item)) {\n    validateCacheKeyOrPrefix(permission.item.keyPrefix);\n    grpcPermission.item_selector =\n      new permission_messages.PermissionsType.CacheItemSelector({\n        key_prefix: convert(permission.item.keyPrefix),\n      });\n  } else {\n    throw new Error(\n      `Unrecognized cache item specification in cache permission: ${JSON.stringify(\n        permission\n      )}`\n    );\n  }\n  return grpcPermission;\n}\n\nfunction cachePermissionToGrpcPermission(\n  permission: CachePermission\n): permission_messages.PermissionsType.CachePermissions {\n  let grpcPermission =\n    new permission_messages.PermissionsType.CachePermissions();\n  grpcPermission = assignCacheRole(permission, grpcPermission);\n  grpcPermission = assignCacheSelector(permission, grpcPermission);\n  return grpcPermission;\n}\n\nfunction disposableTokenPermissionToGrpcPermission(\n  permission: DisposableTokenCachePermission\n): permission_messages.PermissionsType {\n  const result = new permission_messages.PermissionsType();\n  if (isDisposableTokenCachePermission(permission)) {\n    result.cache_permissions = disposableCachePermissionToGrpcPermission(\n      asDisposableTokenCachePermission(permission)\n    );\n    return result;\n  }\n  throw new Error(\n    `Unrecognized token permission: ${JSON.stringify(permission)}`\n  );\n}\n\nfunction disposableCachePermissionToGrpcPermission(\n  permission: DisposableTokenCachePermission\n): permission_messages.PermissionsType.CachePermissions {\n  let grpcPermission =\n    new permission_messages.PermissionsType.CachePermissions();\n  grpcPermission = assignCacheRole(permission, grpcPermission);\n  grpcPermission = assignCacheSelector(permission, grpcPermission);\n  grpcPermission = assignCacheItemSelector(permission, grpcPermission);\n\n  return grpcPermission;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4889, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4893, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk/src/internal/leaderboard-data-client.ts"],"sourcesContent":["import {\n  CredentialProvider,\n  InvalidArgumentError,\n  LeaderboardDelete,\n  LeaderboardFetch,\n  LeaderboardLength,\n  LeaderboardRemoveElements,\n  LeaderboardUpsert,\n  MomentoLogger,\n  MomentoLoggerFactory,\n  LeaderboardOrder,\n} from '@gomomento/sdk-core';\nimport {\n  validateLeaderboardNumberOfElements,\n  validateSortedSetScores,\n  validateLeaderboardOffset,\n  validateLeaderboardCount,\n  validateLeaderboardRanks,\n  range,\n} from '@gomomento/sdk-core/dist/src/internal/utils';\nimport {LeaderboardConfiguration} from '../config/leaderboard-configuration';\nimport {leaderboard} from '@gomomento/generated-types/dist/leaderboard';\nimport _Element = leaderboard._Element;\nimport {IdleGrpcClientWrapper} from './grpc/idle-grpc-client-wrapper';\nimport {GrpcClientWrapper} from './grpc/grpc-client-wrapper';\nimport {Header, HeaderInterceptor} from './grpc/headers-interceptor';\nimport {CacheServiceErrorMapper} from '../errors/cache-service-error-mapper';\nimport {\n  ChannelCredentials,\n  Interceptor,\n  Metadata,\n  ServiceError,\n} from '@grpc/grpc-js';\nimport {version} from '../../package.json';\nimport {ILeaderboardDataClient} from '@gomomento/sdk-core/dist/src/internal/clients/leaderboard/ILeaderboardDataClient';\nimport {LeaderboardClientAllProps} from './leaderboard-client-all-props';\nimport {middlewaresInterceptor} from './grpc/middlewares-interceptor';\nimport {\n  Middleware,\n  MiddlewareRequestHandlerContext,\n} from '../config/middleware/middleware';\nimport {grpcChannelOptionsFromGrpcConfig} from './grpc/grpc-channel-options';\nimport {common} from '@gomomento/generated-types/dist/common';\nimport {RetryInterceptor} from './grpc/retry-interceptor';\n\nexport const CONNECTION_ID_KEY = Symbol('connectionID');\n\nexport class LeaderboardDataClient implements ILeaderboardDataClient {\n  private readonly configuration: LeaderboardConfiguration;\n  private readonly credentialProvider: CredentialProvider;\n  private readonly logger: MomentoLogger;\n  private readonly cacheServiceErrorMapper: CacheServiceErrorMapper;\n  private readonly requestTimeoutMs: number;\n  private readonly clientWrappers: GrpcClientWrapper<leaderboard.LeaderboardClient>[];\n  protected nextDataClientIndex: number;\n  private readonly interceptors: Interceptor[];\n\n  /**\n   * @param {LeaderboardClientAllProps} props\n   * @param dataClientID\n   */\n  constructor(props: LeaderboardClientAllProps, dataClientID: string) {\n    this.configuration = props.configuration;\n    this.cacheServiceErrorMapper = new CacheServiceErrorMapper(\n      props.configuration.getThrowOnErrors()\n    );\n    this.credentialProvider = props.credentialProvider;\n    this.logger = this.configuration.getLoggerFactory().getLogger(this);\n    const grpcConfig = this.configuration\n      .getTransportStrategy()\n      .getGrpcConfig();\n\n    this.requestTimeoutMs = grpcConfig.getDeadlineMillis();\n    this.validateRequestTimeout(this.requestTimeoutMs);\n    this.logger.debug(\n      `Creating leaderboard client using endpoint: '${this.credentialProvider.getCacheEndpoint()}'`\n    );\n\n    const numDataClients = grpcConfig.getNumClients();\n\n    // We round-robin the requests through all of our clients.  Since javascript\n    // is single-threaded, we don't have to worry about thread safety on this\n    // index variable.\n    this.nextDataClientIndex = 0;\n\n    const channelOptions = grpcChannelOptionsFromGrpcConfig(grpcConfig);\n\n    this.clientWrappers = range(numDataClients).map(\n      () =>\n        new IdleGrpcClientWrapper({\n          clientFactoryFn: () =>\n            new leaderboard.LeaderboardClient(\n              this.credentialProvider.getCacheEndpoint(),\n              this.credentialProvider.isCacheEndpointSecure()\n                ? ChannelCredentials.createSsl()\n                : ChannelCredentials.createInsecure(),\n              channelOptions\n            ),\n          loggerFactory: this.configuration.getLoggerFactory(),\n          maxIdleMillis: this.configuration\n            .getTransportStrategy()\n            .getMaxIdleMillis(),\n        })\n    );\n\n    const context: MiddlewareRequestHandlerContext = {};\n    context[CONNECTION_ID_KEY] = dataClientID;\n    this.interceptors = this.initializeInterceptors(\n      this.configuration.getLoggerFactory(),\n      this.configuration.getMiddlewares(),\n      context\n    );\n  }\n\n  close() {\n    this.logger.debug('Closing leaderboard data clients');\n    this.clientWrappers.map(wrapper => wrapper.getClient().close());\n  }\n\n  private validateRequestTimeout(timeout?: number) {\n    this.logger.debug(`Request timeout ms: ${String(timeout)}`);\n    if (timeout !== undefined && timeout <= 0) {\n      throw new InvalidArgumentError(\n        'request timeout must be greater than zero.'\n      );\n    }\n  }\n\n  private initializeInterceptors(\n    _loggerFactory: MomentoLoggerFactory,\n    middlewares: Middleware[],\n    middlewareRequestContext: MiddlewareRequestHandlerContext\n  ): Interceptor[] {\n    const headers = [\n      new Header('Authorization', this.credentialProvider.getAuthToken()),\n      new Header('agent', `nodejs:leaderboard:${version}`),\n      new Header('runtime-version', `nodejs:${process.versions.node}`),\n    ];\n    return [\n      middlewaresInterceptor(\n        _loggerFactory,\n        middlewares,\n        middlewareRequestContext\n      ),\n      HeaderInterceptor.createHeadersInterceptor(headers),\n      RetryInterceptor.createRetryInterceptor({\n        clientName: 'LeaderboardDataClient',\n        loggerFactory: _loggerFactory,\n        overallRequestTimeoutMs: this.requestTimeoutMs,\n      }),\n    ];\n  }\n\n  private createMetadata(cacheName: string): Metadata {\n    const metadata = new Metadata();\n    metadata.set('cache', cacheName);\n    return metadata;\n  }\n\n  private convertMapOrRecordToElementsList(\n    elements: Record<number, number> | Map<number, number>\n  ): _Element[] {\n    const convertedElements: _Element[] = [];\n    if (elements instanceof Map) {\n      elements.forEach((score, id) =>\n        convertedElements.push(new _Element({id: id, score: score}))\n      );\n    } else {\n      Object.entries(elements).forEach(element =>\n        convertedElements.push(\n          new _Element({id: Number(element[0]), score: element[1]})\n        )\n      );\n    }\n    return convertedElements;\n  }\n\n  public async upsert(\n    cacheName: string,\n    leaderboardName: string,\n    elements: Record<number, number> | Map<number, number>\n  ): Promise<LeaderboardUpsert.Response> {\n    const size =\n      elements instanceof Map ? elements.size : Object.keys(elements).length;\n    try {\n      validateLeaderboardNumberOfElements(size);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new LeaderboardUpsert.Error(err)\n      );\n    }\n    this.logger.trace(\n      `Issuing 'upsert' request; cache: ${cacheName}, leaderboard: ${leaderboardName}, number of elements: ${size}`\n    );\n    return await this.sendUpsert(cacheName, leaderboardName, elements);\n  }\n\n  private async sendUpsert(\n    cacheName: string,\n    leaderboardName: string,\n    elements: Record<number, number> | Map<number, number>\n  ): Promise<LeaderboardUpsert.Response> {\n    const request = new leaderboard._UpsertElementsRequest({\n      cache_name: cacheName,\n      leaderboard: leaderboardName,\n      elements: this.convertMapOrRecordToElementsList(elements),\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.getNextDataClient().UpsertElements(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err: ServiceError | null, resp: unknown) => {\n          if (resp) {\n            resolve(new LeaderboardUpsert.Success());\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new LeaderboardUpsert.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async fetchByScore(\n    cacheName: string,\n    leaderboardName: string,\n    minScore?: number,\n    maxScore?: number,\n    order?: LeaderboardOrder,\n    offset?: number,\n    count?: number\n  ): Promise<LeaderboardFetch.Response> {\n    const offsetValue = offset === undefined ? 0 : offset;\n    const countValue = count === undefined ? 8192 : count;\n    const orderValue = order ?? LeaderboardOrder.Ascending;\n    try {\n      validateSortedSetScores(minScore, maxScore);\n      validateLeaderboardOffset(offsetValue);\n      validateLeaderboardCount(countValue);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new LeaderboardFetch.Error(err)\n      );\n    }\n    this.logger.trace(\n      `Issuing 'fetchByScore' request; cache: ${cacheName}, leaderboard: ${leaderboardName}, order: ${orderValue.toString()}, minScore: ${\n        minScore ?? 'null'\n      }, maxScore: ${\n        maxScore?.toString() ?? 'null'\n      }, offset: ${offsetValue.toString()}, count: ${countValue.toString()}`\n    );\n    return await this.sendFetchByScore(\n      cacheName,\n      leaderboardName,\n      orderValue,\n      offsetValue,\n      countValue,\n      minScore,\n      maxScore\n    );\n  }\n\n  private async sendFetchByScore(\n    cacheName: string,\n    leaderboardName: string,\n    order: LeaderboardOrder,\n    offset: number,\n    count: number,\n    minScore?: number,\n    maxScore?: number\n  ): Promise<LeaderboardFetch.Response> {\n    const protoBufOrder =\n      order === LeaderboardOrder.Descending\n        ? leaderboard._Order.DESCENDING\n        : leaderboard._Order.ASCENDING;\n\n    const protoBufScoreRange = new leaderboard._ScoreRange();\n    if (minScore !== undefined) {\n      protoBufScoreRange.min_inclusive = minScore;\n    } else {\n      protoBufScoreRange.unbounded_min = new common._Unbounded();\n    }\n    if (maxScore !== undefined) {\n      protoBufScoreRange.max_exclusive = maxScore;\n    } else {\n      protoBufScoreRange.unbounded_max = new common._Unbounded();\n    }\n\n    const request = new leaderboard._GetByScoreRequest({\n      cache_name: cacheName,\n      leaderboard: leaderboardName,\n      score_range: protoBufScoreRange,\n      order: protoBufOrder,\n      offset: offset,\n      limit_elements: count,\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.getNextDataClient().GetByScore(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err: ServiceError | null, resp: unknown) => {\n          if (resp) {\n            const foundElements = (resp as leaderboard._GetByScoreResponse)\n              .elements;\n            resolve(new LeaderboardFetch.Success(foundElements));\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new LeaderboardFetch.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async fetchByRank(\n    cacheName: string,\n    leaderboardName: string,\n    startRank: number,\n    endRank: number,\n    order?: LeaderboardOrder\n  ): Promise<LeaderboardFetch.Response> {\n    const rankOrder = order ?? LeaderboardOrder.Ascending;\n    try {\n      validateLeaderboardRanks(startRank, endRank);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new LeaderboardFetch.Error(err)\n      );\n    }\n    this.logger.trace(\n      `Issuing 'fetchByRank' request; cache: ${cacheName}, leaderboard: ${leaderboardName}, order: ${rankOrder.toString()}, startRank: ${startRank}, endRank: ${endRank}`\n    );\n    return await this.sendFetchByRank(\n      cacheName,\n      leaderboardName,\n      startRank,\n      endRank,\n      rankOrder\n    );\n  }\n\n  private async sendFetchByRank(\n    cacheName: string,\n    leaderboardName: string,\n    startRank: number,\n    endRank: number,\n    order: LeaderboardOrder\n  ): Promise<LeaderboardFetch.Response> {\n    const protoBufOrder =\n      order === LeaderboardOrder.Descending\n        ? leaderboard._Order.DESCENDING\n        : leaderboard._Order.ASCENDING;\n\n    const protoBufRankRange = new leaderboard._RankRange({\n      start_inclusive: startRank,\n      end_exclusive: endRank,\n    });\n\n    const request = new leaderboard._GetByRankRequest({\n      cache_name: cacheName,\n      leaderboard: leaderboardName,\n      rank_range: protoBufRankRange,\n      order: protoBufOrder,\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.getNextDataClient().GetByRank(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err: ServiceError | null, resp: unknown) => {\n          if (resp) {\n            const foundElements = (resp as leaderboard._GetByRankResponse)\n              .elements;\n            resolve(new LeaderboardFetch.Success(foundElements));\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new LeaderboardFetch.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async getRank(\n    cacheName: string,\n    leaderboardName: string,\n    ids: Array<number>,\n    order?: LeaderboardOrder\n  ): Promise<LeaderboardFetch.Response> {\n    const orderValue = order ?? LeaderboardOrder.Ascending;\n    this.logger.trace(\n      `Issuing 'getRank' request; cache: ${cacheName}, leaderboard: ${leaderboardName}, order: ${orderValue.toString()}, number of ids: ${\n        ids.length\n      }`\n    );\n    return await this.sendGetRank(cacheName, leaderboardName, ids, orderValue);\n  }\n\n  private async sendGetRank(\n    cacheName: string,\n    leaderboardName: string,\n    ids: Array<number>,\n    order: LeaderboardOrder\n  ): Promise<LeaderboardFetch.Response> {\n    const protoBufOrder =\n      order === LeaderboardOrder.Descending\n        ? leaderboard._Order.DESCENDING\n        : leaderboard._Order.ASCENDING;\n\n    const request = new leaderboard._GetRankRequest({\n      cache_name: cacheName,\n      leaderboard: leaderboardName,\n      ids: ids,\n      order: protoBufOrder,\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.getNextDataClient().GetRank(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err: ServiceError | null, resp: unknown) => {\n          if (resp) {\n            const foundElements = (resp as leaderboard._GetRankResponse)\n              .elements;\n            resolve(new LeaderboardFetch.Success(foundElements));\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new LeaderboardFetch.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async length(\n    cacheName: string,\n    leaderboardName: string\n  ): Promise<LeaderboardLength.Response> {\n    this.logger.trace(\n      `Issuing 'length' request; cache: ${cacheName}, leaderboard: ${leaderboardName}`\n    );\n    return await this.sendLength(cacheName, leaderboardName);\n  }\n\n  private async sendLength(\n    cacheName: string,\n    leaderboardName: string\n  ): Promise<LeaderboardLength.Response> {\n    const request = new leaderboard._GetLeaderboardLengthRequest({\n      cache_name: cacheName,\n      leaderboard: leaderboardName,\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.getNextDataClient().GetLeaderboardLength(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err: ServiceError | null, resp: unknown) => {\n          if (resp) {\n            const length = (resp as leaderboard._GetLeaderboardLengthResponse)\n              .count;\n            resolve(new LeaderboardLength.Success(length));\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new LeaderboardLength.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async removeElements(\n    cacheName: string,\n    leaderboardName: string,\n    ids: Array<number>\n  ): Promise<LeaderboardRemoveElements.Response> {\n    try {\n      validateLeaderboardNumberOfElements(ids.length);\n    } catch (err) {\n      return this.cacheServiceErrorMapper.returnOrThrowError(\n        err as Error,\n        err => new LeaderboardRemoveElements.Error(err)\n      );\n    }\n    this.logger.trace(\n      `Issuing 'removeElements' request; cache: ${cacheName}, leaderboard: ${leaderboardName}, number of elements: ${ids.length.toString()}`\n    );\n    return await this.sendRemoveElements(cacheName, leaderboardName, ids);\n  }\n\n  private async sendRemoveElements(\n    cacheName: string,\n    leaderboardName: string,\n    ids: Array<number>\n  ): Promise<LeaderboardRemoveElements.Response> {\n    const request = new leaderboard._RemoveElementsRequest({\n      cache_name: cacheName,\n      leaderboard: leaderboardName,\n      ids: ids,\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.getNextDataClient().RemoveElements(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err: ServiceError | null, resp: unknown) => {\n          if (resp) {\n            resolve(new LeaderboardRemoveElements.Success());\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e =>\n                new LeaderboardRemoveElements.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  public async delete(\n    cacheName: string,\n    leaderboardName: string\n  ): Promise<LeaderboardDelete.Response> {\n    this.logger.trace(\n      `Issuing 'delete' request; cache: ${cacheName}, leaderboard: ${leaderboardName}`\n    );\n    return await this.sendDelete(cacheName, leaderboardName);\n  }\n\n  private async sendDelete(\n    cacheName: string,\n    leaderboardName: string\n  ): Promise<LeaderboardDelete.Response> {\n    const request = new leaderboard._DeleteLeaderboardRequest({\n      cache_name: cacheName,\n      leaderboard: leaderboardName,\n    });\n    const metadata = this.createMetadata(cacheName);\n    return await new Promise((resolve, reject) => {\n      this.getNextDataClient().DeleteLeaderboard(\n        request,\n        metadata,\n        {\n          interceptors: this.interceptors,\n        },\n        (err: ServiceError | null, resp: unknown) => {\n          if (resp) {\n            resolve(new LeaderboardDelete.Success());\n          } else {\n            this.cacheServiceErrorMapper.resolveOrRejectError({\n              err: err,\n              errorResponseFactoryFn: e => new LeaderboardDelete.Error(e),\n              resolveFn: resolve,\n              rejectFn: reject,\n            });\n          }\n        }\n      );\n    });\n  }\n\n  protected getNextDataClient(): leaderboard.LeaderboardClient {\n    const clientWrapper = this.clientWrappers[this.nextDataClientIndex];\n    this.nextDataClientIndex =\n      (this.nextDataClientIndex + 1) % this.clientWrappers.length;\n    return clientWrapper.getClient();\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5243, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5247, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@gomomento/sdk/src/internal/leaderboard.ts"],"sourcesContent":["import {InvalidArgumentError} from '@gomomento/sdk-core';\nimport {\n  AbstractLeaderboard,\n  ILeaderboard,\n} from '@gomomento/sdk-core/dist/src/internal/clients/leaderboard';\nimport {ILeaderboardDataClient} from '@gomomento/sdk-core/dist/src/internal/clients/leaderboard/ILeaderboardDataClient';\nimport {\n  validateCacheName,\n  validateLeaderboardName,\n} from '@gomomento/sdk-core/dist/src/internal/utils';\n\nexport class Leaderboard extends AbstractLeaderboard implements ILeaderboard {\n  constructor(\n    dataClient: ILeaderboardDataClient,\n    cacheName: string,\n    leaderboardName: string\n  ) {\n    try {\n      validateCacheName(cacheName);\n      validateLeaderboardName(leaderboardName);\n    } catch (err) {\n      throw new InvalidArgumentError(\n        'cache name and leaderboard name must not be empty strings'\n      );\n    }\n    super(cacheName, leaderboardName, dataClient);\n  }\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAA;AACA,MAAA;AAKA,MAAA;AAKA,MAAa,oBAAoB,cAAA,mBAAmB;IAClD,YACE,UAAkC,EAClC,SAAiB,EACjB,eAAuB,CAAA;QAEvB,IAAI;YACF,CAAA,GAAA,QAAA,iBAAiB,EAAC;YAClB,CAAA,GAAA,QAAA,uBAAuB,EAAC;UACxB,OAAO,KAAK;YACZ,MAAM,IAAI,WAAA,oBAAoB,CAC5B;;QAGJ,KAAK,CAAC,WAAW,iBAAiB;IACpC;;AAfF,QAAA,WAAA,GAAA"}},
    {"offset": {"line": 5267, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}